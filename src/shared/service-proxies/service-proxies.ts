/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from "rxjs/operators";
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from "@angular/common/http";

import * as moment from "moment";

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

@Injectable()
export class AccountServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isTenantAvailable(
    body: IsTenantAvailableInput | undefined
  ): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsTenantAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsTenantAvailable(<any>response_);
            } catch (e) {
              return <Observable<IsTenantAvailableOutput>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IsTenantAvailableOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processIsTenantAvailable(
    response: HttpResponseBase
  ): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IsTenantAvailableOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IsTenantAvailableOutput>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: RegisterInput | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/Register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(<any>response_);
            } catch (e) {
              return <Observable<RegisterOutput>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RegisterOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processRegister(
    response: HttpResponseBase
  ): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RegisterOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RegisterOutput>(<any>null);
  }
}

@Injectable()
export class AdditionalDetailServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<AdditionalDetailsDto> {
    let url_ = this.baseUrl + "/api/services/app/AdditionalDetailServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<AdditionalDetailsDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: AdditionalDetailsDto | undefined
  ): Observable<AdditionalDetailsDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: AdditionalDetailsDto | undefined
  ): Observable<AdditionalDetailsDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalDetailsDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalDetailsDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<AdditionalDetailsDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalDetailsDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalDetailsDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalDetailServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class AdditionalIncomeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: AdditionalIncomeDto | undefined
  ): Observable<AdditionalIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<AdditionalIncomeDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<Additionalincome[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdditionalIncomeService/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<Additionalincome[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Additionalincome[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<Additionalincome[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(Additionalincome.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Additionalincome[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<AdditionalIncomeDto> {
    let url_ = this.baseUrl + "/api/services/app/AdditionalIncomeService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: AdditionalIncomeDto | undefined
  ): Observable<AdditionalIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/AdditionalIncomeService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<AdditionalIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AdditionalIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<AdditionalIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AdditionalIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AdditionalIncomeDto>(<any>null);
  }
}

@Injectable()
export class AdminDisclosureServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminDisclosure | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/AdminDisclosureService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminDisclosureService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateAdminDisclosure[]> {
    let url_ = this.baseUrl + "/api/services/app/AdminDisclosureService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminDisclosure[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminDisclosure[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateAdminDisclosure[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAdminDisclosure.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminDisclosure[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateAdminDisclosure> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminDisclosureService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminDisclosure>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminDisclosure>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateAdminDisclosure> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAdminDisclosure.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminDisclosure>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminDisclosure | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/AdminDisclosureService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AdminLoanApplicationDocumentServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanApplicationDocument | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateAdminLoanApplicationDocument[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanApplicationDocument[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanApplicationDocument[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanApplicationDocument[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAdminLoanApplicationDocument.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanApplicationDocument[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(
    id: number | undefined
  ): Observable<UpdateAdminLoanApplicationDocument> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanApplicationDocument>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanApplicationDocument>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanApplicationDocument> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAdminLoanApplicationDocument.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanApplicationDocument>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateAdminLoanApplicationDocument | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param loanId (optional)
   * @param disclosureId (optional)
   * @param userId (optional)
   * @param formFile (optional)
   * @return Success
   */
  uploadFile(
    loanId: number | undefined,
    disclosureId: number | undefined,
    userId: number | undefined,
    formFile: FileParameter | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/UploadFile";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (loanId === null || loanId === undefined)
      throw new Error("The parameter 'loanId' cannot be null.");
    else content_.append("LoanId", loanId.toString());
    if (disclosureId === null || disclosureId === undefined)
      throw new Error("The parameter 'disclosureId' cannot be null.");
    else content_.append("DisclosureId", disclosureId.toString());
    if (userId === null || userId === undefined)
      throw new Error("The parameter 'userId' cannot be null.");
    else content_.append("UserId", userId.toString());
    if (formFile === null || formFile === undefined)
      throw new Error("The parameter 'formFile' cannot be null.");
    else
      content_.append(
        "formFile",
        formFile.data,
        formFile.fileName ? formFile.fileName : "formFile"
      );

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadFile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadFile(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUploadFile(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param disId (optional)
   * @param userID (optional)
   * @return Success
   */
  deleteFile(
    disId: number | undefined,
    userID: number | undefined
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/DeleteFile?";
    if (disId === null)
      throw new Error("The parameter 'disId' cannot be null.");
    else if (disId !== undefined)
      url_ += "disId=" + encodeURIComponent("" + disId) + "&";
    if (userID === null)
      throw new Error("The parameter 'userID' cannot be null.");
    else if (userID !== undefined)
      url_ += "userID=" + encodeURIComponent("" + userID) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteFile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteFile(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteFile(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  uploadDocument(
    body: UploadAdminLoanApplicationDocument | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminLoanApplicationDocumentService/UploadDocument";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadDocument(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadDocument(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUploadDocument(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AdminLoanDetailServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanDetail | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/AdminLoanDetailService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanDetailService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateAdminLoanDetail[]> {
    let url_ = this.baseUrl + "/api/services/app/AdminLoanDetailService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanDetail[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanDetail[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanDetail[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAdminLoanDetail.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanDetail[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateAdminLoanDetail> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanDetailService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanDetail>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanDetail>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanDetail> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAdminLoanDetail.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanDetail>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanDetail | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/AdminLoanDetailService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AdminLoanProgramServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanProgram | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/AdminLoanProgramService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanProgramService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateAdminLoanProgram[]> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanProgramService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanProgram[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanProgram[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanProgram[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAdminLoanProgram.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanProgram[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateAdminLoanProgram> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanProgramService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanProgram>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanProgram>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanProgram> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAdminLoanProgram.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanProgram>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanProgram | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanProgramService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AdminLoanStatusServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanStatus | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/AdminLoanStatusService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanStatusService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateAdminLoanStatus[]> {
    let url_ = this.baseUrl + "/api/services/app/AdminLoanStatusService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanStatus[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanStatus[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanStatus[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAdminLoanStatus.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanStatus[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateAdminLoanStatus> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanStatusService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanStatus>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanStatus>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAdminLoanStatus.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanStatus>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanStatus | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/AdminLoanStatusService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AdminLoanSummaryStatusServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminLoanSummaryStatus | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanSummaryStatusService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanSummaryStatusService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateAdminLoanSummaryStatus[]> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanSummaryStatusService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanSummaryStatus[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanSummaryStatus[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanSummaryStatus[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAdminLoanSummaryStatus.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanSummaryStatus[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateAdminLoanSummaryStatus> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanSummaryStatusService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminLoanSummaryStatus>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminLoanSummaryStatus>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateAdminLoanSummaryStatus> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAdminLoanSummaryStatus.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminLoanSummaryStatus>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminLoanSummaryStatus | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminLoanSummaryStatusService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class AdminNotificationsServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  markAsRead(id: string | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminNotifications/MarkAsRead?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMarkAsRead(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMarkAsRead(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processMarkAsRead(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param message (optional)
   * @return Success
   */
  publishNotification(message: string | undefined): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/services/app/AdminNotifications/PublishNotification?";
    if (message === null)
      throw new Error("The parameter 'message' cannot be null.");
    else if (message !== undefined)
      url_ += "message=" + encodeURIComponent("" + message) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPublishNotification(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPublishNotification(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processPublishNotification(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getNotifications(): Observable<UserNotification[]> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminNotifications/GetNotifications";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNotifications(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNotifications(<any>response_);
            } catch (e) {
              return <Observable<UserNotification[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UserNotification[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetNotifications(
    response: HttpResponseBase
  ): Observable<UserNotification[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UserNotification.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserNotification[]>(<any>null);
  }
}

@Injectable()
export class AdminUserEnabledDeviceServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddAdminUserEnabledDevice | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminUserEnabledDeviceService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminUserEnabledDeviceService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateAdminUserEnabledDevice[]> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminUserEnabledDeviceService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminUserEnabledDevice[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminUserEnabledDevice[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateAdminUserEnabledDevice[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAdminUserEnabledDevice.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminUserEnabledDevice[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateAdminUserEnabledDevice> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminUserEnabledDeviceService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAdminUserEnabledDevice>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAdminUserEnabledDevice>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateAdminUserEnabledDevice> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAdminUserEnabledDevice.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAdminUserEnabledDevice>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateAdminUserEnabledDevice | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/AdminUserEnabledDeviceService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class BorrowerEmploymentInformationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BorrowerEmploymentInformationDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<BorrowerEmploymentInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerEmploymentInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BorrowerEmploymentInformationDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <
                Observable<BorrowerEmploymentInformationDtoPagedResultDto>
              >(<any>_observableThrow(e));
            }
          } else
            return <Observable<BorrowerEmploymentInformationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDtoPagedResultDto>(
      <any>null
    );
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<Borroweremploymentinformation[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/BorrowerEmploymentInformation/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<Borroweremploymentinformation[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<Borroweremploymentinformation[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<Borroweremploymentinformation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(Borroweremploymentinformation.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Borroweremploymentinformation[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: BorrowerEmploymentInformationDto | undefined
  ): Observable<BorrowerEmploymentInformationDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerEmploymentInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerEmploymentInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: BorrowerEmploymentInformationDto | undefined
  ): Observable<BorrowerEmploymentInformationDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerEmploymentInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerEmploymentInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<BorrowerEmploymentInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerEmploymentInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerEmploymentInformationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerEmploymentInformation/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class BorrowerMonthlyIncomeServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BorrowerMonthlyIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BorrowerMonthlyIncomeDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<Borrowermonthlyincome[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/BorrowerMonthlyIncomeServices/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<Borrowermonthlyincome[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<Borrowermonthlyincome[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<Borrowermonthlyincome[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(Borrowermonthlyincome.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Borrowermonthlyincome[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: BorrowerMonthlyIncomeDto | undefined
  ): Observable<BorrowerMonthlyIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: BorrowerMonthlyIncomeDto | undefined
  ): Observable<BorrowerMonthlyIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<BorrowerMonthlyIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BorrowerMonthlyIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<BorrowerMonthlyIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BorrowerMonthlyIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BorrowerMonthlyIncomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/BorrowerMonthlyIncomeServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CitizenshipTypeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addCitizenshipType(
    body: AddCitizenshipTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/CitizenshipTypeService/AddCitizenshipType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddCitizenshipType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddCitizenshipType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddCitizenshipType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateCitizenshipType(
    body: UpdateCitizenshipTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/CitizenshipTypeService/UpdateCitizenshipType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCitizenshipType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCitizenshipType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateCitizenshipType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteCitizenshipType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/CitizenshipTypeService/DeleteCitizenshipType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteCitizenshipType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteCitizenshipType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteCitizenshipType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getCitizenshipTypes(): Observable<UpdateCitizenshipTypeRequest[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/CitizenshipTypeService/GetCitizenshipTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCitizenshipTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCitizenshipTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateCitizenshipTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateCitizenshipTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCitizenshipTypes(
    response: HttpResponseBase
  ): Observable<UpdateCitizenshipTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateCitizenshipTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCitizenshipTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCitizenshipTypeById(
    id: number | undefined
  ): Observable<UpdateCitizenshipTypeRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/CitizenshipTypeService/GetCitizenshipTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCitizenshipTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCitizenshipTypeById(<any>response_);
            } catch (e) {
              return <Observable<UpdateCitizenshipTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateCitizenshipTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCitizenshipTypeById(
    response: HttpResponseBase
  ): Observable<UpdateCitizenshipTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateCitizenshipTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCitizenshipTypeRequest>(<any>null);
  }
}

@Injectable()
export class CityServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addCity(body: AddCityRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/CityService/AddCity";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddCity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddCity(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddCity(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateCity(body: UpdateCityRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/CityService/UpdateCity";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCity(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateCity(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteCity(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/CityService/DeleteCity?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteCity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteCity(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteCity(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getCities(): Observable<UpdateCityRequest[]> {
    let url_ = this.baseUrl + "/api/services/app/CityService/GetCities";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCities(<any>response_);
            } catch (e) {
              return <Observable<UpdateCityRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateCityRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCities(
    response: HttpResponseBase
  ): Observable<UpdateCityRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateCityRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCityRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCityById(id: number | undefined): Observable<UpdateCityRequest> {
    let url_ = this.baseUrl + "/api/services/app/CityService/GetCityById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCityById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCityById(<any>response_);
            } catch (e) {
              return <Observable<UpdateCityRequest>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UpdateCityRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCityById(
    response: HttpResponseBase
  ): Observable<UpdateCityRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateCityRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCityRequest>(<any>null);
  }
}

@Injectable()
export class ConfigurationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeUiTheme(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeUiTheme(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CountryServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addCountry(body: AddCountryRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/CountryService/AddCountry";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddCountry(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddCountry(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateCountry(body: UpdateCountryRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/CountryService/UpdateCountry";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCountry(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateCountry(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteCountry(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/CountryService/DeleteCountry?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteCountry(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteCountry(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getCountries(): Observable<UpdateCountryRequest[]> {
    let url_ = this.baseUrl + "/api/services/app/CountryService/GetCountries";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountries(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountries(<any>response_);
            } catch (e) {
              return <Observable<UpdateCountryRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateCountryRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCountries(
    response: HttpResponseBase
  ): Observable<UpdateCountryRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateCountryRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCountryRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCountryById(id: number | undefined): Observable<UpdateCountryRequest> {
    let url_ =
      this.baseUrl + "/api/services/app/CountryService/GetCountryById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountryById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountryById(<any>response_);
            } catch (e) {
              return <Observable<UpdateCountryRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateCountryRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCountryById(
    response: HttpResponseBase
  ): Observable<UpdateCountryRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateCountryRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCountryRequest>(<any>null);
  }
}

@Injectable()
export class CreditAuthAgreementServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<CreditAuthAgreementDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<CreditAuthAgreementDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: CreditAuthAgreementDto | undefined
  ): Observable<CreditAuthAgreementDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: CreditAuthAgreementDto | undefined
  ): Observable<CreditAuthAgreementDto> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<CreditAuthAgreementDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CreditAuthAgreementDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<CreditAuthAgreementDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CreditAuthAgreementDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CreditAuthAgreementDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditAuthAgreementService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class CreditTypeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addCreditType(body: AddCreditTypeRequest | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditTypeService/AddCreditType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddCreditType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddCreditType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddCreditType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateCreditType(
    body: UpdateCreditTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditTypeService/UpdateCreditType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCreditType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCreditType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateCreditType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteCreditType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditTypeService/DeleteCreditType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteCreditType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteCreditType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteCreditType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getCreditTypes(): Observable<UpdateCreditTypeRequest[]> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditTypeService/GetCreditTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCreditTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCreditTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateCreditTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateCreditTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCreditTypes(
    response: HttpResponseBase
  ): Observable<UpdateCreditTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateCreditTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCreditTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getCreditTypeById(
    id: number | undefined
  ): Observable<UpdateCreditTypeRequest> {
    let url_ =
      this.baseUrl + "/api/services/app/CreditTypeService/GetCreditTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCreditTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCreditTypeById(<any>response_);
            } catch (e) {
              return <Observable<UpdateCreditTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateCreditTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCreditTypeById(
    response: HttpResponseBase
  ): Observable<UpdateCreditTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateCreditTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateCreditTypeRequest>(<any>null);
  }
}

@Injectable()
export class DeclarationServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<DeclarationDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DeclarationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<DeclarationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<DeclarationDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<DeclarationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<DeclarationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDtoPagedResultDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllDeclrationByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<Declaration[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetAllDeclrationByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDeclrationByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDeclrationByLoanApplicationId(
                <any>response_
              );
            } catch (e) {
              return <Observable<Declaration[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Declaration[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllDeclrationByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<Declaration[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(Declaration.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Declaration[]>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllDemographicInformationByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<Declarationborroweredemographicsinformation[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetAllDemographicInformationByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllDemographicInformationByLoanApplicationId(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllDemographicInformationByLoanApplicationId(
                <any>response_
              );
            } catch (e) {
              return <
                Observable<Declarationborroweredemographicsinformation[]>
              >(<any>_observableThrow(e));
            }
          } else
            return <Observable<Declarationborroweredemographicsinformation[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllDemographicInformationByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<Declarationborroweredemographicsinformation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                Declarationborroweredemographicsinformation.fromJS(item)
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Declarationborroweredemographicsinformation[]>(
      <any>null
    );
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: DeclarationDto | undefined): Observable<DeclarationDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DeclarationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<DeclarationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: DeclarationDto | undefined): Observable<DeclarationDto> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<DeclarationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<DeclarationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<DeclarationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DeclarationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DeclarationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/DeclarationService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addDeclarationCategory(
    body: AddDeclarationCategoryRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/AddDeclarationCategory";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddDeclarationCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddDeclarationCategory(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddDeclarationCategory(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateDeclarationCategory(
    body: UpdateDeclarationCategoryRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/UpdateDeclarationCategory";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateDeclarationCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateDeclarationCategory(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateDeclarationCategory(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteDeclarationCategory(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/DeleteDeclarationCategory?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteDeclarationCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteDeclarationCategory(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteDeclarationCategory(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getDeclarationCategories(): Observable<UpdateDeclarationCategoryRequest[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetDeclarationCategories";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDeclarationCategories(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDeclarationCategories(<any>response_);
            } catch (e) {
              return <Observable<UpdateDeclarationCategoryRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDeclarationCategoryRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDeclarationCategories(
    response: HttpResponseBase
  ): Observable<UpdateDeclarationCategoryRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateDeclarationCategoryRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDeclarationCategoryRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDeclarationCategoryById(
    id: number | undefined
  ): Observable<UpdateDeclarationCategoryRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetDeclarationCategoryById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDeclarationCategoryById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDeclarationCategoryById(<any>response_);
            } catch (e) {
              return <Observable<UpdateDeclarationCategoryRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDeclarationCategoryRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDeclarationCategoryById(
    response: HttpResponseBase
  ): Observable<UpdateDeclarationCategoryRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateDeclarationCategoryRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDeclarationCategoryRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addDeclarationQuestion(
    body: AddDeclarationQuestionRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/AddDeclarationQuestion";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddDeclarationQuestion(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddDeclarationQuestion(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddDeclarationQuestion(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateDeclarationQuestion(
    body: UpdateDeclarationQuestionRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/UpdateDeclarationQuestion";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateDeclarationQuestion(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateDeclarationQuestion(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateDeclarationQuestion(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteDeclarationQuestion(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/DeleteDeclarationQuestion?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteDeclarationQuestion(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteDeclarationQuestion(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteDeclarationQuestion(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getDeclarationQuestions(): Observable<UpdateDeclarationQuestionRequest[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetDeclarationQuestions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDeclarationQuestions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDeclarationQuestions(<any>response_);
            } catch (e) {
              return <Observable<UpdateDeclarationQuestionRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDeclarationQuestionRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDeclarationQuestions(
    response: HttpResponseBase
  ): Observable<UpdateDeclarationQuestionRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateDeclarationQuestionRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDeclarationQuestionRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDeclarationQuestionById(
    id: number | undefined
  ): Observable<UpdateDeclarationQuestionRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DeclarationService/GetDeclarationQuestionById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDeclarationQuestionById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDeclarationQuestionById(<any>response_);
            } catch (e) {
              return <Observable<UpdateDeclarationQuestionRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDeclarationQuestionRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDeclarationQuestionById(
    response: HttpResponseBase
  ): Observable<UpdateDeclarationQuestionRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateDeclarationQuestionRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDeclarationQuestionRequest>(<any>null);
  }
}

@Injectable()
export class DemographicInformationServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addDemographicInfoSource(
    body: AddDemographicInfoSourceRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/AddDemographicInfoSource";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddDemographicInfoSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddDemographicInfoSource(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddDemographicInfoSource(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateDemographicInfoSource(
    body: UpdateDemographicInfoSourceRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/UpdateDemographicInfoSource";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateDemographicInfoSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateDemographicInfoSource(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateDemographicInfoSource(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteDemographicInfoSource(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/DeleteDemographicInfoSource?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteDemographicInfoSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteDemographicInfoSource(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteDemographicInfoSource(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getDemographicInfoSources(): Observable<
    UpdateDemographicInfoSourceRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/GetDemographicInfoSources";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDemographicInfoSources(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDemographicInfoSources(<any>response_);
            } catch (e) {
              return <Observable<UpdateDemographicInfoSourceRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDemographicInfoSourceRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDemographicInfoSources(
    response: HttpResponseBase
  ): Observable<UpdateDemographicInfoSourceRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateDemographicInfoSourceRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDemographicInfoSourceRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDemographicInfoSourceById(
    id: number | undefined
  ): Observable<UpdateDemographicInfoSourceRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/GetDemographicInfoSourceById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDemographicInfoSourceById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDemographicInfoSourceById(<any>response_);
            } catch (e) {
              return <Observable<UpdateDemographicInfoSourceRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDemographicInfoSourceRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDemographicInfoSourceById(
    response: HttpResponseBase
  ): Observable<UpdateDemographicInfoSourceRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateDemographicInfoSourceRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDemographicInfoSourceRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addDemographicInformation(
    body: AddDemographicInformationRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/AddDemographicInformation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddDemographicInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddDemographicInformation(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddDemographicInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateDemographicInformation(
    body: UpdateDemographicInformationRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/UpdateDemographicInformation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateDemographicInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateDemographicInformation(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateDemographicInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteDemographicInformation(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/DeleteDemographicInformation?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteDemographicInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteDemographicInformation(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteDemographicInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getDemographicInformations(): Observable<
    UpdateDemographicInformationRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/GetDemographicInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDemographicInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDemographicInformations(<any>response_);
            } catch (e) {
              return <Observable<UpdateDemographicInformationRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDemographicInformationRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDemographicInformations(
    response: HttpResponseBase
  ): Observable<UpdateDemographicInformationRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateDemographicInformationRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDemographicInformationRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getDemographicInformationById(
    id: number | undefined
  ): Observable<UpdateDemographicInformationRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/DemographicInformationService/GetDemographicInformationById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDemographicInformationById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDemographicInformationById(<any>response_);
            } catch (e) {
              return <Observable<UpdateDemographicInformationRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateDemographicInformationRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetDemographicInformationById(
    response: HttpResponseBase
  ): Observable<UpdateDemographicInformationRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateDemographicInformationRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateDemographicInformationRequest>(<any>null);
  }
}

@Injectable()
export class EConsentServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EConsentDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EConsentDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EConsentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<EConsentDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EConsentDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EConsentDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EConsentDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<EConsentDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: EConsentDto | undefined): Observable<EConsentDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<EConsentDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EConsentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<EConsentDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: EConsentDto | undefined): Observable<EConsentDto> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EConsentDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EConsentDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<EConsentDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EConsentDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EConsentDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/EConsentService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class EmploymentIncomeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<EmploymentIncomeDto> {
    let url_ = this.baseUrl + "/api/services/app/EmploymentIncomeService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EmploymentIncomeDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: EmploymentIncomeDto | undefined
  ): Observable<EmploymentIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: EmploymentIncomeDto | undefined
  ): Observable<EmploymentIncomeDto> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EmploymentIncomeDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmploymentIncomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<EmploymentIncomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmploymentIncomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmploymentIncomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/EmploymentIncomeService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ExpenseServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<ExpensesDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ExpensesDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ExpensesDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExpensesDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<ExpensesDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: ExpensesDto | undefined): Observable<ExpensesDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<ExpensesDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: ExpensesDto | undefined): Observable<ExpensesDto> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<ExpensesDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<ExpensesDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/ExpenseServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class FinancialServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addFinancialPropertyStatus(
    body: AddPropertyStatusRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/AddFinancialPropertyStatus";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddFinancialPropertyStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddFinancialPropertyStatus(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddFinancialPropertyStatus(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateFinancialPropertyStatus(
    body: UpdatePropertyStatusRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/UpdateFinancialPropertyStatus";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateFinancialPropertyStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateFinancialPropertyStatus(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateFinancialPropertyStatus(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteFinancialPropertyStatus(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/DeleteFinancialPropertyStatus?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteFinancialPropertyStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteFinancialPropertyStatus(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteFinancialPropertyStatus(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getFinancialPropertyStatuses(): Observable<UpdatePropertyStatusRequest[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialPropertyStatuses";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialPropertyStatuses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialPropertyStatuses(<any>response_);
            } catch (e) {
              return <Observable<UpdatePropertyStatusRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdatePropertyStatusRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialPropertyStatuses(
    response: HttpResponseBase
  ): Observable<UpdatePropertyStatusRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdatePropertyStatusRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdatePropertyStatusRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFinancialPropertyStatusById(
    id: number | undefined
  ): Observable<UpdatePropertyStatusRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialPropertyStatusById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialPropertyStatusById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialPropertyStatusById(<any>response_);
            } catch (e) {
              return <Observable<UpdatePropertyStatusRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdatePropertyStatusRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialPropertyStatusById(
    response: HttpResponseBase
  ): Observable<UpdatePropertyStatusRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdatePropertyStatusRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdatePropertyStatusRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addFinancialPropertyIntendedOccupancy(
    body: AddPropertyIntendedOccupancyRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/AddFinancialPropertyIntendedOccupancy";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddFinancialPropertyIntendedOccupancy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddFinancialPropertyIntendedOccupancy(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddFinancialPropertyIntendedOccupancy(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateFinancialPropertyIntendedOccupancy(
    body: UpdatePropertyIntendedOccupancyRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/UpdateFinancialPropertyIntendedOccupancy";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateFinancialPropertyIntendedOccupancy(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateFinancialPropertyIntendedOccupancy(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateFinancialPropertyIntendedOccupancy(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteFinancialPropertyIntendedOccupancy(
    id: number | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/DeleteFinancialPropertyIntendedOccupancy?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteFinancialPropertyIntendedOccupancy(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteFinancialPropertyIntendedOccupancy(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteFinancialPropertyIntendedOccupancy(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getFinancialPropertyIntendedOccupancies(): Observable<
    UpdatePropertyIntendedOccupancyRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialPropertyIntendedOccupancies";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialPropertyIntendedOccupancies(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialPropertyIntendedOccupancies(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdatePropertyIntendedOccupancyRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdatePropertyIntendedOccupancyRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialPropertyIntendedOccupancies(
    response: HttpResponseBase
  ): Observable<UpdatePropertyIntendedOccupancyRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                UpdatePropertyIntendedOccupancyRequest.fromJS(item)
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdatePropertyIntendedOccupancyRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFinancialPropertyIntendedOccupancyById(
    id: number | undefined
  ): Observable<UpdatePropertyIntendedOccupancyRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialPropertyIntendedOccupancyById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialPropertyIntendedOccupancyById(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialPropertyIntendedOccupancyById(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdatePropertyIntendedOccupancyRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdatePropertyIntendedOccupancyRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialPropertyIntendedOccupancyById(
    response: HttpResponseBase
  ): Observable<UpdatePropertyIntendedOccupancyRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdatePropertyIntendedOccupancyRequest.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdatePropertyIntendedOccupancyRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addFinancialOtherLaibilitiesType(
    body: AddOtherLaibilitiesTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/AddFinancialOtherLaibilitiesType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddFinancialOtherLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddFinancialOtherLaibilitiesType(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddFinancialOtherLaibilitiesType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateFinancialOtherLaibilitiesType(
    body: UpdateOtherLaibilitiesTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/UpdateFinancialOtherLaibilitiesType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateFinancialOtherLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateFinancialOtherLaibilitiesType(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateFinancialOtherLaibilitiesType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteFinancialOtherLaibilitiesType(
    id: number | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/DeleteFinancialOtherLaibilitiesType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteFinancialOtherLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteFinancialOtherLaibilitiesType(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteFinancialOtherLaibilitiesType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getFinancialOtherLaibilitiesTypes(): Observable<
    UpdateOtherLaibilitiesTypeRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialOtherLaibilitiesTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialOtherLaibilitiesTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialOtherLaibilitiesTypes(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdateOtherLaibilitiesTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateOtherLaibilitiesTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialOtherLaibilitiesTypes(
    response: HttpResponseBase
  ): Observable<UpdateOtherLaibilitiesTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateOtherLaibilitiesTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateOtherLaibilitiesTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFinancialOtherLaibilitiesTypeById(
    id: number | undefined
  ): Observable<UpdateOtherLaibilitiesTypeRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialOtherLaibilitiesTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialOtherLaibilitiesTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialOtherLaibilitiesTypeById(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdateOtherLaibilitiesTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateOtherLaibilitiesTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialOtherLaibilitiesTypeById(
    response: HttpResponseBase
  ): Observable<UpdateOtherLaibilitiesTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateOtherLaibilitiesTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateOtherLaibilitiesTypeRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addFinancialLaibilitiesType(
    body: AddLaibilitiesTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/AddFinancialLaibilitiesType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddFinancialLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddFinancialLaibilitiesType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddFinancialLaibilitiesType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateFinancialLaibilitiesType(
    body: UpdateLaibilitiesTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/UpdateFinancialLaibilitiesType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateFinancialLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateFinancialLaibilitiesType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateFinancialLaibilitiesType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteFinancialLaibilitiesType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/DeleteFinancialLaibilitiesType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteFinancialLaibilitiesType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteFinancialLaibilitiesType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteFinancialLaibilitiesType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getFinancialLaibilitiesTypes(): Observable<UpdateLaibilitiesTypeRequest[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialLaibilitiesTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialLaibilitiesTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialLaibilitiesTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateLaibilitiesTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLaibilitiesTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialLaibilitiesTypes(
    response: HttpResponseBase
  ): Observable<UpdateLaibilitiesTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLaibilitiesTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLaibilitiesTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFinancialLaibilitiesTypeById(
    id: number | undefined
  ): Observable<UpdateLaibilitiesTypeRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialLaibilitiesTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialLaibilitiesTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialLaibilitiesTypeById(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdateLaibilitiesTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLaibilitiesTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialLaibilitiesTypeById(
    response: HttpResponseBase
  ): Observable<UpdateLaibilitiesTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLaibilitiesTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLaibilitiesTypeRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addFinancialAccountType(
    body: AddAccountTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/AddFinancialAccountType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddFinancialAccountType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddFinancialAccountType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddFinancialAccountType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateFinancialAccountType(
    body: UpdateAccountTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/UpdateFinancialAccountType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateFinancialAccountType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateFinancialAccountType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateFinancialAccountType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteFinancialAccountType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/DeleteFinancialAccountType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteFinancialAccountType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteFinancialAccountType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteFinancialAccountType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getFinancialAccountTypes(): Observable<UpdateAccountTypeRequest[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialAccountTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialAccountTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialAccountTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateAccountTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAccountTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialAccountTypes(
    response: HttpResponseBase
  ): Observable<UpdateAccountTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateAccountTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAccountTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getFinancialAccountTypeById(
    id: number | undefined
  ): Observable<UpdateAccountTypeRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/FinancialService/GetFinancialAccountTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialAccountTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialAccountTypeById(<any>response_);
            } catch (e) {
              return <Observable<UpdateAccountTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateAccountTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetFinancialAccountTypeById(
    response: HttpResponseBase
  ): Observable<UpdateAccountTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateAccountTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateAccountTypeRequest>(<any>null);
  }
}

@Injectable()
export class HomeBuyingServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: BuyingHomeDto | undefined): Observable<BuyingHomeDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<BuyingHomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<BuyingHomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<BuyingHomeDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<BuyingHomeDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<BuyingHomeDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<BuyingHomeDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<BuyingHomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<BuyingHomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: BuyingHomeDto | undefined): Observable<BuyingHomeDto> {
    let url_ = this.baseUrl + "/api/services/app/HomeBuyingService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<BuyingHomeDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<BuyingHomeDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<BuyingHomeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyingHomeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<BuyingHomeDto>(<any>null);
  }
}

@Injectable()
export class HousingTypeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addHousingType(body: AddHousingTypeRequest | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/HousingTypeService/AddHousingType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddHousingType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddHousingType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddHousingType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateHousingType(
    body: UpdateHousingTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/HousingTypeService/UpdateHousingType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateHousingType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateHousingType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateHousingType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteHousingType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/HousingTypeService/DeleteHousingType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteHousingType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteHousingType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteHousingType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getHousingTypes(): Observable<UpdateHousingTypeRequest[]> {
    let url_ =
      this.baseUrl + "/api/services/app/HousingTypeService/GetHousingTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetHousingTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetHousingTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateHousingTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateHousingTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetHousingTypes(
    response: HttpResponseBase
  ): Observable<UpdateHousingTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateHousingTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateHousingTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getHousingTypeById(
    id: number | undefined
  ): Observable<UpdateHousingTypeRequest> {
    let url_ =
      this.baseUrl + "/api/services/app/HousingTypeService/GetHousingTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetHousingTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetHousingTypeById(<any>response_);
            } catch (e) {
              return <Observable<UpdateHousingTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateHousingTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetHousingTypeById(
    response: HttpResponseBase
  ): Observable<UpdateHousingTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateHousingTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateHousingTypeRequest>(<any>null);
  }
}

@Injectable()
export class IncomeSourceServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addIncomeSource(
    body: AddIncomeSourceRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeSourceService/AddIncomeSource";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddIncomeSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddIncomeSource(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddIncomeSource(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateIncomeSource(
    body: UpdateIncomeSourceRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeSourceService/UpdateIncomeSource";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateIncomeSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateIncomeSource(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateIncomeSource(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteIncomeSource(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/IncomeSourceService/DeleteIncomeSource?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteIncomeSource(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteIncomeSource(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteIncomeSource(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getIncomeSources(): Observable<UpdateIncomeSourceRequest[]> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeSourceService/GetIncomeSources";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetIncomeSources(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetIncomeSources(<any>response_);
            } catch (e) {
              return <Observable<UpdateIncomeSourceRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateIncomeSourceRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetIncomeSources(
    response: HttpResponseBase
  ): Observable<UpdateIncomeSourceRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateIncomeSourceRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateIncomeSourceRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getIncomeSourceById(
    id: number | undefined
  ): Observable<UpdateIncomeSourceRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/IncomeSourceService/GetIncomeSourceById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetIncomeSourceById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetIncomeSourceById(<any>response_);
            } catch (e) {
              return <Observable<UpdateIncomeSourceRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateIncomeSourceRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetIncomeSourceById(
    response: HttpResponseBase
  ): Observable<UpdateIncomeSourceRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateIncomeSourceRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateIncomeSourceRequest>(<any>null);
  }
}

@Injectable()
export class IncomeTypeServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addIncomeType(body: AddIncomeTypeRequest | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeTypeService/AddIncomeType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddIncomeType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddIncomeType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddIncomeType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateIncomeType(
    body: UpdateIncomeTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeTypeService/UpdateIncomeType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateIncomeType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateIncomeType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateIncomeType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteIncomeType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeTypeService/DeleteIncomeType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteIncomeType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteIncomeType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteIncomeType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getIncomeTypes(): Observable<UpdateIncomeTypeRequest[]> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeTypeService/GetIncomeTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetIncomeTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetIncomeTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateIncomeTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateIncomeTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetIncomeTypes(
    response: HttpResponseBase
  ): Observable<UpdateIncomeTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateIncomeTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateIncomeTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getIncomeTypeById(
    id: number | undefined
  ): Observable<UpdateIncomeTypeRequest> {
    let url_ =
      this.baseUrl + "/api/services/app/IncomeTypeService/GetIncomeTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetIncomeTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetIncomeTypeById(<any>response_);
            } catch (e) {
              return <Observable<UpdateIncomeTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateIncomeTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetIncomeTypeById(
    response: HttpResponseBase
  ): Observable<UpdateIncomeTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateIncomeTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateIncomeTypeRequest>(<any>null);
  }
}

@Injectable()
export class LeadApplicationQuestionsServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadApplicationQuestions | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationQuestionsService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LeadApplicationQuestionsService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadApplicationQuestions[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationQuestionsService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadApplicationQuestions[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadApplicationQuestions[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadApplicationQuestions[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadApplicationQuestions.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadApplicationQuestions[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadApplicationQuestions> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LeadApplicationQuestionsService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadApplicationQuestions>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadApplicationQuestions>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadApplicationQuestions> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadApplicationQuestions.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadApplicationQuestions>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadApplicationQuestions | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationQuestionsService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadApplicationTypesServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadApplicationType | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationTypesService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationTypesService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadApplicationType[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationTypesService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadApplicationType[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadApplicationType[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadApplicationType[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadApplicationType.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadApplicationType[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadApplicationType> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationTypesService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadApplicationType>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadApplicationType>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadApplicationType> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadApplicationType.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadApplicationType>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadApplicationType | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadApplicationTypesService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadAssetDetailsServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadAssetDetails | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadAssetDetailsService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadAssetDetailsService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadAssetDetails[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadAssetDetailsService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadAssetDetails[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadAssetDetails[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadAssetDetails[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadAssetDetails.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadAssetDetails[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadAssetDetails> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadAssetDetailsService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadAssetDetails>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadAssetDetails>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadAssetDetails> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadAssetDetails.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadAssetDetails>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadAssetDetails | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadAssetDetailsService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadAssetTypesServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadAssetTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadAssetTypesService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadAssetTypesService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadAssetTypes[]> {
    let url_ = this.baseUrl + "/api/services/app/LeadAssetTypesService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadAssetTypes[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadAssetTypes[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadAssetTypes[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadAssetTypes.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadAssetTypes[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadAssetTypes> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadAssetTypesService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadAssetTypes>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadAssetTypes>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadAssetTypes> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadAssetTypes.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadAssetTypes>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadAssetTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadAssetTypesService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadEmploymentDetailsServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadEmploymentDetails | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentDetailsService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentDetailsService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadEmploymentDetails[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentDetailsService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadEmploymentDetails[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadEmploymentDetails[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadEmploymentDetails[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadEmploymentDetails.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadEmploymentDetails[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadEmploymentDetails> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentDetailsService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadEmploymentDetails>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadEmploymentDetails>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadEmploymentDetails> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadEmploymentDetails.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadEmploymentDetails>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadEmploymentDetails | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentDetailsService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadEmploymentTypesServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadEmploymentTypes | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentTypesService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentTypesService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadEmploymentTypes[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentTypesService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadEmploymentTypes[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadEmploymentTypes[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadEmploymentTypes[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadEmploymentTypes.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadEmploymentTypes[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadEmploymentTypes> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentTypesService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadEmploymentTypes>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadEmploymentTypes>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadEmploymentTypes> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadEmploymentTypes.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadEmploymentTypes>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadEmploymentTypes | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadEmploymentTypesService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadIncomeTypesServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadIncomeTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadIncomeTypesService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadIncomeTypesService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadIncomeTypes[]> {
    let url_ = this.baseUrl + "/api/services/app/LeadIncomeTypesService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadIncomeTypes[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadIncomeTypes[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadIncomeTypes[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadIncomeTypes.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadIncomeTypes[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadIncomeTypes> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadIncomeTypesService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadIncomeTypes>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadIncomeTypes>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadIncomeTypes> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadIncomeTypes.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadIncomeTypes>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadIncomeTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadIncomeTypesService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadOwnerTypesServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadOwnerTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadOwnerTypesService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadOwnerTypesService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadOwnerTypes[]> {
    let url_ = this.baseUrl + "/api/services/app/LeadOwnerTypesService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadOwnerTypes[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadOwnerTypes[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadOwnerTypes[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadOwnerTypes.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadOwnerTypes[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadOwnerTypes> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadOwnerTypesService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadOwnerTypes>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadOwnerTypes>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadOwnerTypes> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadOwnerTypes.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadOwnerTypes>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadOwnerTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadOwnerTypesService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadPurchasingDetailServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadPurchasingDetail | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadPurchasingDetailService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadPurchasingDetailService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadPurchasingDetail[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadPurchasingDetailService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadPurchasingDetail[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadPurchasingDetail[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadPurchasingDetail[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadPurchasingDetail.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadPurchasingDetail[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadPurchasingDetail> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadPurchasingDetailService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadPurchasingDetail>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadPurchasingDetail>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadPurchasingDetail> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadPurchasingDetail.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadPurchasingDetail>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadPurchasingDetail | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadPurchasingDetailService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadQuestionAnswersServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadQuestionAnswers | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadQuestionAnswersService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadQuestionAnswersService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadQuestionAnswers[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadQuestionAnswersService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadQuestionAnswers[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadQuestionAnswers[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadQuestionAnswers[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadQuestionAnswers.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadQuestionAnswers[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadQuestionAnswers> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadQuestionAnswersService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadQuestionAnswers>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadQuestionAnswers>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadQuestionAnswers> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadQuestionAnswers.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadQuestionAnswers>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadQuestionAnswers | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadQuestionAnswersService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadRefinancingDetailsServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadRefinancingDetails | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadRefinancingDetailsService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadRefinancingDetailsService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadRefinancingDetails[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadRefinancingDetailsService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadRefinancingDetails[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadRefinancingDetails[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadRefinancingDetails[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadRefinancingDetails.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadRefinancingDetails[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadRefinancingDetails> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadRefinancingDetailsService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadRefinancingDetails>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadRefinancingDetails>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadRefinancingDetails> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadRefinancingDetails.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadRefinancingDetails>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadRefinancingDetails | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LeadRefinancingDetailsService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}

@Injectable()
export class LeadRefinancingIncomeDetailsServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadRefinancingIncomeDetails | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LeadRefinancingIncomeDetailsService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: UpdateLeadRefinancingIncomeDetails | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LeadRefinancingIncomeDetailsService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LeadRefinancingIncomeDetailsService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadRefinancingIncomeDetails[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LeadRefinancingIncomeDetailsService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadRefinancingIncomeDetails[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadRefinancingIncomeDetails[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadRefinancingIncomeDetails[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadRefinancingIncomeDetails.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadRefinancingIncomeDetails[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(
    id: number | undefined
  ): Observable<UpdateLeadRefinancingIncomeDetails> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LeadRefinancingIncomeDetailsService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadRefinancingIncomeDetails>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadRefinancingIncomeDetails>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadRefinancingIncomeDetails> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadRefinancingIncomeDetails.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadRefinancingIncomeDetails>(<any>null);
  }
}

@Injectable()
export class LeadTaxTypesServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  add(body: AddLeadTaxTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadTaxTypesService/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAdd(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UpdateLeadTaxTypes | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadTaxTypesService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/LeadTaxTypesService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAll(): Observable<UpdateLeadTaxTypes[]> {
    let url_ = this.baseUrl + "/api/services/app/LeadTaxTypesService/GetAll";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadTaxTypes[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLeadTaxTypes[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UpdateLeadTaxTypes[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLeadTaxTypes.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadTaxTypes[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getById(id: number | undefined): Observable<UpdateLeadTaxTypes> {
    let url_ = this.baseUrl + "/api/services/app/LeadTaxTypesService/GetById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLeadTaxTypes>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UpdateLeadTaxTypes>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<UpdateLeadTaxTypes> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLeadTaxTypes.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLeadTaxTypes>(<any>null);
  }
}

@Injectable()
export class LoanServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<LoanApplicationDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanApplicationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<LoanApplicationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<LoanApplicationDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LoanApplicationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<LoanApplicationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDtoPagedResultDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAllCustom(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<LoanListDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/GetAllCustom?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCustom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCustom(<any>response_);
            } catch (e) {
              return <Observable<LoanListDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LoanListDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllCustom(
    response: HttpResponseBase
  ): Observable<LoanListDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanListDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanListDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: LoanApplicationDto | undefined): Observable<LoanApplicationDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanApplicationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<LoanApplicationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: LoanApplicationDto | undefined): Observable<LoanApplicationDto> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<LoanApplicationDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanApplicationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<LoanApplicationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanApplicationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanApplicationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Loan/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LoanDetailServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<LoanDetailDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanDetailDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<LoanDetailDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<LoanDetailDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LoanDetailDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<LoanDetailDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: LoanDetailDto | undefined): Observable<LoanDetailDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanDetailDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<LoanDetailDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: LoanDetailDto | undefined): Observable<LoanDetailDto> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<LoanDetailDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LoanDetailDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<LoanDetailDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoanDetailDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoanDetailDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/LoanDetailServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class LoanServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanPropertyGiftType(
    body: AddLoanPropertyGiftTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/AddLoanPropertyGiftType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanPropertyGiftType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanPropertyGiftType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanPropertyGiftType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLoanPropertyGiftType(
    body: UpdateLoanPropertyGiftTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/UpdateLoanPropertyGiftType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLoanPropertyGiftType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLoanPropertyGiftType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLoanPropertyGiftType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLoanPropertyGiftType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteLoanPropertyGiftType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLoanPropertyGiftType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLoanPropertyGiftType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLoanPropertyGiftType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getLoanPropertyGiftTypes(): Observable<UpdateLoanPropertyGiftTypeRequest[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/GetLoanPropertyGiftTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanPropertyGiftTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanPropertyGiftTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateLoanPropertyGiftTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanPropertyGiftTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanPropertyGiftTypes(
    response: HttpResponseBase
  ): Observable<UpdateLoanPropertyGiftTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLoanPropertyGiftTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanPropertyGiftTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanPropertyGiftTypeById(
    id: number | undefined
  ): Observable<UpdateLoanPropertyGiftTypeRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanPropertyGiftTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanPropertyGiftTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanPropertyGiftTypeById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLoanPropertyGiftTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanPropertyGiftTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanPropertyGiftTypeById(
    response: HttpResponseBase
  ): Observable<UpdateLoanPropertyGiftTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLoanPropertyGiftTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanPropertyGiftTypeRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanPropertyOccupancy(
    body: AddLoanPropertyOccupancyRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/AddLoanPropertyOccupancy";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanPropertyOccupancy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanPropertyOccupancy(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanPropertyOccupancy(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLoanPropertyOccupancy(
    body: UpdateLoanPropertyOccupancyRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/UpdateLoanPropertyOccupancy";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLoanPropertyOccupancy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLoanPropertyOccupancy(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLoanPropertyOccupancy(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLoanPropertyOccupancy(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteLoanPropertyOccupancy?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLoanPropertyOccupancy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLoanPropertyOccupancy(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLoanPropertyOccupancy(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getLoanPropertyOccupancies(): Observable<
    UpdateLoanPropertyOccupancyRequest[]
  > {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/GetLoanPropertyOccupancies";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanPropertyOccupancies(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanPropertyOccupancies(<any>response_);
            } catch (e) {
              return <Observable<UpdateLoanPropertyOccupancyRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanPropertyOccupancyRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanPropertyOccupancies(
    response: HttpResponseBase
  ): Observable<UpdateLoanPropertyOccupancyRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateLoanPropertyOccupancyRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanPropertyOccupancyRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanPropertyOccupancyById(
    id: number | undefined
  ): Observable<UpdateLoanPropertyOccupancyRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanPropertyOccupancyById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanPropertyOccupancyById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanPropertyOccupancyById(<any>response_);
            } catch (e) {
              return <Observable<UpdateLoanPropertyOccupancyRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanPropertyOccupancyRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanPropertyOccupancyById(
    response: HttpResponseBase
  ): Observable<UpdateLoanPropertyOccupancyRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLoanPropertyOccupancyRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanPropertyOccupancyRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addMortageLoanType(
    body: AddMortageLoanTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/AddMortageLoanType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddMortageLoanType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddMortageLoanType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddMortageLoanType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateMortageLoanType(
    body: UpdateMortageLoanTypeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/UpdateMortageLoanType";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateMortageLoanType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateMortageLoanType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateMortageLoanType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteMortageLoanType(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/DeleteMortageLoanType?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteMortageLoanType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteMortageLoanType(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteMortageLoanType(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getMortageLoanTypes(): Observable<UpdateMortageLoanTypeRequest[]> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/GetMortageLoanTypes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMortageLoanTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMortageLoanTypes(<any>response_);
            } catch (e) {
              return <Observable<UpdateMortageLoanTypeRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateMortageLoanTypeRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMortageLoanTypes(
    response: HttpResponseBase
  ): Observable<UpdateMortageLoanTypeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateMortageLoanTypeRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateMortageLoanTypeRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getMortageLoanTypeById(
    id: number | undefined
  ): Observable<UpdateMortageLoanTypeRequest> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/GetMortageLoanTypeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMortageLoanTypeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMortageLoanTypeById(<any>response_);
            } catch (e) {
              return <Observable<UpdateMortageLoanTypeRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateMortageLoanTypeRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMortageLoanTypeById(
    response: HttpResponseBase
  ): Observable<UpdateMortageLoanTypeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateMortageLoanTypeRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateMortageLoanTypeRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanAndPropertyInformationGift(
    body: AddLoanAndPropertyInformationGiftRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/AddLoanAndPropertyInformationGift";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanAndPropertyInformationGift(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanAndPropertyInformationGift(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanAndPropertyInformationGift(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLoanAndPropertyInformationGift(
    body: UpdateLoanAndPropertyInformationGiftRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/UpdateLoanAndPropertyInformationGift";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLoanAndPropertyInformationGift(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLoanAndPropertyInformationGift(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLoanAndPropertyInformationGift(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLoanAndPropertyInformationGift(
    id: number | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteLoanAndPropertyInformationGift?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLoanAndPropertyInformationGift(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLoanAndPropertyInformationGift(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLoanAndPropertyInformationGift(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getLoanAndPropertyInformationGifts(): Observable<
    UpdateLoanAndPropertyInformationGiftRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformationGifts";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformationGifts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformationGifts(
                <any>response_
              );
            } catch (e) {
              return <
                Observable<UpdateLoanAndPropertyInformationGiftRequest[]>
              >(<any>_observableThrow(e));
            }
          } else
            return <Observable<UpdateLoanAndPropertyInformationGiftRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanAndPropertyInformationGifts(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationGiftRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                UpdateLoanAndPropertyInformationGiftRequest.fromJS(item)
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanAndPropertyInformationGiftRequest[]>(
      <any>null
    );
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanAndPropertyInformationGiftById(
    id: number | undefined
  ): Observable<UpdateLoanAndPropertyInformationGiftRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformationGiftById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformationGiftById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformationGiftById(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdateLoanAndPropertyInformationGiftRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanAndPropertyInformationGiftRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanAndPropertyInformationGiftById(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationGiftRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLoanAndPropertyInformationGiftRequest.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanAndPropertyInformationGiftRequest>(
      <any>null
    );
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanAndPropertyInformation(
    body: AddLoanAndPropertyInformationRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/AddLoanAndPropertyInformation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanAndPropertyInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanAndPropertyInformation(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanAndPropertyInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLoanAndPropertyInformation(
    body: UpdateLoanAndPropertyInformationRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/UpdateLoanAndPropertyInformation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLoanAndPropertyInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLoanAndPropertyInformation(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLoanAndPropertyInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLoanAndPropertyInformation(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteLoanAndPropertyInformation?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLoanAndPropertyInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLoanAndPropertyInformation(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLoanAndPropertyInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getLoanAndPropertyInformations(): Observable<
    UpdateLoanAndPropertyInformationRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformations(<any>response_);
            } catch (e) {
              return <Observable<UpdateLoanAndPropertyInformationRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanAndPropertyInformationRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanAndPropertyInformations(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                UpdateLoanAndPropertyInformationRequest.fromJS(item)
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanAndPropertyInformationRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanAndPropertyInformationById(
    id: number | undefined
  ): Observable<UpdateLoanAndPropertyInformationRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformationById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformationById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformationById(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdateLoanAndPropertyInformationRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanAndPropertyInformationRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanAndPropertyInformationById(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLoanAndPropertyInformationRequest.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanAndPropertyInformationRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanOriginatorInformation(
    body: AddLoanOriginatorInformationRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/AddLoanOriginatorInformation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanOriginatorInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanOriginatorInformation(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanOriginatorInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLoanOriginatorInformation(
    body: UpdateLoanOriginatorInformationRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/UpdateLoanOriginatorInformation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLoanOriginatorInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLoanOriginatorInformation(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLoanOriginatorInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLoanOriginatorInformation(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteLoanOriginatorInformation?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLoanOriginatorInformation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLoanOriginatorInformation(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLoanOriginatorInformation(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getLoanOriginatorInformations(): Observable<
    UpdateLoanOriginatorInformationRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanOriginatorInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanOriginatorInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanOriginatorInformations(<any>response_);
            } catch (e) {
              return <Observable<UpdateLoanOriginatorInformationRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanOriginatorInformationRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanOriginatorInformations(
    response: HttpResponseBase
  ): Observable<UpdateLoanOriginatorInformationRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                UpdateLoanOriginatorInformationRequest.fromJS(item)
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanOriginatorInformationRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanOriginatorInformationById(
    id: number | undefined
  ): Observable<UpdateLoanOriginatorInformationRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanOriginatorInformationById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanOriginatorInformationById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanOriginatorInformationById(
                <any>response_
              );
            } catch (e) {
              return <Observable<UpdateLoanOriginatorInformationRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateLoanOriginatorInformationRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanOriginatorInformationById(
    response: HttpResponseBase
  ): Observable<UpdateLoanOriginatorInformationRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLoanOriginatorInformationRequest.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanOriginatorInformationRequest>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanAndPropertyInformationOtherMortageLoan(
    body: AddLoanAndPropertyInformationOtherMortageLoanRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/AddLoanAndPropertyInformationOtherMortageLoan";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanAndPropertyInformationOtherMortageLoan(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanAndPropertyInformationOtherMortageLoan(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanAndPropertyInformationOtherMortageLoan(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLoanAndPropertyInformationOtherMortageLoan(
    body: UpdateLoanAndPropertyInformationOtherMortageLoanRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/UpdateLoanAndPropertyInformationOtherMortageLoan";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLoanAndPropertyInformationOtherMortageLoan(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLoanAndPropertyInformationOtherMortageLoan(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLoanAndPropertyInformationOtherMortageLoan(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLoanAndPropertyInformationOtherMortageLoan(
    id: number | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteLoanAndPropertyInformationOtherMortageLoan?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLoanAndPropertyInformationOtherMortageLoan(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLoanAndPropertyInformationOtherMortageLoan(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLoanAndPropertyInformationOtherMortageLoan(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getLoanAndPropertyInformationOtherMortageLoans(): Observable<
    UpdateLoanAndPropertyInformationOtherMortageLoanRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformationOtherMortageLoans";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformationOtherMortageLoans(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformationOtherMortageLoans(
                <any>response_
              );
            } catch (e) {
              return <
                Observable<
                  UpdateLoanAndPropertyInformationOtherMortageLoanRequest[]
                >
              >(<any>_observableThrow(e));
            }
          } else
            return <
              Observable<
                UpdateLoanAndPropertyInformationOtherMortageLoanRequest[]
              >
            >(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLoanAndPropertyInformationOtherMortageLoans(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationOtherMortageLoanRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                UpdateLoanAndPropertyInformationOtherMortageLoanRequest.fromJS(
                  item
                )
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<
      UpdateLoanAndPropertyInformationOtherMortageLoanRequest[]
    >(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanAndPropertyInformationOtherMortageLoanById(
    id: number | undefined
  ): Observable<UpdateLoanAndPropertyInformationOtherMortageLoanRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformationOtherMortageLoanById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformationOtherMortageLoanById(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformationOtherMortageLoanById(
                <any>response_
              );
            } catch (e) {
              return <
                Observable<
                  UpdateLoanAndPropertyInformationOtherMortageLoanRequest
                >
              >(<any>_observableThrow(e));
            }
          } else
            return <
              Observable<
                UpdateLoanAndPropertyInformationOtherMortageLoanRequest
              >
            >(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLoanAndPropertyInformationOtherMortageLoanById(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationOtherMortageLoanRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLoanAndPropertyInformationOtherMortageLoanRequest.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<
      UpdateLoanAndPropertyInformationOtherMortageLoanRequest
    >(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addLoanAndPropertyInformationRentalIncome(
    body: AddLoanAndPropertyInformationRentalIncomeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/AddLoanAndPropertyInformationRentalIncome";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddLoanAndPropertyInformationRentalIncome(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddLoanAndPropertyInformationRentalIncome(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddLoanAndPropertyInformationRentalIncome(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateLoanAndPropertyInformationRentalIncome(
    body: UpdateLoanAndPropertyInformationRentalIncomeRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/UpdateLoanAndPropertyInformationRentalIncome";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLoanAndPropertyInformationRentalIncome(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLoanAndPropertyInformationRentalIncome(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateLoanAndPropertyInformationRentalIncome(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteLoanAndPropertyInformationRentalIncome(
    id: number | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteLoanAndPropertyInformationRentalIncome?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteLoanAndPropertyInformationRentalIncome(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteLoanAndPropertyInformationRentalIncome(
                <any>response_
              );
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteLoanAndPropertyInformationRentalIncome(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getLoanAndPropertyInformationRentalIncomes(): Observable<
    UpdateLoanAndPropertyInformationRentalIncomeRequest[]
  > {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformationRentalIncomes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformationRentalIncomes(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformationRentalIncomes(
                <any>response_
              );
            } catch (e) {
              return <
                Observable<
                  UpdateLoanAndPropertyInformationRentalIncomeRequest[]
                >
              >(<any>_observableThrow(e));
            }
          } else
            return <
              Observable<UpdateLoanAndPropertyInformationRentalIncomeRequest[]>
            >(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLoanAndPropertyInformationRentalIncomes(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationRentalIncomeRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(
                UpdateLoanAndPropertyInformationRentalIncomeRequest.fromJS(item)
              );
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanAndPropertyInformationRentalIncomeRequest[]>(
      <any>null
    );
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanAndPropertyInformationRentalIncomeById(
    id: number | undefined
  ): Observable<UpdateLoanAndPropertyInformationRentalIncomeRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetLoanAndPropertyInformationRentalIncomeById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanAndPropertyInformationRentalIncomeById(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanAndPropertyInformationRentalIncomeById(
                <any>response_
              );
            } catch (e) {
              return <
                Observable<UpdateLoanAndPropertyInformationRentalIncomeRequest>
              >(<any>_observableThrow(e));
            }
          } else
            return <
              Observable<UpdateLoanAndPropertyInformationRentalIncomeRequest>
            >(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetLoanAndPropertyInformationRentalIncomeById(
    response: HttpResponseBase
  ): Observable<UpdateLoanAndPropertyInformationRentalIncomeRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateLoanAndPropertyInformationRentalIncomeRequest.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateLoanAndPropertyInformationRentalIncomeRequest>(
      <any>null
    );
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addMortageLoanOnProperty(
    body: AddMortageLoanOnPropertyRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/AddMortageLoanOnProperty";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddMortageLoanOnProperty(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddMortageLoanOnProperty(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddMortageLoanOnProperty(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateMortageLoanOnProperty(
    body: UpdateMortageLoanOnPropertyRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/UpdateMortageLoanOnProperty";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateMortageLoanOnProperty(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateMortageLoanOnProperty(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateMortageLoanOnProperty(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteMortageLoanOnProperty(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/DeleteMortageLoanOnProperty?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteMortageLoanOnProperty(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteMortageLoanOnProperty(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteMortageLoanOnProperty(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getMortageLoanOnProperties(): Observable<
    UpdateMortageLoanOnPropertyRequest[]
  > {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/GetMortageLoanOnProperties";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMortageLoanOnProperties(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMortageLoanOnProperties(<any>response_);
            } catch (e) {
              return <Observable<UpdateMortageLoanOnPropertyRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateMortageLoanOnPropertyRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMortageLoanOnProperties(
    response: HttpResponseBase
  ): Observable<UpdateMortageLoanOnPropertyRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateMortageLoanOnPropertyRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateMortageLoanOnPropertyRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getMortageLoanOnPropertyById(
    id: number | undefined
  ): Observable<UpdateMortageLoanOnPropertyRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/LoanService/GetMortageLoanOnPropertyById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMortageLoanOnPropertyById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMortageLoanOnPropertyById(<any>response_);
            } catch (e) {
              return <Observable<UpdateMortageLoanOnPropertyRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateMortageLoanOnPropertyRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMortageLoanOnPropertyById(
    response: HttpResponseBase
  ): Observable<UpdateMortageLoanOnPropertyRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateMortageLoanOnPropertyRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateMortageLoanOnPropertyRequest>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getLoanApplicationDetail(
    id: number | undefined
  ): Observable<GetPdfDataModel> {
    let url_ =
      this.baseUrl + "/api/services/app/LoanService/GetLoanApplicationDetail?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLoanApplicationDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLoanApplicationDetail(<any>response_);
            } catch (e) {
              return <Observable<GetPdfDataModel>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<GetPdfDataModel>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetLoanApplicationDetail(
    response: HttpResponseBase
  ): Observable<GetPdfDataModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetPdfDataModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetPdfDataModel>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  createPdfNew(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/LoanService/CreatePdfNew?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePdfNew(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePdfNew(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreatePdfNew(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ManualAssetEntryServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: ManualAssetEntryDto | undefined
  ): Observable<ManualAssetEntryDto> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ManualAssetEntryDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<ManualAssetEntryDto> {
    let url_ = this.baseUrl + "/api/services/app/ManualAssetEntryService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDto>(<any>null);
  }

  /**
   * @param loanApplicationId (optional)
   * @return Success
   */
  getAllByLoanApplicationId(
    loanApplicationId: number | undefined
  ): Observable<Manualassetentry[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/ManualAssetEntryService/GetAllByLoanApplicationId?";
    if (loanApplicationId === null)
      throw new Error("The parameter 'loanApplicationId' cannot be null.");
    else if (loanApplicationId !== undefined)
      url_ +=
        "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllByLoanApplicationId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllByLoanApplicationId(<any>response_);
            } catch (e) {
              return <Observable<Manualassetentry[]>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<Manualassetentry[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllByLoanApplicationId(
    response: HttpResponseBase
  ): Observable<Manualassetentry[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(Manualassetentry.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<Manualassetentry[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: ManualAssetEntryDto | undefined
  ): Observable<ManualAssetEntryDto> {
    let url_ =
      this.baseUrl + "/api/services/app/ManualAssetEntryService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<ManualAssetEntryDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ManualAssetEntryDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<ManualAssetEntryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ManualAssetEntryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ManualAssetEntryDto>(<any>null);
  }
}

@Injectable()
export class MaritalStatusServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addMaritalStatus(
    body: AddMaritalStatusRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/services/app/MaritalStatusService/AddMaritalStatus";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddMaritalStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddMaritalStatus(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddMaritalStatus(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateMaritalStatus(
    body: UpdateMaritalStatusRequest | undefined
  ): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/MaritalStatusService/UpdateMaritalStatus";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateMaritalStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateMaritalStatus(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateMaritalStatus(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteMaritalStatus(id: number | undefined): Observable<string> {
    let url_ =
      this.baseUrl +
      "/api/services/app/MaritalStatusService/DeleteMaritalStatus?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteMaritalStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteMaritalStatus(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteMaritalStatus(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getMaritalStatuses(): Observable<UpdateMaritalStatusRequest[]> {
    let url_ =
      this.baseUrl +
      "/api/services/app/MaritalStatusService/GetMaritalStatuses";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMaritalStatuses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMaritalStatuses(<any>response_);
            } catch (e) {
              return <Observable<UpdateMaritalStatusRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateMaritalStatusRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMaritalStatuses(
    response: HttpResponseBase
  ): Observable<UpdateMaritalStatusRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateMaritalStatusRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateMaritalStatusRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getMaritalStatusById(
    id: number | undefined
  ): Observable<UpdateMaritalStatusRequest> {
    let url_ =
      this.baseUrl +
      "/api/services/app/MaritalStatusService/GetMaritalStatusById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMaritalStatusById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMaritalStatusById(<any>response_);
            } catch (e) {
              return <Observable<UpdateMaritalStatusRequest>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateMaritalStatusRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetMaritalStatusById(
    response: HttpResponseBase
  ): Observable<UpdateMaritalStatusRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateMaritalStatusRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateMaritalStatusRequest>(<any>null);
  }
}

@Injectable()
export class PersonalDetailServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<PersonalInformationDto> {
    let url_ = this.baseUrl + "/api/services/app/PersonalDetailServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<PersonalInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<PersonalInformationDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/PersonalDetailServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<PersonalInformationDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: PersonalInformationDto | undefined
  ): Observable<PersonalInformationDto> {
    let url_ = this.baseUrl + "/api/services/app/PersonalDetailServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<PersonalInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: PersonalInformationDto | undefined
  ): Observable<PersonalInformationDto> {
    let url_ = this.baseUrl + "/api/services/app/PersonalDetailServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<PersonalInformationDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PersonalInformationDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<PersonalInformationDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PersonalInformationDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PersonalInformationDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/PersonalDetailServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class RefinanceHomeBuyingServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    body: RefinanceHomeBuyingDto | undefined
  ): Observable<RefinanceHomeBuyingDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RefinanceHomeBuyingDtoPagedResultDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDtoPagedResultDto.fromJS(
            resultData200
          );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RefinanceHomeBuyingDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    body: RefinanceHomeBuyingDto | undefined
  ): Observable<RefinanceHomeBuyingDto> {
    let url_ =
      this.baseUrl + "/api/services/app/RefinanceHomeBuyingService/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<RefinanceHomeBuyingDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RefinanceHomeBuyingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<RefinanceHomeBuyingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RefinanceHomeBuyingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RefinanceHomeBuyingDto>(<any>null);
  }
}

@Injectable()
export class RoleServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateRoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param permission (optional)
   * @return Success
   */
  getRoles(
    permission: string | undefined
  ): Observable<RoleListDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
    if (permission === null)
      throw new Error("The parameter 'permission' cannot be null.");
    else if (permission !== undefined)
      url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(<any>response_);
            } catch (e) {
              return <Observable<RoleListDtoListResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RoleListDtoListResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleListDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleListDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleListDtoListResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: RoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPermissions(): Observable<PermissionDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPermissions(<any>response_);
            } catch (e) {
              return <Observable<PermissionDtoListResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<PermissionDtoListResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAllPermissions(
    response: HttpResponseBase
  ): Observable<PermissionDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PermissionDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PermissionDtoListResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoleForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoleForEdit(<any>response_);
            } catch (e) {
              return <Observable<GetRoleForEditOutput>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<GetRoleForEditOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoleForEdit(
    response: HttpResponseBase
  ): Observable<GetRoleForEditOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoleForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetRoleForEditOutput>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<RoleDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<RoleDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RoleDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<RoleDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RoleDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RoleDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDtoPagedResultDto>(<any>null);
  }
}

@Injectable()
export class SessionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
    let url_ =
      this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentLoginInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentLoginInformations(<any>response_);
            } catch (e) {
              return <Observable<GetCurrentLoginInformationsOutput>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<GetCurrentLoginInformationsOutput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCurrentLoginInformations(
    response: HttpResponseBase
  ): Observable<GetCurrentLoginInformationsOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
  }
}

@Injectable()
export class SiteSettingServicesServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: SiteSettingDto | undefined): Observable<SiteSettingDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SiteSettingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<SiteSettingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<SiteSettingDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<SiteSettingDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<SiteSettingDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<SiteSettingDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SiteSettingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SiteSettingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: SiteSettingDto | undefined): Observable<SiteSettingDto> {
    let url_ = this.baseUrl + "/api/services/app/SiteSettingServices/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<SiteSettingDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<SiteSettingDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<SiteSettingDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SiteSettingDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SiteSettingDto>(<any>null);
  }
}

@Injectable()
export class StateServiceServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addState(body: AddStateRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/StateService/AddState";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddState(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddState(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAddState(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateState(body: UpdateStateRequest | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/StateService/UpdateState";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateState(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateState(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateState(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteState(id: number | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/StateService/DeleteState?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteState(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteState(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteState(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  /**
   * @return Success
   */
  getStates(): Observable<UpdateStateRequest[]> {
    let url_ = this.baseUrl + "/api/services/app/StateService/GetStates";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetStates(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetStates(<any>response_);
            } catch (e) {
              return <Observable<UpdateStateRequest[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UpdateStateRequest[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetStates(
    response: HttpResponseBase
  ): Observable<UpdateStateRequest[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(UpdateStateRequest.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateStateRequest[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getStateById(id: number | undefined): Observable<UpdateStateRequest> {
    let url_ = this.baseUrl + "/api/services/app/StateService/GetStateById?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetStateById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetStateById(<any>response_);
            } catch (e) {
              return <Observable<UpdateStateRequest>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<UpdateStateRequest>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetStateById(
    response: HttpResponseBase
  ): Observable<UpdateStateRequest> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UpdateStateRequest.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UpdateStateRequest>(<any>null);
  }
}

@Injectable()
export class TenantServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateTenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<TenantDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<TenantDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<TenantDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<TenantDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDtoPagedResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: TenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<TenantDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<TenantDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TenantDto>(<any>null);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  authenticate(
    body: AuthenticateModel | undefined
  ): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<AuthenticateResultModel>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<AuthenticateResultModel>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processAuthenticate(
    response: HttpResponseBase
  ): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<AuthenticateResultModel>(<any>null);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<
    ExternalLoginProviderInfoModel[]
  > {
    let url_ =
      this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExternalAuthenticationProviders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExternalAuthenticationProviders(
                <any>response_
              );
            } catch (e) {
              return <Observable<ExternalLoginProviderInfoModel[]>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExternalLoginProviderInfoModel[]>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetExternalAuthenticationProviders(
    response: HttpResponseBase
  ): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(ExternalLoginProviderInfoModel.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  externalAuthenticate(
    body: ExternalAuthenticateModel | undefined
  ): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalAuthenticate(<any>response_);
            } catch (e) {
              return <Observable<ExternalAuthenticateResultModel>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExternalAuthenticateResultModel>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processExternalAuthenticate(
    response: HttpResponseBase
  ): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExternalAuthenticateResultModel>(<any>null);
  }
}

@Injectable()
export class UserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateUserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @return Success
   */
  getRoles(): Observable<RoleDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(<any>response_);
            } catch (e) {
              return <Observable<RoleDtoListResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RoleDtoListResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RoleDtoListResultDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(<any>response_);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangeLanguage(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processChangePassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(<any>response_);
            } catch (e) {
              return <Observable<boolean>>(<any>_observableThrow(e));
            }
          } else return <Observable<boolean>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processResetPassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<boolean>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<UserDto>>(<any>_observableThrow(e));
            }
          } else return <Observable<UserDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDto>(<any>null);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<UserDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<UserDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<UserDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UserDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<UserDtoPagedResultDto>(<any>null);
  }
}

export class AddAccountTypeRequest implements IAddAccountTypeRequest {
  financialAccountType1: string | undefined;

  constructor(data?: IAddAccountTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialAccountType1 = _data["financialAccountType1"];
    }
  }

  static fromJS(data: any): AddAccountTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddAccountTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialAccountType1"] = this.financialAccountType1;
    return data;
  }

  clone(): AddAccountTypeRequest {
    const json = this.toJSON();
    let result = new AddAccountTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddAccountTypeRequest {
  financialAccountType1: string | undefined;
}

export class AddAdminDisclosure implements IAddAdminDisclosure {
  title: string | undefined;

  constructor(data?: IAddAdminDisclosure) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
    }
  }

  static fromJS(data: any): AddAdminDisclosure {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminDisclosure();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["title"] = this.title;
    return data;
  }

  clone(): AddAdminDisclosure {
    const json = this.toJSON();
    let result = new AddAdminDisclosure();
    result.init(json);
    return result;
  }
}

export interface IAddAdminDisclosure {
  title: string | undefined;
}

export class AddAdminLoanApplicationDocument
  implements IAddAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number | undefined;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;

  constructor(data?: IAddAdminLoanApplicationDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.disclosureId = _data["disclosureId"];
      this.userId = _data["userId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
      this.documentPath = _data["documentPath"];
    }
  }

  static fromJS(data: any): AddAdminLoanApplicationDocument {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanApplicationDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["disclosureId"] = this.disclosureId;
    data["userId"] = this.userId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    data["documentPath"] = this.documentPath;
    return data;
  }

  clone(): AddAdminLoanApplicationDocument {
    const json = this.toJSON();
    let result = new AddAdminLoanApplicationDocument();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number | undefined;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;
}

export class AddAdminLoanDetail implements IAddAdminLoanDetail {
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;

  constructor(data?: IAddAdminLoanDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanApplicationId = _data["loanApplicationId"];
      this.loanNo = _data["loanNo"];
      this.mortageConsultant = _data["mortageConsultant"];
      this.nmlsId = _data["nmlsId"];
      this.borrowerName = _data["borrowerName"];
      this.propertyAddress = _data["propertyAddress"];
      this.loanProgramId = _data["loanProgramId"];
      this.loanAmount = _data["loanAmount"];
      this.loanPurpose = _data["loanPurpose"];
      this.interestRate = _data["interestRate"];
      this.applicationDate = _data["applicationDate"]
        ? moment(_data["applicationDate"].toString())
        : <any>undefined;
      this.rateLockDate = _data["rateLockDate"]
        ? moment(_data["rateLockDate"].toString())
        : <any>undefined;
      this.rateLockExpirationDate = _data["rateLockExpirationDate"]
        ? moment(_data["rateLockExpirationDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddAdminLoanDetail {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanApplicationId"] = this.loanApplicationId;
    data["loanNo"] = this.loanNo;
    data["mortageConsultant"] = this.mortageConsultant;
    data["nmlsId"] = this.nmlsId;
    data["borrowerName"] = this.borrowerName;
    data["propertyAddress"] = this.propertyAddress;
    data["loanProgramId"] = this.loanProgramId;
    data["loanAmount"] = this.loanAmount;
    data["loanPurpose"] = this.loanPurpose;
    data["interestRate"] = this.interestRate;
    data["applicationDate"] = this.applicationDate
      ? this.applicationDate.toISOString()
      : <any>undefined;
    data["rateLockDate"] = this.rateLockDate
      ? this.rateLockDate.toISOString()
      : <any>undefined;
    data["rateLockExpirationDate"] = this.rateLockExpirationDate
      ? this.rateLockExpirationDate.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddAdminLoanDetail {
    const json = this.toJSON();
    let result = new AddAdminLoanDetail();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanDetail {
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;
}

export class AddAdminLoanProgram implements IAddAdminLoanProgram {
  loanProgram: string | undefined;

  constructor(data?: IAddAdminLoanProgram) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanProgram = _data["loanProgram"];
    }
  }

  static fromJS(data: any): AddAdminLoanProgram {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanProgram();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanProgram"] = this.loanProgram;
    return data;
  }

  clone(): AddAdminLoanProgram {
    const json = this.toJSON();
    let result = new AddAdminLoanProgram();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanProgram {
  loanProgram: string | undefined;
}

export class AddAdminLoanStatus implements IAddAdminLoanStatus {
  status: string | undefined;

  constructor(data?: IAddAdminLoanStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data["status"];
    }
  }

  static fromJS(data: any): AddAdminLoanStatus {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["status"] = this.status;
    return data;
  }

  clone(): AddAdminLoanStatus {
    const json = this.toJSON();
    let result = new AddAdminLoanStatus();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanStatus {
  status: string | undefined;
}

export class AddAdminLoanSummaryStatus implements IAddAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;

  constructor(data?: IAddAdminLoanSummaryStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.statusId = _data["statusId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddAdminLoanSummaryStatus {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminLoanSummaryStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["statusId"] = this.statusId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddAdminLoanSummaryStatus {
    const json = this.toJSON();
    let result = new AddAdminLoanSummaryStatus();
    result.init(json);
    return result;
  }
}

export interface IAddAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;
}

export class AddAdminUserEnabledDevice implements IAddAdminUserEnabledDevice {
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;

  constructor(data?: IAddAdminUserEnabledDevice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deviceId = _data["deviceId"];
      this.bioMetricData = _data["bioMetricData"];
      this.isEnabled = _data["isEnabled"];
    }
  }

  static fromJS(data: any): AddAdminUserEnabledDevice {
    data = typeof data === "object" ? data : {};
    let result = new AddAdminUserEnabledDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["deviceId"] = this.deviceId;
    data["bioMetricData"] = this.bioMetricData;
    data["isEnabled"] = this.isEnabled;
    return data;
  }

  clone(): AddAdminUserEnabledDevice {
    const json = this.toJSON();
    let result = new AddAdminUserEnabledDevice();
    result.init(json);
    return result;
  }
}

export interface IAddAdminUserEnabledDevice {
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;
}

export class AddCitizenshipTypeRequest implements IAddCitizenshipTypeRequest {
  citizenshipType1: string | undefined;

  constructor(data?: IAddCitizenshipTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.citizenshipType1 = _data["citizenshipType1"];
    }
  }

  static fromJS(data: any): AddCitizenshipTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCitizenshipTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["citizenshipType1"] = this.citizenshipType1;
    return data;
  }

  clone(): AddCitizenshipTypeRequest {
    const json = this.toJSON();
    let result = new AddCitizenshipTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCitizenshipTypeRequest {
  citizenshipType1: string | undefined;
}

export class AddCityRequest implements IAddCityRequest {
  stateId: number;
  cityName: string | undefined;

  constructor(data?: IAddCityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stateId = _data["stateId"];
      this.cityName = _data["cityName"];
    }
  }

  static fromJS(data: any): AddCityRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stateId"] = this.stateId;
    data["cityName"] = this.cityName;
    return data;
  }

  clone(): AddCityRequest {
    const json = this.toJSON();
    let result = new AddCityRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCityRequest {
  stateId: number;
  cityName: string | undefined;
}

export class AddCountryRequest implements IAddCountryRequest {
  countryName: string | undefined;

  constructor(data?: IAddCountryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryName = _data["countryName"];
    }
  }

  static fromJS(data: any): AddCountryRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCountryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryName"] = this.countryName;
    return data;
  }

  clone(): AddCountryRequest {
    const json = this.toJSON();
    let result = new AddCountryRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCountryRequest {
  countryName: string | undefined;
}

export class AddCreditTypeRequest implements IAddCreditTypeRequest {
  creditType1: string | undefined;

  constructor(data?: IAddCreditTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creditType1 = _data["creditType1"];
    }
  }

  static fromJS(data: any): AddCreditTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddCreditTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["creditType1"] = this.creditType1;
    return data;
  }

  clone(): AddCreditTypeRequest {
    const json = this.toJSON();
    let result = new AddCreditTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddCreditTypeRequest {
  creditType1: string | undefined;
}

export class AddDeclarationCategoryRequest
  implements IAddDeclarationCategoryRequest {
  declarationCategory1: string | undefined;

  constructor(data?: IAddDeclarationCategoryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategory1 = _data["declarationCategory1"];
    }
  }

  static fromJS(data: any): AddDeclarationCategoryRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDeclarationCategoryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategory1"] = this.declarationCategory1;
    return data;
  }

  clone(): AddDeclarationCategoryRequest {
    const json = this.toJSON();
    let result = new AddDeclarationCategoryRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDeclarationCategoryRequest {
  declarationCategory1: string | undefined;
}

export class AddDeclarationQuestionRequest
  implements IAddDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;

  constructor(data?: IAddDeclarationQuestionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategoryId = _data["declarationCategoryId"];
      this.parentQuestionId = _data["parentQuestionId"];
      this.question = _data["question"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): AddDeclarationQuestionRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDeclarationQuestionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategoryId"] = this.declarationCategoryId;
    data["parentQuestionId"] = this.parentQuestionId;
    data["question"] = this.question;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): AddDeclarationQuestionRequest {
    const json = this.toJSON();
    let result = new AddDeclarationQuestionRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;
}

export class AddDemographicInfoSourceRequest
  implements IAddDemographicInfoSourceRequest {
  value: string | undefined;

  constructor(data?: IAddDemographicInfoSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): AddDemographicInfoSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDemographicInfoSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value;
    return data;
  }

  clone(): AddDemographicInfoSourceRequest {
    const json = this.toJSON();
    let result = new AddDemographicInfoSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDemographicInfoSourceRequest {
  value: string | undefined;
}

export class AddDemographicInformationRequest
  implements IAddDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;

  constructor(data?: IAddDemographicInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.ethnicity81 = _data["ethnicity81"];
      this.gender82 = _data["gender82"];
      this.race83 = _data["race83"];
      this.isEthnicityByObservation84 = _data["isEthnicityByObservation84"];
      this.isGenderByObservation85 = _data["isGenderByObservation85"];
      this.isRaceByObservation86 = _data["isRaceByObservation86"];
      this.demographicInfoSourceId87 = _data["demographicInfoSourceId87"];
    }
  }

  static fromJS(data: any): AddDemographicInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddDemographicInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["ethnicity81"] = this.ethnicity81;
    data["gender82"] = this.gender82;
    data["race83"] = this.race83;
    data["isEthnicityByObservation84"] = this.isEthnicityByObservation84;
    data["isGenderByObservation85"] = this.isGenderByObservation85;
    data["isRaceByObservation86"] = this.isRaceByObservation86;
    data["demographicInfoSourceId87"] = this.demographicInfoSourceId87;
    return data;
  }

  clone(): AddDemographicInformationRequest {
    const json = this.toJSON();
    let result = new AddDemographicInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IAddDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;
}

export class AddHousingTypeRequest implements IAddHousingTypeRequest {
  housingType1: string | undefined;

  constructor(data?: IAddHousingTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.housingType1 = _data["housingType1"];
    }
  }

  static fromJS(data: any): AddHousingTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddHousingTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["housingType1"] = this.housingType1;
    return data;
  }

  clone(): AddHousingTypeRequest {
    const json = this.toJSON();
    let result = new AddHousingTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddHousingTypeRequest {
  housingType1: string | undefined;
}

export class AddIncomeSourceRequest implements IAddIncomeSourceRequest {
  incomeSource1: string | undefined;

  constructor(data?: IAddIncomeSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeSource1 = _data["incomeSource1"];
    }
  }

  static fromJS(data: any): AddIncomeSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddIncomeSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeSource1"] = this.incomeSource1;
    return data;
  }

  clone(): AddIncomeSourceRequest {
    const json = this.toJSON();
    let result = new AddIncomeSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IAddIncomeSourceRequest {
  incomeSource1: string | undefined;
}

export class AddIncomeTypeRequest implements IAddIncomeTypeRequest {
  incomeType1: string | undefined;

  constructor(data?: IAddIncomeTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType1 = _data["incomeType1"];
    }
  }

  static fromJS(data: any): AddIncomeTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddIncomeTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType1"] = this.incomeType1;
    return data;
  }

  clone(): AddIncomeTypeRequest {
    const json = this.toJSON();
    let result = new AddIncomeTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddIncomeTypeRequest {
  incomeType1: string | undefined;
}

export class AddLaibilitiesTypeRequest implements IAddLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;

  constructor(data?: IAddLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialLaibilitiesType1 = _data["financialLaibilitiesType1"];
    }
  }

  static fromJS(data: any): AddLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialLaibilitiesType1"] = this.financialLaibilitiesType1;
    return data;
  }

  clone(): AddLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new AddLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;
}

export class AddLeadApplicationQuestions
  implements IAddLeadApplicationQuestions {
  question: string | undefined;

  constructor(data?: IAddLeadApplicationQuestions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.question = _data["question"];
    }
  }

  static fromJS(data: any): AddLeadApplicationQuestions {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadApplicationQuestions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["question"] = this.question;
    return data;
  }

  clone(): AddLeadApplicationQuestions {
    const json = this.toJSON();
    let result = new AddLeadApplicationQuestions();
    result.init(json);
    return result;
  }
}

export interface IAddLeadApplicationQuestions {
  question: string | undefined;
}

export class AddLeadApplicationType implements IAddLeadApplicationType {
  applicationType: string | undefined;

  constructor(data?: IAddLeadApplicationType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationType = _data["applicationType"];
    }
  }

  static fromJS(data: any): AddLeadApplicationType {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadApplicationType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationType"] = this.applicationType;
    return data;
  }

  clone(): AddLeadApplicationType {
    const json = this.toJSON();
    let result = new AddLeadApplicationType();
    result.init(json);
    return result;
  }
}

export interface IAddLeadApplicationType {
  applicationType: string | undefined;
}

export class AddLeadAssetDetails implements IAddLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;

  constructor(data?: IAddLeadAssetDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.assetTypeId = _data["assetTypeId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.financialInstitution = _data["financialInstitution"];
      this.balance = _data["balance"];
      this.ownerTypeId = _data["ownerTypeId"];
    }
  }

  static fromJS(data: any): AddLeadAssetDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadAssetDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["assetTypeId"] = this.assetTypeId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["financialInstitution"] = this.financialInstitution;
    data["balance"] = this.balance;
    data["ownerTypeId"] = this.ownerTypeId;
    return data;
  }

  clone(): AddLeadAssetDetails {
    const json = this.toJSON();
    let result = new AddLeadAssetDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;
}

export class AddLeadAssetTypes implements IAddLeadAssetTypes {
  assetsType: string | undefined;

  constructor(data?: IAddLeadAssetTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.assetsType = _data["assetsType"];
    }
  }

  static fromJS(data: any): AddLeadAssetTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadAssetTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["assetsType"] = this.assetsType;
    return data;
  }

  clone(): AddLeadAssetTypes {
    const json = this.toJSON();
    let result = new AddLeadAssetTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadAssetTypes {
  assetsType: string | undefined;
}

export class AddLeadEmploymentDetails implements IAddLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementStateName: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;

  constructor(data?: IAddLeadEmploymentDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employeeTypeId = _data["employeeTypeId"];
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.employerName = _data["employerName"];
      this.employementAddress = _data["employementAddress"];
      this.employementSuite = _data["employementSuite"];
      this.employementCity = _data["employementCity"];
      this.employementTaxeId = _data["employementTaxeId"];
      this.employementZip = _data["employementZip"];
      this.employerPhoneNumber = _data["employerPhoneNumber"];
      this.isCurrentJob = _data["isCurrentJob"];
      this.estimatedStartDate = _data["estimatedStartDate"]
        ? moment(_data["estimatedStartDate"].toString())
        : <any>undefined;
      this.jobTitle = _data["jobTitle"];
      this.estimatedAnnualBaseSalary = _data["estimatedAnnualBaseSalary"];
      this.estimatedAnnualBonus = _data["estimatedAnnualBonus"];
      this.estimatedAnnualCommission = _data["estimatedAnnualCommission"];
      this.estimatedAnnualOvertime = _data["estimatedAnnualOvertime"];
      this.isCoBorrower = _data["isCoBorrower"];
    }
  }

  static fromJS(data: any): AddLeadEmploymentDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadEmploymentDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employeeTypeId"] = this.employeeTypeId;
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["employerName"] = this.employerName;
    data["employementAddress"] = this.employementAddress;
    data["employementSuite"] = this.employementSuite;
    data["employementCity"] = this.employementCity;
    data["employementTaxeId"] = this.employementTaxeId;
    data["employementZip"] = this.employementZip;
    data["employerPhoneNumber"] = this.employerPhoneNumber;
    data["isCurrentJob"] = this.isCurrentJob;
    data["estimatedStartDate"] = this.estimatedStartDate
      ? this.estimatedStartDate.toString()
      : <any>undefined;
    data["jobTitle"] = this.jobTitle;
    data["estimatedAnnualBaseSalary"] = this.estimatedAnnualBaseSalary;
    data["estimatedAnnualBonus"] = this.estimatedAnnualBonus;
    data["estimatedAnnualCommission"] = this.estimatedAnnualCommission;
    data["estimatedAnnualOvertime"] = this.estimatedAnnualOvertime;
    data["isCoBorrower"] = this.isCoBorrower;
    return data;
  }

  clone(): AddLeadEmploymentDetails {
    const json = this.toJSON();
    let result = new AddLeadEmploymentDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementStateName: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;
}

export class AddLeadEmploymentTypes implements IAddLeadEmploymentTypes {
  employementType: string | undefined;

  constructor(data?: IAddLeadEmploymentTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employementType = _data["employementType"];
    }
  }

  static fromJS(data: any): AddLeadEmploymentTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadEmploymentTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employementType"] = this.employementType;
    return data;
  }

  clone(): AddLeadEmploymentTypes {
    const json = this.toJSON();
    let result = new AddLeadEmploymentTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadEmploymentTypes {
  employementType: string | undefined;
}

export class AddLeadIncomeTypes implements IAddLeadIncomeTypes {
  incomeType: string | undefined;

  constructor(data?: IAddLeadIncomeTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType = _data["incomeType"];
    }
  }

  static fromJS(data: any): AddLeadIncomeTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadIncomeTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType"] = this.incomeType;
    return data;
  }

  clone(): AddLeadIncomeTypes {
    const json = this.toJSON();
    let result = new AddLeadIncomeTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadIncomeTypes {
  incomeType: string | undefined;
}

export class AddLeadOwnerTypes implements IAddLeadOwnerTypes {
  ownerType: string | undefined;

  constructor(data?: IAddLeadOwnerTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ownerType = _data["ownerType"];
    }
  }

  static fromJS(data: any): AddLeadOwnerTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadOwnerTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ownerType"] = this.ownerType;
    return data;
  }

  clone(): AddLeadOwnerTypes {
    const json = this.toJSON();
    let result = new AddLeadOwnerTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadOwnerTypes {
  ownerType: string | undefined;
}

export class AddLeadPurchasingDetail implements IAddLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;

  constructor(data?: IAddLeadPurchasingDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stage = _data["stage"];
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.newHomeAddress = _data["newHomeAddress"];
      this.newHomeUnit = _data["newHomeUnit"];
      this.newHomeCity = _data["newHomeCity"];
      this.newHomeStateId = _data["newHomeStateId"];
      this.newHomeZipCode = _data["newHomeZipCode"];
      this.contractClosingDate = _data["contractClosingDate"]
        ? moment(_data["contractClosingDate"].toString())
        : <any>undefined;
      this.contractType = _data["contractType"];
      this.estimatedHomePrice = _data["estimatedHomePrice"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.creditScore = _data["creditScore"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.typeOfNewHome = _data["typeOfNewHome"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isSomeOneRefer = _data["isSomeOneRefer"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isOtherSourceOfIncome = _data["isOtherSourceOfIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddLeadPurchasingDetail {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadPurchasingDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stage"] = this.stage;
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["newHomeAddress"] = this.newHomeAddress;
    data["newHomeUnit"] = this.newHomeUnit;
    data["newHomeCity"] = this.newHomeCity;
    data["newHomeStateId"] = this.newHomeStateId;
    data["newHomeZipCode"] = this.newHomeZipCode;
    data["contractClosingDate"] = this.contractClosingDate
      ? this.contractClosingDate.toISOString()
      : <any>undefined;
    data["contractType"] = this.contractType;
    data["estimatedHomePrice"] = this.estimatedHomePrice;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["creditScore"] = this.creditScore;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["typeOfNewHome"] = this.typeOfNewHome;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data["isSomeOneRefer"] = this.isSomeOneRefer;
    data["isApplyOwn"] = this.isApplyOwn;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isOtherSourceOfIncome"] = this.isOtherSourceOfIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddLeadPurchasingDetail {
    const json = this.toJSON();
    let result = new AddLeadPurchasingDetail();
    result.init(json);
    return result;
  }
}

export interface IAddLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
}

export class AddLeadQuestionAnswers implements IAddLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;

  constructor(data?: IAddLeadQuestionAnswers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.questionId = _data["questionId"];
      this.isYes = _data["isYes"];
    }
  }

  static fromJS(data: any): AddLeadQuestionAnswers {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadQuestionAnswers();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["questionId"] = this.questionId;
    data["isYes"] = this.isYes;
    return data;
  }

  clone(): AddLeadQuestionAnswers {
    const json = this.toJSON();
    let result = new AddLeadQuestionAnswers();
    result.init(json);
    return result;
  }
}

export interface IAddLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;
}

export class AddLeadRefinancingDetails implements IAddLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;

  constructor(data?: IAddLeadRefinancingDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.objectiveReason = _data["objectiveReason"];
      this.propertyAddress = _data["propertyAddress"];
      this.propertyUnit = _data["propertyUnit"];
      this.propertyCity = _data["propertyCity"];
      this.propertyZip = _data["propertyZip"];
      this.propertyStateId = _data["propertyStateId"];
      this.propertyCountryId = _data["propertyCountryId"];
      this.propertyEstimatedValue = _data["propertyEstimatedValue"];
      this.propertyLoanBalance = _data["propertyLoanBalance"];
      this.propertCashOutAmount = _data["propertCashOutAmount"];
      this.newLoanEstimateAmount = _data["newLoanEstimateAmount"];
      this.creditScore = _data["creditScore"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.yearHomePurchased = _data["yearHomePurchased"];
      this.orignalPurchasedPrice = _data["orignalPurchasedPrice"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.currentlyUsingHomeAs = _data["currentlyUsingHomeAs"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.propertyPassword = _data["propertyPassword"];
      this.isSomeoneRefer = _data["isSomeoneRefer"];
      this.refferedBy = _data["refferedBy"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.isLegalSpouse = _data["isLegalSpouse"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.firstDependantAge = _data["firstDependantAge"];
      this.isCurrentlyLivingOnRefinancingProperty =
        _data["isCurrentlyLivingOnRefinancingProperty"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isAddressSameAsPrimaryBorrower =
        _data["isAddressSameAsPrimaryBorrower"];
      this.personalAddress = _data["personalAddress"];
      this.personalUnit = _data["personalUnit"];
      this.personalCity = _data["personalCity"];
      this.personalStateId = _data["personalStateId"];
      this.personalZipCode = _data["personalZipCode"];
      this.personalStartLivingDate = _data["personalStartLivingDate"]
        ? moment(_data["personalStartLivingDate"].toString())
        : <any>undefined;
      this.personalReantingType = _data["personalReantingType"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isCoBorrowerHaveShareIncome = _data["isCoBorrowerHaveShareIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddLeadRefinancingDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadRefinancingDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["objectiveReason"] = this.objectiveReason;
    data["propertyAddress"] = this.propertyAddress;
    data["propertyUnit"] = this.propertyUnit;
    data["propertyCity"] = this.propertyCity;
    data["propertyZip"] = this.propertyZip;
    data["propertyStateId"] = this.propertyStateId;
    data["propertyCountryId"] = this.propertyCountryId;
    data["propertyEstimatedValue"] = this.propertyEstimatedValue;
    data["propertyLoanBalance"] = this.propertyLoanBalance;
    data["propertCashOutAmount"] = this.propertCashOutAmount;
    data["newLoanEstimateAmount"] = this.newLoanEstimateAmount;
    data["creditScore"] = this.creditScore;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["yearHomePurchased"] = this.yearHomePurchased;
    data["orignalPurchasedPrice"] = this.orignalPurchasedPrice;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["currentlyUsingHomeAs"] = this.currentlyUsingHomeAs;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["propertyPassword"] = this.propertyPassword;
    data["isSomeoneRefer"] = this.isSomeoneRefer;
    data["refferedBy"] = this.refferedBy;
    data["isApplyOwn"] = this.isApplyOwn;
    data["isLegalSpouse"] = this.isLegalSpouse;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["firstDependantAge"] = this.firstDependantAge;
    data[
      "isCurrentlyLivingOnRefinancingProperty"
    ] = this.isCurrentlyLivingOnRefinancingProperty;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data[
      "isAddressSameAsPrimaryBorrower"
    ] = this.isAddressSameAsPrimaryBorrower;
    data["personalAddress"] = this.personalAddress;
    data["personalUnit"] = this.personalUnit;
    data["personalCity"] = this.personalCity;
    data["personalStateId"] = this.personalStateId;
    data["personalZipCode"] = this.personalZipCode;
    data["personalStartLivingDate"] = this.personalStartLivingDate
      ? this.personalStartLivingDate.toISOString()
      : <any>undefined;
    data["personalReantingType"] = this.personalReantingType;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isCoBorrowerHaveShareIncome"] = this.isCoBorrowerHaveShareIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddLeadRefinancingDetails {
    const json = this.toJSON();
    let result = new AddLeadRefinancingDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
}

export class AddLeadRefinancingIncomeDetails
  implements IAddLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;

  constructor(data?: IAddLeadRefinancingIncomeDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.incomeTypeId = _data["incomeTypeId"];
      this.monthlyAmount = _data["monthlyAmount"];
    }
  }

  static fromJS(data: any): AddLeadRefinancingIncomeDetails {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadRefinancingIncomeDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["incomeTypeId"] = this.incomeTypeId;
    data["monthlyAmount"] = this.monthlyAmount;
    return data;
  }

  clone(): AddLeadRefinancingIncomeDetails {
    const json = this.toJSON();
    let result = new AddLeadRefinancingIncomeDetails();
    result.init(json);
    return result;
  }
}

export interface IAddLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;
}

export class AddLeadTaxTypes implements IAddLeadTaxTypes {
  taxesType: string | undefined;

  constructor(data?: IAddLeadTaxTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.taxesType = _data["taxesType"];
    }
  }

  static fromJS(data: any): AddLeadTaxTypes {
    data = typeof data === "object" ? data : {};
    let result = new AddLeadTaxTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["taxesType"] = this.taxesType;
    return data;
  }

  clone(): AddLeadTaxTypes {
    const json = this.toJSON();
    let result = new AddLeadTaxTypes();
    result.init(json);
    return result;
  }
}

export interface IAddLeadTaxTypes {
  taxesType: string | undefined;
}

export class AddLoanAndPropertyInformationGiftRequest
  implements IAddLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationGiftRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanPropertyGiftTypeId4d1 = _data["loanPropertyGiftTypeId4d1"];
      this.deposited4d2 = _data["deposited4d2"];
      this.source4d3 = _data["source4d3"];
      this.value4d4 = _data["value4d4"];
    }
  }

  static fromJS(data: any): AddLoanAndPropertyInformationGiftRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationGiftRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanPropertyGiftTypeId4d1"] = this.loanPropertyGiftTypeId4d1;
    data["deposited4d2"] = this.deposited4d2;
    data["source4d3"] = this.source4d3;
    data["value4d4"] = this.value4d4;
    return data;
  }

  clone(): AddLoanAndPropertyInformationGiftRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationGiftRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;
}

export class AddLoanAndPropertyInformationOtherMortageLoanRequest
  implements IAddLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationOtherMortageLoanRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.creditorName4b1 = _data["creditorName4b1"];
      this.lienType4b2 = _data["lienType4b2"];
      this.monthlyPayment4b3 = _data["monthlyPayment4b3"];
      this.loanAmount4b4 = _data["loanAmount4b4"];
      this.creditAmount4b5 = _data["creditAmount4b5"];
    }
  }

  static fromJS(
    data: any
  ): AddLoanAndPropertyInformationOtherMortageLoanRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["creditorName4b1"] = this.creditorName4b1;
    data["lienType4b2"] = this.lienType4b2;
    data["monthlyPayment4b3"] = this.monthlyPayment4b3;
    data["loanAmount4b4"] = this.loanAmount4b4;
    data["creditAmount4b5"] = this.creditAmount4b5;
    return data;
  }

  clone(): AddLoanAndPropertyInformationOtherMortageLoanRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;
}

export class AddLoanAndPropertyInformationRentalIncomeRequest
  implements IAddLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationRentalIncomeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.expectedMonthlyIncome4c1 = _data["expectedMonthlyIncome4c1"];
      this.lenderExpectedMonthlyIncome4c2 =
        _data["lenderExpectedMonthlyIncome4c2"];
    }
  }

  static fromJS(data: any): AddLoanAndPropertyInformationRentalIncomeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationRentalIncomeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["expectedMonthlyIncome4c1"] = this.expectedMonthlyIncome4c1;
    data[
      "lenderExpectedMonthlyIncome4c2"
    ] = this.lenderExpectedMonthlyIncome4c2;
    return data;
  }

  clone(): AddLoanAndPropertyInformationRentalIncomeRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationRentalIncomeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;
}

export class AddLoanAndPropertyInformationRequest
  implements IAddLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;

  constructor(data?: IAddLoanAndPropertyInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanAmount4a1 = _data["loanAmount4a1"];
      this.loanPurpose4a2 = _data["loanPurpose4a2"];
      this.propertyStreet4a31 = _data["propertyStreet4a31"];
      this.propertyUnitNo4a32 = _data["propertyUnitNo4a32"];
      this.propertyZip4a35 = _data["propertyZip4a35"];
      this.countryId4a36 = _data["countryId4a36"];
      this.stateId4a34 = _data["stateId4a34"];
      this.cityId4a33 = _data["cityId4a33"];
      this.propertyNumberUnits4a4 = _data["propertyNumberUnits4a4"];
      this.propertyValue4a5 = _data["propertyValue4a5"];
      this.loanPropertyOccupancyId4a6 = _data["loanPropertyOccupancyId4a6"];
      this.fhaSecondaryResidance4a61 = _data["fhaSecondaryResidance4a61"];
      this.isMixedUseProperty4a7 = _data["isMixedUseProperty4a7"];
      this.isManufacturedHome4a8 = _data["isManufacturedHome4a8"];
    }
  }

  static fromJS(data: any): AddLoanAndPropertyInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanAndPropertyInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanAmount4a1"] = this.loanAmount4a1;
    data["loanPurpose4a2"] = this.loanPurpose4a2;
    data["propertyStreet4a31"] = this.propertyStreet4a31;
    data["propertyUnitNo4a32"] = this.propertyUnitNo4a32;
    data["propertyZip4a35"] = this.propertyZip4a35;
    data["countryId4a36"] = this.countryId4a36;
    data["stateId4a34"] = this.stateId4a34;
    data["cityId4a33"] = this.cityId4a33;
    data["propertyNumberUnits4a4"] = this.propertyNumberUnits4a4;
    data["propertyValue4a5"] = this.propertyValue4a5;
    data["loanPropertyOccupancyId4a6"] = this.loanPropertyOccupancyId4a6;
    data["fhaSecondaryResidance4a61"] = this.fhaSecondaryResidance4a61;
    data["isMixedUseProperty4a7"] = this.isMixedUseProperty4a7;
    data["isManufacturedHome4a8"] = this.isManufacturedHome4a8;
    return data;
  }

  clone(): AddLoanAndPropertyInformationRequest {
    const json = this.toJSON();
    let result = new AddLoanAndPropertyInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;
}

export class AddLoanOriginatorInformationRequest
  implements IAddLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;

  constructor(data?: IAddLoanOriginatorInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.organizationName91 = _data["organizationName91"];
      this.address92 = _data["address92"];
      this.organizationNmlsrId93 = _data["organizationNmlsrId93"];
      this.organizationStateLicence94 = _data["organizationStateLicence94"];
      this.originatorName95 = _data["originatorName95"];
      this.originatorNmlsrId96 = _data["originatorNmlsrId96"];
      this.originatorStateLicense97 = _data["originatorStateLicense97"];
      this.email98 = _data["email98"];
      this.phone99 = _data["phone99"];
      this.date910 = _data["date910"]
        ? moment(_data["date910"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddLoanOriginatorInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanOriginatorInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["organizationName91"] = this.organizationName91;
    data["address92"] = this.address92;
    data["organizationNmlsrId93"] = this.organizationNmlsrId93;
    data["organizationStateLicence94"] = this.organizationStateLicence94;
    data["originatorName95"] = this.originatorName95;
    data["originatorNmlsrId96"] = this.originatorNmlsrId96;
    data["originatorStateLicense97"] = this.originatorStateLicense97;
    data["email98"] = this.email98;
    data["phone99"] = this.phone99;
    data["date910"] = this.date910
      ? this.date910.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): AddLoanOriginatorInformationRequest {
    const json = this.toJSON();
    let result = new AddLoanOriginatorInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;
}

export class AddLoanPropertyGiftTypeRequest
  implements IAddLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;

  constructor(data?: IAddLoanPropertyGiftTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyGiftType1 = _data["loanPropertyGiftType1"];
    }
  }

  static fromJS(data: any): AddLoanPropertyGiftTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanPropertyGiftTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyGiftType1"] = this.loanPropertyGiftType1;
    return data;
  }

  clone(): AddLoanPropertyGiftTypeRequest {
    const json = this.toJSON();
    let result = new AddLoanPropertyGiftTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;
}

export class AddLoanPropertyOccupancyRequest
  implements IAddLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;

  constructor(data?: IAddLoanPropertyOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyOccupancy1 = _data["loanPropertyOccupancy1"];
    }
  }

  static fromJS(data: any): AddLoanPropertyOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddLoanPropertyOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyOccupancy1"] = this.loanPropertyOccupancy1;
    return data;
  }

  clone(): AddLoanPropertyOccupancyRequest {
    const json = this.toJSON();
    let result = new AddLoanPropertyOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IAddLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;
}

export class AddMaritalStatusRequest implements IAddMaritalStatusRequest {
  maritialStatus1: string | undefined;

  constructor(data?: IAddMaritalStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.maritialStatus1 = _data["maritialStatus1"];
    }
  }

  static fromJS(data: any): AddMaritalStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddMaritalStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["maritialStatus1"] = this.maritialStatus1;
    return data;
  }

  clone(): AddMaritalStatusRequest {
    const json = this.toJSON();
    let result = new AddMaritalStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IAddMaritalStatusRequest {
  maritialStatus1: string | undefined;
}

export class AddMortageLoanOnPropertyRequest
  implements IAddMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;

  constructor(data?: IAddMortageLoanOnPropertyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationFinancialRealEstateId =
        _data["applicationFinancialRealEstateId"];
      this.creditorName3a9 = _data["creditorName3a9"];
      this.accountNumber3a10 = _data["accountNumber3a10"];
      this.monthlyMortagePayment3a11 = _data["monthlyMortagePayment3a11"];
      this.unpaidBalance3a12 = _data["unpaidBalance3a12"];
      this.paidOff3a13 = _data["paidOff3a13"];
      this.mortageLoanTypesId3a14 = _data["mortageLoanTypesId3a14"];
      this.creditLimit3a15 = _data["creditLimit3a15"];
    }
  }

  static fromJS(data: any): AddMortageLoanOnPropertyRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddMortageLoanOnPropertyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationFinancialRealEstateId"
    ] = this.applicationFinancialRealEstateId;
    data["creditorName3a9"] = this.creditorName3a9;
    data["accountNumber3a10"] = this.accountNumber3a10;
    data["monthlyMortagePayment3a11"] = this.monthlyMortagePayment3a11;
    data["unpaidBalance3a12"] = this.unpaidBalance3a12;
    data["paidOff3a13"] = this.paidOff3a13;
    data["mortageLoanTypesId3a14"] = this.mortageLoanTypesId3a14;
    data["creditLimit3a15"] = this.creditLimit3a15;
    return data;
  }

  clone(): AddMortageLoanOnPropertyRequest {
    const json = this.toJSON();
    let result = new AddMortageLoanOnPropertyRequest();
    result.init(json);
    return result;
  }
}

export interface IAddMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;
}

export class AddMortageLoanTypeRequest implements IAddMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;

  constructor(data?: IAddMortageLoanTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mortageLoanTypesId = _data["mortageLoanTypesId"];
    }
  }

  static fromJS(data: any): AddMortageLoanTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddMortageLoanTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["mortageLoanTypesId"] = this.mortageLoanTypesId;
    return data;
  }

  clone(): AddMortageLoanTypeRequest {
    const json = this.toJSON();
    let result = new AddMortageLoanTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;
}

export class AddOtherLaibilitiesTypeRequest
  implements IAddOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;

  constructor(data?: IAddOtherLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialOtherLaibilitiesType1 =
        _data["financialOtherLaibilitiesType1"];
    }
  }

  static fromJS(data: any): AddOtherLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddOtherLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialOtherLaibilitiesType1"
    ] = this.financialOtherLaibilitiesType1;
    return data;
  }

  clone(): AddOtherLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new AddOtherLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IAddOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;
}

export class AddPropertyIntendedOccupancyRequest
  implements IAddPropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;

  constructor(data?: IAddPropertyIntendedOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyIntendedOccupancy1 =
        _data["financialPropertyIntendedOccupancy1"];
    }
  }

  static fromJS(data: any): AddPropertyIntendedOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddPropertyIntendedOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialPropertyIntendedOccupancy1"
    ] = this.financialPropertyIntendedOccupancy1;
    return data;
  }

  clone(): AddPropertyIntendedOccupancyRequest {
    const json = this.toJSON();
    let result = new AddPropertyIntendedOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;
}

export class AddPropertyStatusRequest implements IAddPropertyStatusRequest {
  financialPropertyStatus1: string | undefined;

  constructor(data?: IAddPropertyStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyStatus1 = _data["financialPropertyStatus1"];
    }
  }

  static fromJS(data: any): AddPropertyStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddPropertyStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialPropertyStatus1"] = this.financialPropertyStatus1;
    return data;
  }

  clone(): AddPropertyStatusRequest {
    const json = this.toJSON();
    let result = new AddPropertyStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IAddPropertyStatusRequest {
  financialPropertyStatus1: string | undefined;
}

export class AddStateRequest implements IAddStateRequest {
  countryId: number;
  stateName: string | undefined;

  constructor(data?: IAddStateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryId = _data["countryId"];
      this.stateName = _data["stateName"];
    }
  }

  static fromJS(data: any): AddStateRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddStateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryId"] = this.countryId;
    data["stateName"] = this.stateName;
    return data;
  }

  clone(): AddStateRequest {
    const json = this.toJSON();
    let result = new AddStateRequest();
    result.init(json);
    return result;
  }
}

export interface IAddStateRequest {
  countryId: number;
  stateName: string | undefined;
}

export class AdditionalDetailsDto implements IAdditionalDetailsDto {
  id: number | undefined;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;

  constructor(data?: IAdditionalDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.nameOfIndividualsOnTitle = _data["nameOfIndividualsOnTitle"];
      this.nameOfIndividualsCoBorrowerOnTitle =
        _data["nameOfIndividualsCoBorrowerOnTitle"];
    }
  }

  static fromJS(data: any): AdditionalDetailsDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["nameOfIndividualsOnTitle"] = this.nameOfIndividualsOnTitle;
    data[
      "nameOfIndividualsCoBorrowerOnTitle"
    ] = this.nameOfIndividualsCoBorrowerOnTitle;
    return data;
  }

  clone(): AdditionalDetailsDto {
    const json = this.toJSON();
    let result = new AdditionalDetailsDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalDetailsDto {
  id: number | undefined;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;
}

export class AdditionalDetailsDtoPagedResultDto
  implements IAdditionalDetailsDtoPagedResultDto {
  items: AdditionalDetailsDto[] | undefined;
  totalCount: number;

  constructor(data?: IAdditionalDetailsDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(AdditionalDetailsDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): AdditionalDetailsDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalDetailsDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): AdditionalDetailsDtoPagedResultDto {
    const json = this.toJSON();
    let result = new AdditionalDetailsDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalDetailsDtoPagedResultDto {
  items: AdditionalDetailsDto[] | undefined;
  totalCount: number;
}

export class AdditionalEmployementIncomeDetail
  implements IAdditionalEmployementIncomeDetail {
  id: number;
  applicationAdditionalEmployementDetails: number;
  incomeType: string | undefined;
  amount: number | undefined;

  constructor(data?: IAdditionalEmployementIncomeDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.applicationAdditionalEmployementDetails =
        _data["applicationAdditionalEmployementDetails"];
      this.incomeType = _data["incomeType"];
      this.amount = _data["amount"];
    }
  }

  static fromJS(data: any): AdditionalEmployementIncomeDetail {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalEmployementIncomeDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data[
      "applicationAdditionalEmployementDetails"
    ] = this.applicationAdditionalEmployementDetails;
    data["incomeType"] = this.incomeType;
    data["amount"] = this.amount;
    return data;
  }

  clone(): AdditionalEmployementIncomeDetail {
    const json = this.toJSON();
    let result = new AdditionalEmployementIncomeDetail();
    result.init(json);
    return result;
  }
}

export interface IAdditionalEmployementIncomeDetail {
  id: number;
  applicationAdditionalEmployementDetails: number;
  incomeType: string | undefined;
  amount: number | undefined;
}

export class AdditionalEmploymentDetail implements IAdditionalEmploymentDetail {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName: string | undefined;
  phone: string | undefined;
  street: string | undefined;
  unit: string | undefined;
  zip: string | undefined;
  country: string | undefined;
  state: string | undefined;
  city: string | undefined;
  positionTitle: string | undefined;
  startDate: moment.Moment | undefined;
  workingYears: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone: boolean | undefined;
  isSelfEmployed: boolean | undefined;
  isOwnershipLessThan25: boolean | undefined;
  monthlyIncome: number | undefined;
  employementIncomeDetail: AdditionalEmployementIncomeDetail[] | undefined;

  constructor(data?: IAdditionalEmploymentDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName = _data["employerBusinessName"];
      this.phone = _data["phone"];
      this.street = _data["street"];
      this.unit = _data["unit"];
      this.zip = _data["zip"];
      this.country = _data["country"];
      this.state = _data["state"];
      this.city = _data["city"];
      this.positionTitle = _data["positionTitle"];
      this.startDate = _data["startDate"]
        ? moment(_data["startDate"].toString())
        : <any>undefined;
      this.workingYears = _data["workingYears"];
      this.workingMonths = _data["workingMonths"];
      this.isEmployedBySomeone = _data["isEmployedBySomeone"];
      this.isSelfEmployed = _data["isSelfEmployed"];
      this.isOwnershipLessThan25 = _data["isOwnershipLessThan25"];
      this.monthlyIncome = _data["monthlyIncome"];
      if (Array.isArray(_data["employementIncomeDetail"])) {
        this.employementIncomeDetail = [] as any;
        for (let item of _data["employementIncomeDetail"])
          this.employementIncomeDetail.push(
            AdditionalEmployementIncomeDetail.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): AdditionalEmploymentDetail {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalEmploymentDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName"] = this.employerBusinessName;
    data["phone"] = this.phone;
    data["street"] = this.street;
    data["unit"] = this.unit;
    data["zip"] = this.zip;
    data["country"] = this.country;
    data["state"] = this.state;
    data["city"] = this.city;
    data["positionTitle"] = this.positionTitle;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["workingYears"] = this.workingYears;
    data["workingMonths"] = this.workingMonths;
    data["isEmployedBySomeone"] = this.isEmployedBySomeone;
    data["isSelfEmployed"] = this.isSelfEmployed;
    data["isOwnershipLessThan25"] = this.isOwnershipLessThan25;
    data["monthlyIncome"] = this.monthlyIncome;
    if (Array.isArray(this.employementIncomeDetail)) {
      data["employementIncomeDetail"] = [];
      for (let item of this.employementIncomeDetail)
        data["employementIncomeDetail"].push(item.toJSON());
    }
    return data;
  }

  clone(): AdditionalEmploymentDetail {
    const json = this.toJSON();
    let result = new AdditionalEmploymentDetail();
    result.init(json);
    return result;
  }
}

export interface IAdditionalEmploymentDetail {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName: string | undefined;
  phone: string | undefined;
  street: string | undefined;
  unit: string | undefined;
  zip: string | undefined;
  country: string | undefined;
  state: string | undefined;
  city: string | undefined;
  positionTitle: string | undefined;
  startDate: moment.Moment | undefined;
  workingYears: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone: boolean | undefined;
  isSelfEmployed: boolean | undefined;
  isOwnershipLessThan25: boolean | undefined;
  monthlyIncome: number | undefined;
  employementIncomeDetail: AdditionalEmployementIncomeDetail[] | undefined;
}

export class AdditionalIncomeDto implements IAdditionalIncomeDto {
  id: number | undefined;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;

  constructor(data?: IAdditionalIncomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.amount = _data["amount"];
      this.incomeSourceId = _data["incomeSourceId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): AdditionalIncomeDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalIncomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["amount"] = this.amount;
    data["incomeSourceId"] = this.incomeSourceId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): AdditionalIncomeDto {
    const json = this.toJSON();
    let result = new AdditionalIncomeDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalIncomeDto {
  id: number | undefined;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;
}

export class AdditionalIncomeDtoPagedResultDto
  implements IAdditionalIncomeDtoPagedResultDto {
  items: AdditionalIncomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IAdditionalIncomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(AdditionalIncomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): AdditionalIncomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new AdditionalIncomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): AdditionalIncomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new AdditionalIncomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IAdditionalIncomeDtoPagedResultDto {
  items: AdditionalIncomeDto[] | undefined;
  totalCount: number;
}

export class Additionaldetail implements IAdditionaldetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;
  loanapplications: Loanapplication[] | undefined;

  constructor(data?: IAdditionaldetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.nameOfIndividualsOnTitle = _data["nameOfIndividualsOnTitle"];
      this.nameOfIndividualsCoBorrowerOnTitle =
        _data["nameOfIndividualsCoBorrowerOnTitle"];
      if (Array.isArray(_data["loanapplications"])) {
        this.loanapplications = [] as any;
        for (let item of _data["loanapplications"])
          this.loanapplications.push(Loanapplication.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Additionaldetail {
    data = typeof data === "object" ? data : {};
    let result = new Additionaldetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["nameOfIndividualsOnTitle"] = this.nameOfIndividualsOnTitle;
    data[
      "nameOfIndividualsCoBorrowerOnTitle"
    ] = this.nameOfIndividualsCoBorrowerOnTitle;
    if (Array.isArray(this.loanapplications)) {
      data["loanapplications"] = [];
      for (let item of this.loanapplications)
        data["loanapplications"].push(item.toJSON());
    }
    return data;
  }

  clone(): Additionaldetail {
    const json = this.toJSON();
    let result = new Additionaldetail();
    result.init(json);
    return result;
  }
}

export interface IAdditionaldetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  nameOfIndividualsOnTitle: string | undefined;
  nameOfIndividualsCoBorrowerOnTitle: string | undefined;
  loanapplications: Loanapplication[] | undefined;
}

export class Additionalincome implements IAdditionalincome {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  incomeSource: Incomesource1;
  loanApplication: Loanapplication;

  constructor(data?: IAdditionalincome) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.amount = _data["amount"];
      this.incomeSourceId = _data["incomeSourceId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.incomeSource = _data["incomeSource"]
        ? Incomesource1.fromJS(_data["incomeSource"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? Loanapplication.fromJS(_data["loanApplication"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Additionalincome {
    data = typeof data === "object" ? data : {};
    let result = new Additionalincome();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["amount"] = this.amount;
    data["incomeSourceId"] = this.incomeSourceId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["incomeSource"] = this.incomeSource
      ? this.incomeSource.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Additionalincome {
    const json = this.toJSON();
    let result = new Additionalincome();
    result.init(json);
    return result;
  }
}

export interface IAdditionalincome {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  amount: number | undefined;
  incomeSourceId: number | undefined;
  borrowerTypeId: number | undefined;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  incomeSource: Incomesource1;
  loanApplication: Loanapplication;
}

export class Address implements IAddress {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  addressType: string | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;
  personalDetailId: number;
  borrowerTypeId: number;
  borrowerType: Borrowertype;
  personalDetail: Personaldetail;
  state: State;

  constructor(data?: IAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.addressType = _data["addressType"];
      this.addressLine1 = _data["addressLine1"];
      this.addressLine2 = _data["addressLine2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.years = _data["years"];
      this.months = _data["months"];
      this.personalDetailId = _data["personalDetailId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.personalDetail = _data["personalDetail"]
        ? Personaldetail.fromJS(_data["personalDetail"])
        : <any>undefined;
      this.state = _data["state"]
        ? State.fromJS(_data["state"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Address {
    data = typeof data === "object" ? data : {};
    let result = new Address();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["addressType"] = this.addressType;
    data["addressLine1"] = this.addressLine1;
    data["addressLine2"] = this.addressLine2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["years"] = this.years;
    data["months"] = this.months;
    data["personalDetailId"] = this.personalDetailId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["personalDetail"] = this.personalDetail
      ? this.personalDetail.toJSON()
      : <any>undefined;
    data["state"] = this.state ? this.state.toJSON() : <any>undefined;
    return data;
  }

  clone(): Address {
    const json = this.toJSON();
    let result = new Address();
    result.init(json);
    return result;
  }
}

export interface IAddress {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  addressType: string | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;
  personalDetailId: number;
  borrowerTypeId: number;
  borrowerType: Borrowertype;
  personalDetail: Personaldetail;
  state: State;
}

export class AddressDto implements IAddressDto {
  id: number | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;

  constructor(data?: IAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.addressLine1 = _data["addressLine1"];
      this.addressLine2 = _data["addressLine2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.years = _data["years"];
      this.months = _data["months"];
    }
  }

  static fromJS(data: any): AddressDto {
    data = typeof data === "object" ? data : {};
    let result = new AddressDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["addressLine1"] = this.addressLine1;
    data["addressLine2"] = this.addressLine2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["years"] = this.years;
    data["months"] = this.months;
    return data;
  }

  clone(): AddressDto {
    const json = this.toJSON();
    let result = new AddressDto();
    result.init(json);
    return result;
  }
}

export interface IAddressDto {
  id: number | undefined;
  addressLine1: string | undefined;
  addressLine2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  years: number | undefined;
  months: number | undefined;
}

export class ApplicationDeclarationQuestion
  implements IApplicationDeclarationQuestion {
  isParent: boolean | undefined;
  question: string | undefined;
  answer: string | undefined;
  yesNo: boolean | undefined;

  constructor(data?: IApplicationDeclarationQuestion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isParent = _data["isParent"];
      this.question = _data["question"];
      this.answer = _data["answer"];
      this.yesNo = _data["yesNo"];
    }
  }

  static fromJS(data: any): ApplicationDeclarationQuestion {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationDeclarationQuestion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isParent"] = this.isParent;
    data["question"] = this.question;
    data["answer"] = this.answer;
    data["yesNo"] = this.yesNo;
    return data;
  }

  clone(): ApplicationDeclarationQuestion {
    const json = this.toJSON();
    let result = new ApplicationDeclarationQuestion();
    result.init(json);
    return result;
  }
}

export interface IApplicationDeclarationQuestion {
  isParent: boolean | undefined;
  question: string | undefined;
  answer: string | undefined;
  yesNo: boolean | undefined;
}

export class ApplicationDetail implements IApplicationDetail {
  date: moment.Moment;
  loanNoIdentifierB1B3: string | undefined;
  agencyCaseNoB2: string | undefined;
  creditType: string | undefined;
  totalBorrowers1a6: number | undefined;
  initials: string | undefined;

  constructor(data?: IApplicationDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data["date"]
        ? moment(_data["date"].toString())
        : <any>undefined;
      this.loanNoIdentifierB1B3 = _data["loanNoIdentifierB1B3"];
      this.agencyCaseNoB2 = _data["agencyCaseNoB2"];
      this.creditType = _data["creditType"];
      this.totalBorrowers1a6 = _data["totalBorrowers1a6"];
      this.initials = _data["initials"];
    }
  }

  static fromJS(data: any): ApplicationDetail {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["loanNoIdentifierB1B3"] = this.loanNoIdentifierB1B3;
    data["agencyCaseNoB2"] = this.agencyCaseNoB2;
    data["creditType"] = this.creditType;
    data["totalBorrowers1a6"] = this.totalBorrowers1a6;
    data["initials"] = this.initials;
    return data;
  }

  clone(): ApplicationDetail {
    const json = this.toJSON();
    let result = new ApplicationDetail();
    result.init(json);
    return result;
  }
}

export interface IApplicationDetail {
  date: moment.Moment;
  loanNoIdentifierB1B3: string | undefined;
  agencyCaseNoB2: string | undefined;
  creditType: string | undefined;
  totalBorrowers1a6: number | undefined;
  initials: string | undefined;
}

export class ApplicationEmployementDetail
  implements IApplicationEmployementDetail {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1b2: string | undefined;
  phone1b3: string | undefined;
  street1b41: string | undefined;
  unit1b42: string | undefined;
  zip1b45: string | undefined;
  country1b46: string | undefined;
  state1b44: string | undefined;
  city1b43: string | undefined;
  positionTitle1b5: string | undefined;
  startDate1b6: moment.Moment | undefined;
  workingYears1b7: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone1b8: number | undefined;
  isSelfEmployed1b9: number | undefined;
  isOwnershipLessThan251b91: number | undefined;
  monthlyIncome1b92: number | undefined;

  constructor(data?: IApplicationEmployementDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName1b2 = _data["employerBusinessName1b2"];
      this.phone1b3 = _data["phone1b3"];
      this.street1b41 = _data["street1b41"];
      this.unit1b42 = _data["unit1b42"];
      this.zip1b45 = _data["zip1b45"];
      this.country1b46 = _data["country1b46"];
      this.state1b44 = _data["state1b44"];
      this.city1b43 = _data["city1b43"];
      this.positionTitle1b5 = _data["positionTitle1b5"];
      this.startDate1b6 = _data["startDate1b6"]
        ? moment(_data["startDate1b6"].toString())
        : <any>undefined;
      this.workingYears1b7 = _data["workingYears1b7"];
      this.workingMonths = _data["workingMonths"];
      this.isEmployedBySomeone1b8 = _data["isEmployedBySomeone1b8"];
      this.isSelfEmployed1b9 = _data["isSelfEmployed1b9"];
      this.isOwnershipLessThan251b91 = _data["isOwnershipLessThan251b91"];
      this.monthlyIncome1b92 = _data["monthlyIncome1b92"];
    }
  }

  static fromJS(data: any): ApplicationEmployementDetail {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationEmployementDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName1b2"] = this.employerBusinessName1b2;
    data["phone1b3"] = this.phone1b3;
    data["street1b41"] = this.street1b41;
    data["unit1b42"] = this.unit1b42;
    data["zip1b45"] = this.zip1b45;
    data["country1b46"] = this.country1b46;
    data["state1b44"] = this.state1b44;
    data["city1b43"] = this.city1b43;
    data["positionTitle1b5"] = this.positionTitle1b5;
    data["startDate1b6"] = this.startDate1b6
      ? this.startDate1b6.toISOString()
      : <any>undefined;
    data["workingYears1b7"] = this.workingYears1b7;
    data["workingMonths"] = this.workingMonths;
    data["isEmployedBySomeone1b8"] = this.isEmployedBySomeone1b8;
    data["isSelfEmployed1b9"] = this.isSelfEmployed1b9;
    data["isOwnershipLessThan251b91"] = this.isOwnershipLessThan251b91;
    data["monthlyIncome1b92"] = this.monthlyIncome1b92;
    return data;
  }

  clone(): ApplicationEmployementDetail {
    const json = this.toJSON();
    let result = new ApplicationEmployementDetail();
    result.init(json);
    return result;
  }
}

export interface IApplicationEmployementDetail {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1b2: string | undefined;
  phone1b3: string | undefined;
  street1b41: string | undefined;
  unit1b42: string | undefined;
  zip1b45: string | undefined;
  country1b46: string | undefined;
  state1b44: string | undefined;
  city1b43: string | undefined;
  positionTitle1b5: string | undefined;
  startDate1b6: moment.Moment | undefined;
  workingYears1b7: number | undefined;
  workingMonths: number | undefined;
  isEmployedBySomeone1b8: number | undefined;
  isSelfEmployed1b9: number | undefined;
  isOwnershipLessThan251b91: number | undefined;
  monthlyIncome1b92: number | undefined;
}

export class ApplicationFinancialAsset implements IApplicationFinancialAsset {
  financialAccountType2a1: string | undefined;
  financialInstitution2a2: string | undefined;
  accountNumber2a3: string | undefined;
  value2a4: number | undefined;

  constructor(data?: IApplicationFinancialAsset) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialAccountType2a1 = _data["financialAccountType2a1"];
      this.financialInstitution2a2 = _data["financialInstitution2a2"];
      this.accountNumber2a3 = _data["accountNumber2a3"];
      this.value2a4 = _data["value2a4"];
    }
  }

  static fromJS(data: any): ApplicationFinancialAsset {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationFinancialAsset();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialAccountType2a1"] = this.financialAccountType2a1;
    data["financialInstitution2a2"] = this.financialInstitution2a2;
    data["accountNumber2a3"] = this.accountNumber2a3;
    data["value2a4"] = this.value2a4;
    return data;
  }

  clone(): ApplicationFinancialAsset {
    const json = this.toJSON();
    let result = new ApplicationFinancialAsset();
    result.init(json);
    return result;
  }
}

export interface IApplicationFinancialAsset {
  financialAccountType2a1: string | undefined;
  financialInstitution2a2: string | undefined;
  accountNumber2a3: string | undefined;
  value2a4: number | undefined;
}

export class ApplicationFinancialLiabilityDetail
  implements IApplicationFinancialLiabilityDetail {
  applicationPersonalInformationId: number | undefined;
  financialLaibilitiesType2c1: string | undefined;
  companyName2c2: string | undefined;
  accountNumber2c3: string | undefined;
  unpaidBalance2c4: number | undefined;
  paidOff2c5: number | undefined;
  monthlyValue2c6: number | undefined;

  constructor(data?: IApplicationFinancialLiabilityDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialLaibilitiesType2c1 = _data["financialLaibilitiesType2c1"];
      this.companyName2c2 = _data["companyName2c2"];
      this.accountNumber2c3 = _data["accountNumber2c3"];
      this.unpaidBalance2c4 = _data["unpaidBalance2c4"];
      this.paidOff2c5 = _data["paidOff2c5"];
      this.monthlyValue2c6 = _data["monthlyValue2c6"];
    }
  }

  static fromJS(data: any): ApplicationFinancialLiabilityDetail {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationFinancialLiabilityDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["financialLaibilitiesType2c1"] = this.financialLaibilitiesType2c1;
    data["companyName2c2"] = this.companyName2c2;
    data["accountNumber2c3"] = this.accountNumber2c3;
    data["unpaidBalance2c4"] = this.unpaidBalance2c4;
    data["paidOff2c5"] = this.paidOff2c5;
    data["monthlyValue2c6"] = this.monthlyValue2c6;
    return data;
  }

  clone(): ApplicationFinancialLiabilityDetail {
    const json = this.toJSON();
    let result = new ApplicationFinancialLiabilityDetail();
    result.init(json);
    return result;
  }
}

export interface IApplicationFinancialLiabilityDetail {
  applicationPersonalInformationId: number | undefined;
  financialLaibilitiesType2c1: string | undefined;
  companyName2c2: string | undefined;
  accountNumber2c3: string | undefined;
  unpaidBalance2c4: number | undefined;
  paidOff2c5: number | undefined;
  monthlyValue2c6: number | undefined;
}

export class ApplicationFinancialOtherAssetDetail
  implements IApplicationFinancialOtherAssetDetail {
  financialAssetsType2b1: string | undefined;
  applicationPersonalInformationId: number | undefined;
  value2b2: number | undefined;

  constructor(data?: IApplicationFinancialOtherAssetDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialAssetsType2b1 = _data["financialAssetsType2b1"];
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.value2b2 = _data["value2b2"];
    }
  }

  static fromJS(data: any): ApplicationFinancialOtherAssetDetail {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationFinancialOtherAssetDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialAssetsType2b1"] = this.financialAssetsType2b1;
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["value2b2"] = this.value2b2;
    return data;
  }

  clone(): ApplicationFinancialOtherAssetDetail {
    const json = this.toJSON();
    let result = new ApplicationFinancialOtherAssetDetail();
    result.init(json);
    return result;
  }
}

export interface IApplicationFinancialOtherAssetDetail {
  financialAssetsType2b1: string | undefined;
  applicationPersonalInformationId: number | undefined;
  value2b2: number | undefined;
}

export class ApplicationFinancialOtherLaibilityDetail
  implements IApplicationFinancialOtherLaibilityDetail {
  applicationPersonalInformationId: number | undefined;
  financialOtherLaibilityType2d1: string | undefined;
  monthlyPayment2d2: number | undefined;

  constructor(data?: IApplicationFinancialOtherLaibilityDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.financialOtherLaibilityType2d1 =
        _data["financialOtherLaibilityType2d1"];
      this.monthlyPayment2d2 = _data["monthlyPayment2d2"];
    }
  }

  static fromJS(data: any): ApplicationFinancialOtherLaibilityDetail {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationFinancialOtherLaibilityDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data[
      "financialOtherLaibilityType2d1"
    ] = this.financialOtherLaibilityType2d1;
    data["monthlyPayment2d2"] = this.monthlyPayment2d2;
    return data;
  }

  clone(): ApplicationFinancialOtherLaibilityDetail {
    const json = this.toJSON();
    let result = new ApplicationFinancialOtherLaibilityDetail();
    result.init(json);
    return result;
  }
}

export interface IApplicationFinancialOtherLaibilityDetail {
  applicationPersonalInformationId: number | undefined;
  financialOtherLaibilityType2d1: string | undefined;
  monthlyPayment2d2: number | undefined;
}

export class ApplicationIncomeSourceDetail
  implements IApplicationIncomeSourceDetail {
  applicationPersonalInformationId: number | undefined;
  incomeSource1e1: string | undefined;
  amount1e2: number | undefined;

  constructor(data?: IApplicationIncomeSourceDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.incomeSource1e1 = _data["incomeSource1e1"];
      this.amount1e2 = _data["amount1e2"];
    }
  }

  static fromJS(data: any): ApplicationIncomeSourceDetail {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationIncomeSourceDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["incomeSource1e1"] = this.incomeSource1e1;
    data["amount1e2"] = this.amount1e2;
    return data;
  }

  clone(): ApplicationIncomeSourceDetail {
    const json = this.toJSON();
    let result = new ApplicationIncomeSourceDetail();
    result.init(json);
    return result;
  }
}

export interface IApplicationIncomeSourceDetail {
  applicationPersonalInformationId: number | undefined;
  incomeSource1e1: string | undefined;
  amount1e2: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;

  constructor(data?: IApplicationInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data["version"];
      this.releaseDate = _data["releaseDate"]
        ? moment(_data["releaseDate"].toString())
        : <any>undefined;
      if (_data["features"]) {
        this.features = {} as any;
        for (let key in _data["features"]) {
          if (_data["features"].hasOwnProperty(key))
            (<any>this.features)[key] = _data["features"][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["version"] = this.version;
    data["releaseDate"] = this.releaseDate
      ? this.releaseDate.toISOString()
      : <any>undefined;
    if (this.features) {
      data["features"] = {};
      for (let key in this.features) {
        if (this.features.hasOwnProperty(key))
          (<any>data["features"])[key] = this.features[key];
      }
    }
    return data;
  }

  clone(): ApplicationInfoDto {
    const json = this.toJSON();
    let result = new ApplicationInfoDto();
    result.init(json);
    return result;
  }
}

export interface IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;
}

export class Assembly implements IAssembly {
  readonly definedTypes: TypeInfo[] | undefined;
  readonly exportedTypes: Type[] | undefined;
  readonly codeBase: string | undefined;
  entryPoint: MethodInfo;
  readonly fullName: string | undefined;
  readonly imageRuntimeVersion: string | undefined;
  readonly isDynamic: boolean;
  readonly location: string | undefined;
  readonly reflectionOnly: boolean;
  readonly isCollectible: boolean;
  readonly isFullyTrusted: boolean;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly escapedCodeBase: string | undefined;
  manifestModule: Module;
  readonly modules: Module[] | undefined;
  readonly globalAssemblyCache: boolean;
  readonly hostContext: number;
  securityRuleSet: SecurityRuleSet;

  constructor(data?: IAssembly) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["definedTypes"])) {
        (<any>this).definedTypes = [] as any;
        for (let item of _data["definedTypes"])
          (<any>this).definedTypes.push(TypeInfo.fromJS(item));
      }
      if (Array.isArray(_data["exportedTypes"])) {
        (<any>this).exportedTypes = [] as any;
        for (let item of _data["exportedTypes"])
          (<any>this).exportedTypes.push(Type.fromJS(item));
      }
      (<any>this).codeBase = _data["codeBase"];
      this.entryPoint = _data["entryPoint"]
        ? MethodInfo.fromJS(_data["entryPoint"])
        : <any>undefined;
      (<any>this).fullName = _data["fullName"];
      (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
      (<any>this).isDynamic = _data["isDynamic"];
      (<any>this).location = _data["location"];
      (<any>this).reflectionOnly = _data["reflectionOnly"];
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).isFullyTrusted = _data["isFullyTrusted"];
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).escapedCodeBase = _data["escapedCodeBase"];
      this.manifestModule = _data["manifestModule"]
        ? Module.fromJS(_data["manifestModule"])
        : <any>undefined;
      if (Array.isArray(_data["modules"])) {
        (<any>this).modules = [] as any;
        for (let item of _data["modules"])
          (<any>this).modules.push(Module.fromJS(item));
      }
      (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
      (<any>this).hostContext = _data["hostContext"];
      this.securityRuleSet = _data["securityRuleSet"];
    }
  }

  static fromJS(data: any): Assembly {
    data = typeof data === "object" ? data : {};
    let result = new Assembly();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.definedTypes)) {
      data["definedTypes"] = [];
      for (let item of this.definedTypes)
        data["definedTypes"].push(item.toJSON());
    }
    if (Array.isArray(this.exportedTypes)) {
      data["exportedTypes"] = [];
      for (let item of this.exportedTypes)
        data["exportedTypes"].push(item.toJSON());
    }
    data["codeBase"] = this.codeBase;
    data["entryPoint"] = this.entryPoint
      ? this.entryPoint.toJSON()
      : <any>undefined;
    data["fullName"] = this.fullName;
    data["imageRuntimeVersion"] = this.imageRuntimeVersion;
    data["isDynamic"] = this.isDynamic;
    data["location"] = this.location;
    data["reflectionOnly"] = this.reflectionOnly;
    data["isCollectible"] = this.isCollectible;
    data["isFullyTrusted"] = this.isFullyTrusted;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["escapedCodeBase"] = this.escapedCodeBase;
    data["manifestModule"] = this.manifestModule
      ? this.manifestModule.toJSON()
      : <any>undefined;
    if (Array.isArray(this.modules)) {
      data["modules"] = [];
      for (let item of this.modules) data["modules"].push(item.toJSON());
    }
    data["globalAssemblyCache"] = this.globalAssemblyCache;
    data["hostContext"] = this.hostContext;
    data["securityRuleSet"] = this.securityRuleSet;
    return data;
  }

  clone(): Assembly {
    const json = this.toJSON();
    let result = new Assembly();
    result.init(json);
    return result;
  }
}

export interface IAssembly {
  definedTypes: TypeInfo[] | undefined;
  exportedTypes: Type[] | undefined;
  codeBase: string | undefined;
  entryPoint: MethodInfo;
  fullName: string | undefined;
  imageRuntimeVersion: string | undefined;
  isDynamic: boolean;
  location: string | undefined;
  reflectionOnly: boolean;
  isCollectible: boolean;
  isFullyTrusted: boolean;
  customAttributes: CustomAttributeData[] | undefined;
  escapedCodeBase: string | undefined;
  manifestModule: Module;
  modules: Module[] | undefined;
  globalAssemblyCache: boolean;
  hostContext: number;
  securityRuleSet: SecurityRuleSet;
}

export class Assettype implements IAssettype {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  name: string | undefined;
  manualassetentries: Manualassetentry[] | undefined;

  constructor(data?: IAssettype) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.name = _data["name"];
      if (Array.isArray(_data["manualassetentries"])) {
        this.manualassetentries = [] as any;
        for (let item of _data["manualassetentries"])
          this.manualassetentries.push(Manualassetentry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Assettype {
    data = typeof data === "object" ? data : {};
    let result = new Assettype();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["name"] = this.name;
    if (Array.isArray(this.manualassetentries)) {
      data["manualassetentries"] = [];
      for (let item of this.manualassetentries)
        data["manualassetentries"].push(item.toJSON());
    }
    return data;
  }

  clone(): Assettype {
    const json = this.toJSON();
    let result = new Assettype();
    result.init(json);
    return result;
  }
}

export interface IAssettype {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  name: string | undefined;
  manualassetentries: Manualassetentry[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;

  constructor(data?: IAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
      this.password = _data["password"];
      this.rememberClient = _data["rememberClient"];
    }
  }

  static fromJS(data: any): AuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
    data["password"] = this.password;
    data["rememberClient"] = this.rememberClient;
    return data;
  }

  clone(): AuthenticateModel {
    const json = this.toJSON();
    let result = new AuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;

  constructor(data?: IAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): AuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["userId"] = this.userId;
    return data;
  }

  clone(): AuthenticateResultModel {
    const json = this.toJSON();
    let result = new AuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;
}

export class Borrower implements IBorrower {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  borrowerTypeId: number;
  borrowerType: Borrowertype;

  constructor(data?: IBorrower) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.firstName = _data["firstName"];
      this.middleInitial = _data["middleInitial"];
      this.lastName = _data["lastName"];
      this.suffix = _data["suffix"];
      this.email = _data["email"];
      this.dateOfBirth = _data["dateOfBirth"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.maritalStatusId = _data["maritalStatusId"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.cellPhone = _data["cellPhone"];
      this.homePhone = _data["homePhone"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Borrower {
    data = typeof data === "object" ? data : {};
    let result = new Borrower();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["firstName"] = this.firstName;
    data["middleInitial"] = this.middleInitial;
    data["lastName"] = this.lastName;
    data["suffix"] = this.suffix;
    data["email"] = this.email;
    data["dateOfBirth"] = this.dateOfBirth;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["maritalStatusId"] = this.maritalStatusId;
    data["numberOfDependents"] = this.numberOfDependents;
    data["cellPhone"] = this.cellPhone;
    data["homePhone"] = this.homePhone;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Borrower {
    const json = this.toJSON();
    let result = new Borrower();
    result.init(json);
    return result;
  }
}

export interface IBorrower {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  borrowerTypeId: number;
  borrowerType: Borrowertype;
}

export class BorrowerDto implements IBorrowerDto {
  id: number | undefined;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  personalDetailId: number | undefined;
  borrowerTypeId: number;

  constructor(data?: IBorrowerDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.firstName = _data["firstName"];
      this.middleInitial = _data["middleInitial"];
      this.lastName = _data["lastName"];
      this.suffix = _data["suffix"];
      this.email = _data["email"];
      this.dateOfBirth = _data["dateOfBirth"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.maritalStatusId = _data["maritalStatusId"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.cellPhone = _data["cellPhone"];
      this.homePhone = _data["homePhone"];
      this.personalDetailId = _data["personalDetailId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
    }
  }

  static fromJS(data: any): BorrowerDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["firstName"] = this.firstName;
    data["middleInitial"] = this.middleInitial;
    data["lastName"] = this.lastName;
    data["suffix"] = this.suffix;
    data["email"] = this.email;
    data["dateOfBirth"] = this.dateOfBirth;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["maritalStatusId"] = this.maritalStatusId;
    data["numberOfDependents"] = this.numberOfDependents;
    data["cellPhone"] = this.cellPhone;
    data["homePhone"] = this.homePhone;
    data["personalDetailId"] = this.personalDetailId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    return data;
  }

  clone(): BorrowerDto {
    const json = this.toJSON();
    let result = new BorrowerDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerDto {
  id: number | undefined;
  firstName: string | undefined;
  middleInitial: string | undefined;
  lastName: string | undefined;
  suffix: string | undefined;
  email: string | undefined;
  dateOfBirth: string | undefined;
  socialSecurityNumber: string | undefined;
  maritalStatusId: number | undefined;
  numberOfDependents: number | undefined;
  cellPhone: string | undefined;
  homePhone: string | undefined;
  personalDetailId: number | undefined;
  borrowerTypeId: number;
}

export class BorrowerEmploymentInformationDto
  implements IBorrowerEmploymentInformationDto {
  id: number | undefined;
  employerName: string | undefined;
  address1: string | undefined;
  address2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;

  constructor(data?: IBorrowerEmploymentInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.employerName = _data["employerName"];
      this.address1 = _data["address1"];
      this.address2 = _data["address2"];
      this.isSelfEmployed = _data["isSelfEmployed"];
      this.position = _data["position"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.startDate = _data["startDate"]
        ? moment(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? moment(_data["endDate"].toString())
        : <any>undefined;
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): BorrowerEmploymentInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerEmploymentInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["employerName"] = this.employerName;
    data["address1"] = this.address1;
    data["address2"] = this.address2;
    data["isSelfEmployed"] = this.isSelfEmployed;
    data["position"] = this.position;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): BorrowerEmploymentInformationDto {
    const json = this.toJSON();
    let result = new BorrowerEmploymentInformationDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerEmploymentInformationDto {
  id: number | undefined;
  employerName: string | undefined;
  address1: string | undefined;
  address2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;
}

export class BorrowerEmploymentInformationDtoPagedResultDto
  implements IBorrowerEmploymentInformationDtoPagedResultDto {
  items: BorrowerEmploymentInformationDto[] | undefined;
  totalCount: number;

  constructor(data?: IBorrowerEmploymentInformationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BorrowerEmploymentInformationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BorrowerEmploymentInformationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerEmploymentInformationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BorrowerEmploymentInformationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BorrowerEmploymentInformationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerEmploymentInformationDtoPagedResultDto {
  items: BorrowerEmploymentInformationDto[] | undefined;
  totalCount: number;
}

export class BorrowerMonthlyIncomeDto implements IBorrowerMonthlyIncomeDto {
  id: number | undefined;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;

  constructor(data?: IBorrowerMonthlyIncomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.base = _data["base"];
      this.overtime = _data["overtime"];
      this.bonuses = _data["bonuses"];
      this.commissions = _data["commissions"];
      this.dividends = _data["dividends"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
    }
  }

  static fromJS(data: any): BorrowerMonthlyIncomeDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerMonthlyIncomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["base"] = this.base;
    data["overtime"] = this.overtime;
    data["bonuses"] = this.bonuses;
    data["commissions"] = this.commissions;
    data["dividends"] = this.dividends;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    return data;
  }

  clone(): BorrowerMonthlyIncomeDto {
    const json = this.toJSON();
    let result = new BorrowerMonthlyIncomeDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerMonthlyIncomeDto {
  id: number | undefined;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerTypeId: number;
  loanApplicationId: number | undefined;
}

export class BorrowerMonthlyIncomeDtoPagedResultDto
  implements IBorrowerMonthlyIncomeDtoPagedResultDto {
  items: BorrowerMonthlyIncomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IBorrowerMonthlyIncomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BorrowerMonthlyIncomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BorrowerMonthlyIncomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BorrowerMonthlyIncomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BorrowerMonthlyIncomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BorrowerMonthlyIncomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBorrowerMonthlyIncomeDtoPagedResultDto {
  items: BorrowerMonthlyIncomeDto[] | undefined;
  totalCount: number;
}

export class Borroweremploymentinformation
  implements IBorroweremploymentinformation {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  employersName: string | undefined;
  employersAddress1: string | undefined;
  employersAddress2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;

  constructor(data?: IBorroweremploymentinformation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.employersName = _data["employersName"];
      this.employersAddress1 = _data["employersAddress1"];
      this.employersAddress2 = _data["employersAddress2"];
      this.isSelfEmployed = _data["isSelfEmployed"];
      this.position = _data["position"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.startDate = _data["startDate"]
        ? moment(_data["startDate"].toString())
        : <any>undefined;
      this.endDate = _data["endDate"]
        ? moment(_data["endDate"].toString())
        : <any>undefined;
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? Loanapplication.fromJS(_data["loanApplication"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Borroweremploymentinformation {
    data = typeof data === "object" ? data : {};
    let result = new Borroweremploymentinformation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["employersName"] = this.employersName;
    data["employersAddress1"] = this.employersAddress1;
    data["employersAddress2"] = this.employersAddress2;
    data["isSelfEmployed"] = this.isSelfEmployed;
    data["position"] = this.position;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["startDate"] = this.startDate
      ? this.startDate.toISOString()
      : <any>undefined;
    data["endDate"] = this.endDate
      ? this.endDate.toISOString()
      : <any>undefined;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Borroweremploymentinformation {
    const json = this.toJSON();
    let result = new Borroweremploymentinformation();
    result.init(json);
    return result;
  }
}

export interface IBorroweremploymentinformation {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  employersName: string | undefined;
  employersAddress1: string | undefined;
  employersAddress2: string | undefined;
  isSelfEmployed: boolean | undefined;
  position: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: number | undefined;
  startDate: moment.Moment | undefined;
  endDate: moment.Moment | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;
}

export class Borrowermonthlyincome implements IBorrowermonthlyincome {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;

  constructor(data?: IBorrowermonthlyincome) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.base = _data["base"];
      this.overtime = _data["overtime"];
      this.bonuses = _data["bonuses"];
      this.commissions = _data["commissions"];
      this.dividends = _data["dividends"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? Loanapplication.fromJS(_data["loanApplication"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Borrowermonthlyincome {
    data = typeof data === "object" ? data : {};
    let result = new Borrowermonthlyincome();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["base"] = this.base;
    data["overtime"] = this.overtime;
    data["bonuses"] = this.bonuses;
    data["commissions"] = this.commissions;
    data["dividends"] = this.dividends;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Borrowermonthlyincome {
    const json = this.toJSON();
    let result = new Borrowermonthlyincome();
    result.init(json);
    return result;
  }
}

export interface IBorrowermonthlyincome {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  base: number | undefined;
  overtime: number | undefined;
  bonuses: number | undefined;
  commissions: number | undefined;
  dividends: number | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;
}

export class Borrowertype implements IBorrowertype {
  id: number;
  name: string | undefined;
  additionalincomes: Additionalincome[] | undefined;
  addresses: Address[] | undefined;
  borroweremploymentinformations: Borroweremploymentinformation[] | undefined;
  borrowermonthlyincomes: Borrowermonthlyincome[] | undefined;
  borrowers: Borrower[] | undefined;
  declarationborroweredemographicsinformations:
    | Declarationborroweredemographicsinformation[]
    | undefined;
  declarations: Declaration[] | undefined;
  manualassetentries: Manualassetentry[] | undefined;

  constructor(data?: IBorrowertype) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["additionalincomes"])) {
        this.additionalincomes = [] as any;
        for (let item of _data["additionalincomes"])
          this.additionalincomes.push(Additionalincome.fromJS(item));
      }
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses.push(Address.fromJS(item));
      }
      if (Array.isArray(_data["borroweremploymentinformations"])) {
        this.borroweremploymentinformations = [] as any;
        for (let item of _data["borroweremploymentinformations"])
          this.borroweremploymentinformations.push(
            Borroweremploymentinformation.fromJS(item)
          );
      }
      if (Array.isArray(_data["borrowermonthlyincomes"])) {
        this.borrowermonthlyincomes = [] as any;
        for (let item of _data["borrowermonthlyincomes"])
          this.borrowermonthlyincomes.push(Borrowermonthlyincome.fromJS(item));
      }
      if (Array.isArray(_data["borrowers"])) {
        this.borrowers = [] as any;
        for (let item of _data["borrowers"])
          this.borrowers.push(Borrower.fromJS(item));
      }
      if (
        Array.isArray(_data["declarationborroweredemographicsinformations"])
      ) {
        this.declarationborroweredemographicsinformations = [] as any;
        for (let item of _data["declarationborroweredemographicsinformations"])
          this.declarationborroweredemographicsinformations.push(
            Declarationborroweredemographicsinformation.fromJS(item)
          );
      }
      if (Array.isArray(_data["declarations"])) {
        this.declarations = [] as any;
        for (let item of _data["declarations"])
          this.declarations.push(Declaration.fromJS(item));
      }
      if (Array.isArray(_data["manualassetentries"])) {
        this.manualassetentries = [] as any;
        for (let item of _data["manualassetentries"])
          this.manualassetentries.push(Manualassetentry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Borrowertype {
    data = typeof data === "object" ? data : {};
    let result = new Borrowertype();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.additionalincomes)) {
      data["additionalincomes"] = [];
      for (let item of this.additionalincomes)
        data["additionalincomes"].push(item.toJSON());
    }
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.borroweremploymentinformations)) {
      data["borroweremploymentinformations"] = [];
      for (let item of this.borroweremploymentinformations)
        data["borroweremploymentinformations"].push(item.toJSON());
    }
    if (Array.isArray(this.borrowermonthlyincomes)) {
      data["borrowermonthlyincomes"] = [];
      for (let item of this.borrowermonthlyincomes)
        data["borrowermonthlyincomes"].push(item.toJSON());
    }
    if (Array.isArray(this.borrowers)) {
      data["borrowers"] = [];
      for (let item of this.borrowers) data["borrowers"].push(item.toJSON());
    }
    if (Array.isArray(this.declarationborroweredemographicsinformations)) {
      data["declarationborroweredemographicsinformations"] = [];
      for (let item of this.declarationborroweredemographicsinformations)
        data["declarationborroweredemographicsinformations"].push(
          item.toJSON()
        );
    }
    if (Array.isArray(this.declarations)) {
      data["declarations"] = [];
      for (let item of this.declarations)
        data["declarations"].push(item.toJSON());
    }
    if (Array.isArray(this.manualassetentries)) {
      data["manualassetentries"] = [];
      for (let item of this.manualassetentries)
        data["manualassetentries"].push(item.toJSON());
    }
    return data;
  }

  clone(): Borrowertype {
    const json = this.toJSON();
    let result = new Borrowertype();
    result.init(json);
    return result;
  }
}

export interface IBorrowertype {
  id: number;
  name: string | undefined;
  additionalincomes: Additionalincome[] | undefined;
  addresses: Address[] | undefined;
  borroweremploymentinformations: Borroweremploymentinformation[] | undefined;
  borrowermonthlyincomes: Borrowermonthlyincome[] | undefined;
  borrowers: Borrower[] | undefined;
  declarationborroweredemographicsinformations:
    | Declarationborroweredemographicsinformation[]
    | undefined;
  declarations: Declaration[] | undefined;
  manualassetentries: Manualassetentry[] | undefined;
}

export class BuyingHomeDto implements IBuyingHomeDto {
  id: number | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  firstTimeHomeBuying: boolean;
  planToPurchase: string | undefined;
  propertyLocated: string | undefined;
  purchasePrice: string | undefined;
  downPayment: number;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  militarySevice: boolean;
  bankruptcyPastThreeYears: boolean;
  foreclosurePastTwoYears: boolean;
  lateMortgagePayments: string | undefined;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;

  constructor(data?: IBuyingHomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.propertyType = _data["propertyType"];
      this.propertyUse = _data["propertyUse"];
      this.firstTimeHomeBuying = _data["firstTimeHomeBuying"];
      this.planToPurchase = _data["planToPurchase"];
      this.propertyLocated = _data["propertyLocated"];
      this.purchasePrice = _data["purchasePrice"];
      this.downPayment = _data["downPayment"];
      this.currentEmployed = _data["currentEmployed"];
      this.houseHoldIncome = _data["houseHoldIncome"];
      this.proofOfincome = _data["proofOfincome"];
      this.militarySevice = _data["militarySevice"];
      this.bankruptcyPastThreeYears = _data["bankruptcyPastThreeYears"];
      this.foreclosurePastTwoYears = _data["foreclosurePastTwoYears"];
      this.lateMortgagePayments = _data["lateMortgagePayments"];
      this.rateCredit = _data["rateCredit"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.emailAddress = _data["emailAddress"];
      this.phoneNumber = _data["phoneNumber"];
      this.refferedBy = _data["refferedBy"];
    }
  }

  static fromJS(data: any): BuyingHomeDto {
    data = typeof data === "object" ? data : {};
    let result = new BuyingHomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["propertyType"] = this.propertyType;
    data["propertyUse"] = this.propertyUse;
    data["firstTimeHomeBuying"] = this.firstTimeHomeBuying;
    data["planToPurchase"] = this.planToPurchase;
    data["propertyLocated"] = this.propertyLocated;
    data["purchasePrice"] = this.purchasePrice;
    data["downPayment"] = this.downPayment;
    data["currentEmployed"] = this.currentEmployed;
    data["houseHoldIncome"] = this.houseHoldIncome;
    data["proofOfincome"] = this.proofOfincome;
    data["militarySevice"] = this.militarySevice;
    data["bankruptcyPastThreeYears"] = this.bankruptcyPastThreeYears;
    data["foreclosurePastTwoYears"] = this.foreclosurePastTwoYears;
    data["lateMortgagePayments"] = this.lateMortgagePayments;
    data["rateCredit"] = this.rateCredit;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["emailAddress"] = this.emailAddress;
    data["phoneNumber"] = this.phoneNumber;
    data["refferedBy"] = this.refferedBy;
    return data;
  }

  clone(): BuyingHomeDto {
    const json = this.toJSON();
    let result = new BuyingHomeDto();
    result.init(json);
    return result;
  }
}

export interface IBuyingHomeDto {
  id: number | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  firstTimeHomeBuying: boolean;
  planToPurchase: string | undefined;
  propertyLocated: string | undefined;
  purchasePrice: string | undefined;
  downPayment: number;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  militarySevice: boolean;
  bankruptcyPastThreeYears: boolean;
  foreclosurePastTwoYears: boolean;
  lateMortgagePayments: string | undefined;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;
}

export class BuyingHomeDtoPagedResultDto
  implements IBuyingHomeDtoPagedResultDto {
  items: BuyingHomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IBuyingHomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(BuyingHomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): BuyingHomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new BuyingHomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): BuyingHomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new BuyingHomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IBuyingHomeDtoPagedResultDto {
  items: BuyingHomeDto[] | undefined;
  totalCount: number;
}

export enum CallingConventions {
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _32 = 32,
  _64 = 64,
}

export class ChangePasswordDto implements IChangePasswordDto {
  currentPassword: string;
  newPassword: string;

  constructor(data?: IChangePasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data["currentPassword"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangePasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currentPassword"] = this.currentPassword;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ChangePasswordDto {
    const json = this.toJSON();
    let result = new ChangePasswordDto();
    result.init(json);
    return result;
  }
}

export interface IChangePasswordDto {
  currentPassword: string;
  newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
  theme: string;

  constructor(data?: IChangeUiThemeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.theme = _data["theme"];
    }
  }

  static fromJS(data: any): ChangeUiThemeInput {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUiThemeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["theme"] = this.theme;
    return data;
  }

  clone(): ChangeUiThemeInput {
    const json = this.toJSON();
    let result = new ChangeUiThemeInput();
    result.init(json);
    return result;
  }
}

export interface IChangeUiThemeInput {
  theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
  languageName: string;

  constructor(data?: IChangeUserLanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageName = _data["languageName"];
    }
  }

  static fromJS(data: any): ChangeUserLanguageDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUserLanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["languageName"] = this.languageName;
    return data;
  }

  clone(): ChangeUserLanguageDto {
    const json = this.toJSON();
    let result = new ChangeUserLanguageDto();
    result.init(json);
    return result;
  }
}

export interface IChangeUserLanguageDto {
  languageName: string;
}

export class Consentdetail implements IConsentdetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  agreeEconsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEconsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;
  loanapplications: Loanapplication[] | undefined;

  constructor(data?: IConsentdetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.agreeEconsent = _data["agreeEconsent"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.email = _data["email"];
      this.coborrowerAgreeEconsent = _data["coborrowerAgreeEconsent"];
      this.coborrowerFirstName = _data["coborrowerFirstName"];
      this.coborrowerLastName = _data["coborrowerLastName"];
      this.coborrowerEmail = _data["coborrowerEmail"];
      if (Array.isArray(_data["loanapplications"])) {
        this.loanapplications = [] as any;
        for (let item of _data["loanapplications"])
          this.loanapplications.push(Loanapplication.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Consentdetail {
    data = typeof data === "object" ? data : {};
    let result = new Consentdetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["agreeEconsent"] = this.agreeEconsent;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["email"] = this.email;
    data["coborrowerAgreeEconsent"] = this.coborrowerAgreeEconsent;
    data["coborrowerFirstName"] = this.coborrowerFirstName;
    data["coborrowerLastName"] = this.coborrowerLastName;
    data["coborrowerEmail"] = this.coborrowerEmail;
    if (Array.isArray(this.loanapplications)) {
      data["loanapplications"] = [];
      for (let item of this.loanapplications)
        data["loanapplications"].push(item.toJSON());
    }
    return data;
  }

  clone(): Consentdetail {
    const json = this.toJSON();
    let result = new Consentdetail();
    result.init(json);
    return result;
  }
}

export interface IConsentdetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  agreeEconsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEconsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;
  loanapplications: Loanapplication[] | undefined;
}

export class ConstructorInfo implements IConstructorInfo {
  readonly name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  attributes: MethodAttributes;
  methodImplementationFlags: MethodImplAttributes;
  callingConvention: CallingConventions;
  readonly isAbstract: boolean;
  readonly isConstructor: boolean;
  readonly isFinal: boolean;
  readonly isHideBySig: boolean;
  readonly isSpecialName: boolean;
  readonly isStatic: boolean;
  readonly isVirtual: boolean;
  readonly isAssembly: boolean;
  readonly isFamily: boolean;
  readonly isFamilyAndAssembly: boolean;
  readonly isFamilyOrAssembly: boolean;
  readonly isPrivate: boolean;
  readonly isPublic: boolean;
  readonly isConstructedGenericMethod: boolean;
  readonly isGenericMethod: boolean;
  readonly isGenericMethodDefinition: boolean;
  readonly containsGenericParameters: boolean;
  methodHandle: RuntimeMethodHandle;
  readonly isSecurityCritical: boolean;
  readonly isSecuritySafeCritical: boolean;
  readonly isSecurityTransparent: boolean;
  memberType: MemberTypes;

  constructor(data?: IConstructorInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data["name"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      this.attributes = _data["attributes"];
      this.methodImplementationFlags = _data["methodImplementationFlags"];
      this.callingConvention = _data["callingConvention"];
      (<any>this).isAbstract = _data["isAbstract"];
      (<any>this).isConstructor = _data["isConstructor"];
      (<any>this).isFinal = _data["isFinal"];
      (<any>this).isHideBySig = _data["isHideBySig"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      (<any>this).isStatic = _data["isStatic"];
      (<any>this).isVirtual = _data["isVirtual"];
      (<any>this).isAssembly = _data["isAssembly"];
      (<any>this).isFamily = _data["isFamily"];
      (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
      (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
      (<any>this).isPrivate = _data["isPrivate"];
      (<any>this).isPublic = _data["isPublic"];
      (<any>this).isConstructedGenericMethod =
        _data["isConstructedGenericMethod"];
      (<any>this).isGenericMethod = _data["isGenericMethod"];
      (<any>this).isGenericMethodDefinition =
        _data["isGenericMethodDefinition"];
      (<any>this).containsGenericParameters =
        _data["containsGenericParameters"];
      this.methodHandle = _data["methodHandle"]
        ? RuntimeMethodHandle.fromJS(_data["methodHandle"])
        : <any>undefined;
      (<any>this).isSecurityCritical = _data["isSecurityCritical"];
      (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
      (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
      this.memberType = _data["memberType"];
    }
  }

  static fromJS(data: any): ConstructorInfo {
    data = typeof data === "object" ? data : {};
    let result = new ConstructorInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["attributes"] = this.attributes;
    data["methodImplementationFlags"] = this.methodImplementationFlags;
    data["callingConvention"] = this.callingConvention;
    data["isAbstract"] = this.isAbstract;
    data["isConstructor"] = this.isConstructor;
    data["isFinal"] = this.isFinal;
    data["isHideBySig"] = this.isHideBySig;
    data["isSpecialName"] = this.isSpecialName;
    data["isStatic"] = this.isStatic;
    data["isVirtual"] = this.isVirtual;
    data["isAssembly"] = this.isAssembly;
    data["isFamily"] = this.isFamily;
    data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
    data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
    data["isPrivate"] = this.isPrivate;
    data["isPublic"] = this.isPublic;
    data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
    data["isGenericMethod"] = this.isGenericMethod;
    data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
    data["containsGenericParameters"] = this.containsGenericParameters;
    data["methodHandle"] = this.methodHandle
      ? this.methodHandle.toJSON()
      : <any>undefined;
    data["isSecurityCritical"] = this.isSecurityCritical;
    data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
    data["isSecurityTransparent"] = this.isSecurityTransparent;
    data["memberType"] = this.memberType;
    return data;
  }

  clone(): ConstructorInfo {
    const json = this.toJSON();
    let result = new ConstructorInfo();
    result.init(json);
    return result;
  }
}

export interface IConstructorInfo {
  name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  attributes: MethodAttributes;
  methodImplementationFlags: MethodImplAttributes;
  callingConvention: CallingConventions;
  isAbstract: boolean;
  isConstructor: boolean;
  isFinal: boolean;
  isHideBySig: boolean;
  isSpecialName: boolean;
  isStatic: boolean;
  isVirtual: boolean;
  isAssembly: boolean;
  isFamily: boolean;
  isFamilyAndAssembly: boolean;
  isFamilyOrAssembly: boolean;
  isPrivate: boolean;
  isPublic: boolean;
  isConstructedGenericMethod: boolean;
  isGenericMethod: boolean;
  isGenericMethodDefinition: boolean;
  containsGenericParameters: boolean;
  methodHandle: RuntimeMethodHandle;
  isSecurityCritical: boolean;
  isSecuritySafeCritical: boolean;
  isSecurityTransparent: boolean;
  memberType: MemberTypes;
}

export class CreateRoleDto implements ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: ICreateRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoleDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): CreateRoleDto {
    const json = this.toJSON();
    let result = new CreateRoleDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;

  constructor(data?: ICreateTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.adminEmailAddress = _data["adminEmailAddress"];
      this.connectionString = _data["connectionString"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): CreateTenantDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["adminEmailAddress"] = this.adminEmailAddress;
    data["connectionString"] = this.connectionString;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): CreateTenantDto {
    const json = this.toJSON();
    let result = new CreateTenantDto();
    result.init(json);
    return result;
  }
}

export interface ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): CreateUserDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    data["password"] = this.password;
    return data;
  }

  clone(): CreateUserDto {
    const json = this.toJSON();
    let result = new CreateUserDto();
    result.init(json);
    return result;
  }
}

export interface ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;
}

export class CreditAuthAgreementDto implements ICreditAuthAgreementDto {
  id: number | undefined;
  agreeCreditAuthAgreement: boolean | undefined;

  constructor(data?: ICreditAuthAgreementDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.agreeCreditAuthAgreement = _data["agreeCreditAuthAgreement"];
    }
  }

  static fromJS(data: any): CreditAuthAgreementDto {
    data = typeof data === "object" ? data : {};
    let result = new CreditAuthAgreementDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["agreeCreditAuthAgreement"] = this.agreeCreditAuthAgreement;
    return data;
  }

  clone(): CreditAuthAgreementDto {
    const json = this.toJSON();
    let result = new CreditAuthAgreementDto();
    result.init(json);
    return result;
  }
}

export interface ICreditAuthAgreementDto {
  id: number | undefined;
  agreeCreditAuthAgreement: boolean | undefined;
}

export class CreditAuthAgreementDtoPagedResultDto
  implements ICreditAuthAgreementDtoPagedResultDto {
  items: CreditAuthAgreementDto[] | undefined;
  totalCount: number;

  constructor(data?: ICreditAuthAgreementDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(CreditAuthAgreementDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): CreditAuthAgreementDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new CreditAuthAgreementDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): CreditAuthAgreementDtoPagedResultDto {
    const json = this.toJSON();
    let result = new CreditAuthAgreementDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ICreditAuthAgreementDtoPagedResultDto {
  items: CreditAuthAgreementDto[] | undefined;
  totalCount: number;
}

export class Creditauthagreement implements ICreditauthagreement {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  agreeCreditAuthAgreement: boolean | undefined;
  loanapplications: Loanapplication[] | undefined;

  constructor(data?: ICreditauthagreement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.agreeCreditAuthAgreement = _data["agreeCreditAuthAgreement"];
      if (Array.isArray(_data["loanapplications"])) {
        this.loanapplications = [] as any;
        for (let item of _data["loanapplications"])
          this.loanapplications.push(Loanapplication.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Creditauthagreement {
    data = typeof data === "object" ? data : {};
    let result = new Creditauthagreement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["agreeCreditAuthAgreement"] = this.agreeCreditAuthAgreement;
    if (Array.isArray(this.loanapplications)) {
      data["loanapplications"] = [];
      for (let item of this.loanapplications)
        data["loanapplications"].push(item.toJSON());
    }
    return data;
  }

  clone(): Creditauthagreement {
    const json = this.toJSON();
    let result = new Creditauthagreement();
    result.init(json);
    return result;
  }
}

export interface ICreditauthagreement {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  agreeCreditAuthAgreement: boolean | undefined;
  loanapplications: Loanapplication[] | undefined;
}

export class CustomAttributeData implements ICustomAttributeData {
  attributeType: Type;
  constructor_: ConstructorInfo;
  readonly constructorArguments: CustomAttributeTypedArgument[] | undefined;
  readonly namedArguments: CustomAttributeNamedArgument[] | undefined;

  constructor(data?: ICustomAttributeData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attributeType = _data["attributeType"]
        ? Type.fromJS(_data["attributeType"])
        : <any>undefined;
      this.constructor_ = _data["constructor"]
        ? ConstructorInfo.fromJS(_data["constructor"])
        : <any>undefined;
      if (Array.isArray(_data["constructorArguments"])) {
        (<any>this).constructorArguments = [] as any;
        for (let item of _data["constructorArguments"])
          (<any>this).constructorArguments.push(
            CustomAttributeTypedArgument.fromJS(item)
          );
      }
      if (Array.isArray(_data["namedArguments"])) {
        (<any>this).namedArguments = [] as any;
        for (let item of _data["namedArguments"])
          (<any>this).namedArguments.push(
            CustomAttributeNamedArgument.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): CustomAttributeData {
    data = typeof data === "object" ? data : {};
    let result = new CustomAttributeData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["attributeType"] = this.attributeType
      ? this.attributeType.toJSON()
      : <any>undefined;
    data["constructor"] = this.constructor_
      ? this.constructor_.toJSON()
      : <any>undefined;
    if (Array.isArray(this.constructorArguments)) {
      data["constructorArguments"] = [];
      for (let item of this.constructorArguments)
        data["constructorArguments"].push(item.toJSON());
    }
    if (Array.isArray(this.namedArguments)) {
      data["namedArguments"] = [];
      for (let item of this.namedArguments)
        data["namedArguments"].push(item.toJSON());
    }
    return data;
  }

  clone(): CustomAttributeData {
    const json = this.toJSON();
    let result = new CustomAttributeData();
    result.init(json);
    return result;
  }
}

export interface ICustomAttributeData {
  attributeType: Type;
  constructor_: ConstructorInfo;
  constructorArguments: CustomAttributeTypedArgument[] | undefined;
  namedArguments: CustomAttributeNamedArgument[] | undefined;
}

export class CustomAttributeNamedArgument
  implements ICustomAttributeNamedArgument {
  memberInfo: MemberInfo;
  typedValue: CustomAttributeTypedArgument;
  readonly memberName: string | undefined;
  readonly isField: boolean;

  constructor(data?: ICustomAttributeNamedArgument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.memberInfo = _data["memberInfo"]
        ? MemberInfo.fromJS(_data["memberInfo"])
        : <any>undefined;
      this.typedValue = _data["typedValue"]
        ? CustomAttributeTypedArgument.fromJS(_data["typedValue"])
        : <any>undefined;
      (<any>this).memberName = _data["memberName"];
      (<any>this).isField = _data["isField"];
    }
  }

  static fromJS(data: any): CustomAttributeNamedArgument {
    data = typeof data === "object" ? data : {};
    let result = new CustomAttributeNamedArgument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["memberInfo"] = this.memberInfo
      ? this.memberInfo.toJSON()
      : <any>undefined;
    data["typedValue"] = this.typedValue
      ? this.typedValue.toJSON()
      : <any>undefined;
    data["memberName"] = this.memberName;
    data["isField"] = this.isField;
    return data;
  }

  clone(): CustomAttributeNamedArgument {
    const json = this.toJSON();
    let result = new CustomAttributeNamedArgument();
    result.init(json);
    return result;
  }
}

export interface ICustomAttributeNamedArgument {
  memberInfo: MemberInfo;
  typedValue: CustomAttributeTypedArgument;
  memberName: string | undefined;
  isField: boolean;
}

export class CustomAttributeTypedArgument
  implements ICustomAttributeTypedArgument {
  argumentType: Type;
  value: any | undefined;

  constructor(data?: ICustomAttributeTypedArgument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.argumentType = _data["argumentType"]
        ? Type.fromJS(_data["argumentType"])
        : <any>undefined;
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): CustomAttributeTypedArgument {
    data = typeof data === "object" ? data : {};
    let result = new CustomAttributeTypedArgument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["argumentType"] = this.argumentType
      ? this.argumentType.toJSON()
      : <any>undefined;
    data["value"] = this.value;
    return data;
  }

  clone(): CustomAttributeTypedArgument {
    const json = this.toJSON();
    let result = new CustomAttributeTypedArgument();
    result.init(json);
    return result;
  }
}

export interface ICustomAttributeTypedArgument {
  argumentType: Type;
  value: any | undefined;
}

export class Declaration implements IDeclaration {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUscitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;

  constructor(data?: IDeclaration) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.isOutstandingJudgmentsAgainstYou =
        _data["isOutstandingJudgmentsAgainstYou"];
      this.isDeclaredBankrupt = _data["isDeclaredBankrupt"];
      this.isPropertyForeClosedUponOrGivenTitle =
        _data["isPropertyForeClosedUponOrGivenTitle"];
      this.isPartyToLawsuit = _data["isPartyToLawsuit"];
      this.isObligatedOnAnyLoanWhichResultedForeclosure =
        _data["isObligatedOnAnyLoanWhichResultedForeclosure"];
      this.isPresentlyDelinquent = _data["isPresentlyDelinquent"];
      this.isObligatedToPayAlimonyChildSupport =
        _data["isObligatedToPayAlimonyChildSupport"];
      this.isAnyPartOfTheDownPayment = _data["isAnyPartOfTheDownPayment"];
      this.isCoMakerOrEndorser = _data["isCoMakerOrEndorser"];
      this.isUscitizen = _data["isUscitizen"];
      this.isPermanentResidentSlien = _data["isPermanentResidentSlien"];
      this.isIntendToOccupyThePropertyAsYourPrimary =
        _data["isIntendToOccupyThePropertyAsYourPrimary"];
      this.isOwnershipInterestInPropertyInTheLastThreeYears =
        _data["isOwnershipInterestInPropertyInTheLastThreeYears"];
      this.declarationsSection = _data["declarationsSection"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? Loanapplication.fromJS(_data["loanApplication"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Declaration {
    data = typeof data === "object" ? data : {};
    let result = new Declaration();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data[
      "isOutstandingJudgmentsAgainstYou"
    ] = this.isOutstandingJudgmentsAgainstYou;
    data["isDeclaredBankrupt"] = this.isDeclaredBankrupt;
    data[
      "isPropertyForeClosedUponOrGivenTitle"
    ] = this.isPropertyForeClosedUponOrGivenTitle;
    data["isPartyToLawsuit"] = this.isPartyToLawsuit;
    data[
      "isObligatedOnAnyLoanWhichResultedForeclosure"
    ] = this.isObligatedOnAnyLoanWhichResultedForeclosure;
    data["isPresentlyDelinquent"] = this.isPresentlyDelinquent;
    data[
      "isObligatedToPayAlimonyChildSupport"
    ] = this.isObligatedToPayAlimonyChildSupport;
    data["isAnyPartOfTheDownPayment"] = this.isAnyPartOfTheDownPayment;
    data["isCoMakerOrEndorser"] = this.isCoMakerOrEndorser;
    data["isUscitizen"] = this.isUscitizen;
    data["isPermanentResidentSlien"] = this.isPermanentResidentSlien;
    data[
      "isIntendToOccupyThePropertyAsYourPrimary"
    ] = this.isIntendToOccupyThePropertyAsYourPrimary;
    data[
      "isOwnershipInterestInPropertyInTheLastThreeYears"
    ] = this.isOwnershipInterestInPropertyInTheLastThreeYears;
    data["declarationsSection"] = this.declarationsSection;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Declaration {
    const json = this.toJSON();
    let result = new Declaration();
    result.init(json);
    return result;
  }
}

export interface IDeclaration {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUscitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;
}

export class DeclarationCategory implements IDeclarationCategory {
  applicationPersonalInformationId: number | undefined;
  category: string | undefined;
  yesNo: boolean | undefined;
  applicationDeclarationQuestions: ApplicationDeclarationQuestion[] | undefined;

  constructor(data?: IDeclarationCategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.category = _data["category"];
      this.yesNo = _data["yesNo"];
      if (Array.isArray(_data["applicationDeclarationQuestions"])) {
        this.applicationDeclarationQuestions = [] as any;
        for (let item of _data["applicationDeclarationQuestions"])
          this.applicationDeclarationQuestions.push(
            ApplicationDeclarationQuestion.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): DeclarationCategory {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationCategory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["category"] = this.category;
    data["yesNo"] = this.yesNo;
    if (Array.isArray(this.applicationDeclarationQuestions)) {
      data["applicationDeclarationQuestions"] = [];
      for (let item of this.applicationDeclarationQuestions)
        data["applicationDeclarationQuestions"].push(item.toJSON());
    }
    return data;
  }

  clone(): DeclarationCategory {
    const json = this.toJSON();
    let result = new DeclarationCategory();
    result.init(json);
    return result;
  }
}

export interface IDeclarationCategory {
  applicationPersonalInformationId: number | undefined;
  category: string | undefined;
  yesNo: boolean | undefined;
  applicationDeclarationQuestions: ApplicationDeclarationQuestion[] | undefined;
}

export class DeclarationDetailDto implements IDeclarationDetailDto {
  id: number | undefined;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUSCitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;

  constructor(data?: IDeclarationDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isOutstandingJudgmentsAgainstYou =
        _data["isOutstandingJudgmentsAgainstYou"];
      this.isDeclaredBankrupt = _data["isDeclaredBankrupt"];
      this.isPropertyForeClosedUponOrGivenTitle =
        _data["isPropertyForeClosedUponOrGivenTitle"];
      this.isPartyToLawsuit = _data["isPartyToLawsuit"];
      this.isObligatedOnAnyLoanWhichResultedForeclosure =
        _data["isObligatedOnAnyLoanWhichResultedForeclosure"];
      this.isPresentlyDelinquent = _data["isPresentlyDelinquent"];
      this.isObligatedToPayAlimonyChildSupport =
        _data["isObligatedToPayAlimonyChildSupport"];
      this.isAnyPartOfTheDownPayment = _data["isAnyPartOfTheDownPayment"];
      this.isCoMakerOrEndorser = _data["isCoMakerOrEndorser"];
      this.isUSCitizen = _data["isUSCitizen"];
      this.isPermanentResidentSlien = _data["isPermanentResidentSlien"];
      this.isIntendToOccupyThePropertyAsYourPrimary =
        _data["isIntendToOccupyThePropertyAsYourPrimary"];
      this.isOwnershipInterestInPropertyInTheLastThreeYears =
        _data["isOwnershipInterestInPropertyInTheLastThreeYears"];
      this.declarationsSection = _data["declarationsSection"];
    }
  }

  static fromJS(data: any): DeclarationDetailDto {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data[
      "isOutstandingJudgmentsAgainstYou"
    ] = this.isOutstandingJudgmentsAgainstYou;
    data["isDeclaredBankrupt"] = this.isDeclaredBankrupt;
    data[
      "isPropertyForeClosedUponOrGivenTitle"
    ] = this.isPropertyForeClosedUponOrGivenTitle;
    data["isPartyToLawsuit"] = this.isPartyToLawsuit;
    data[
      "isObligatedOnAnyLoanWhichResultedForeclosure"
    ] = this.isObligatedOnAnyLoanWhichResultedForeclosure;
    data["isPresentlyDelinquent"] = this.isPresentlyDelinquent;
    data[
      "isObligatedToPayAlimonyChildSupport"
    ] = this.isObligatedToPayAlimonyChildSupport;
    data["isAnyPartOfTheDownPayment"] = this.isAnyPartOfTheDownPayment;
    data["isCoMakerOrEndorser"] = this.isCoMakerOrEndorser;
    data["isUSCitizen"] = this.isUSCitizen;
    data["isPermanentResidentSlien"] = this.isPermanentResidentSlien;
    data[
      "isIntendToOccupyThePropertyAsYourPrimary"
    ] = this.isIntendToOccupyThePropertyAsYourPrimary;
    data[
      "isOwnershipInterestInPropertyInTheLastThreeYears"
    ] = this.isOwnershipInterestInPropertyInTheLastThreeYears;
    data["declarationsSection"] = this.declarationsSection;
    return data;
  }

  clone(): DeclarationDetailDto {
    const json = this.toJSON();
    let result = new DeclarationDetailDto();
    result.init(json);
    return result;
  }
}

export interface IDeclarationDetailDto {
  id: number | undefined;
  isOutstandingJudgmentsAgainstYou: boolean | undefined;
  isDeclaredBankrupt: boolean | undefined;
  isPropertyForeClosedUponOrGivenTitle: boolean | undefined;
  isPartyToLawsuit: boolean | undefined;
  isObligatedOnAnyLoanWhichResultedForeclosure: boolean | undefined;
  isPresentlyDelinquent: boolean | undefined;
  isObligatedToPayAlimonyChildSupport: boolean | undefined;
  isAnyPartOfTheDownPayment: boolean | undefined;
  isCoMakerOrEndorser: boolean | undefined;
  isUSCitizen: boolean | undefined;
  isPermanentResidentSlien: boolean | undefined;
  isIntendToOccupyThePropertyAsYourPrimary: boolean | undefined;
  isOwnershipInterestInPropertyInTheLastThreeYears: boolean | undefined;
  declarationsSection: string | undefined;
}

export class DeclarationDto implements IDeclarationDto {
  id: number | undefined;
  loanApplicationId: number;
  borrowerDeclaration: DeclarationDetailDto;
  borrowerDemographic: DemographicDto;
  coBorrowerDeclaration: DeclarationDetailDto;
  coBorrowerDemographic: DemographicDto;

  constructor(data?: IDeclarationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerDeclaration = _data["borrowerDeclaration"]
        ? DeclarationDetailDto.fromJS(_data["borrowerDeclaration"])
        : <any>undefined;
      this.borrowerDemographic = _data["borrowerDemographic"]
        ? DemographicDto.fromJS(_data["borrowerDemographic"])
        : <any>undefined;
      this.coBorrowerDeclaration = _data["coBorrowerDeclaration"]
        ? DeclarationDetailDto.fromJS(_data["coBorrowerDeclaration"])
        : <any>undefined;
      this.coBorrowerDemographic = _data["coBorrowerDemographic"]
        ? DemographicDto.fromJS(_data["coBorrowerDemographic"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): DeclarationDto {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerDeclaration"] = this.borrowerDeclaration
      ? this.borrowerDeclaration.toJSON()
      : <any>undefined;
    data["borrowerDemographic"] = this.borrowerDemographic
      ? this.borrowerDemographic.toJSON()
      : <any>undefined;
    data["coBorrowerDeclaration"] = this.coBorrowerDeclaration
      ? this.coBorrowerDeclaration.toJSON()
      : <any>undefined;
    data["coBorrowerDemographic"] = this.coBorrowerDemographic
      ? this.coBorrowerDemographic.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): DeclarationDto {
    const json = this.toJSON();
    let result = new DeclarationDto();
    result.init(json);
    return result;
  }
}

export interface IDeclarationDto {
  id: number | undefined;
  loanApplicationId: number;
  borrowerDeclaration: DeclarationDetailDto;
  borrowerDemographic: DemographicDto;
  coBorrowerDeclaration: DeclarationDetailDto;
  coBorrowerDemographic: DemographicDto;
}

export class DeclarationDtoPagedResultDto
  implements IDeclarationDtoPagedResultDto {
  items: DeclarationDto[] | undefined;
  totalCount: number;

  constructor(data?: IDeclarationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(DeclarationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): DeclarationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new DeclarationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): DeclarationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new DeclarationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IDeclarationDtoPagedResultDto {
  items: DeclarationDto[] | undefined;
  totalCount: number;
}

export class Declarationborroweredemographicsinformation
  implements IDeclarationborroweredemographicsinformation {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isHispanicOrLatino: boolean | undefined;
  isMexican: boolean | undefined;
  isPuertoRican: boolean | undefined;
  isCuban: boolean | undefined;
  isOtherHispanicOrLatino: boolean | undefined;
  origin: string | undefined;
  isNotHispanicOrLatino: boolean | undefined;
  canNotProvideEthnic: boolean | undefined;
  isAmericanIndianOrAlaskaNative: boolean | undefined;
  nameOfEnrolledOrPrincipalTribe: string | undefined;
  isAsian: boolean | undefined;
  isAsianIndian: boolean | undefined;
  isChinese: boolean | undefined;
  isFilipino: boolean | undefined;
  isJapanese: boolean | undefined;
  isKorean: boolean | undefined;
  isVietnamese: boolean | undefined;
  isOtherAsian: boolean | undefined;
  isBlackOrAfricanAmerican: boolean | undefined;
  isNativeHawaiianOrOtherPacificIslander: boolean | undefined;
  isNativeHawaiian: boolean | undefined;
  isGuamanianOrChamorro: boolean | undefined;
  isSamoan: boolean | undefined;
  isOtherPacificIslander: boolean | undefined;
  enterRace: string | undefined;
  isWhite: boolean | undefined;
  canNotProvideRace: boolean | undefined;
  isMale: boolean | undefined;
  isFemale: boolean | undefined;
  canNotProvideSex: boolean | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;

  constructor(data?: IDeclarationborroweredemographicsinformation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.isHispanicOrLatino = _data["isHispanicOrLatino"];
      this.isMexican = _data["isMexican"];
      this.isPuertoRican = _data["isPuertoRican"];
      this.isCuban = _data["isCuban"];
      this.isOtherHispanicOrLatino = _data["isOtherHispanicOrLatino"];
      this.origin = _data["origin"];
      this.isNotHispanicOrLatino = _data["isNotHispanicOrLatino"];
      this.canNotProvideEthnic = _data["canNotProvideEthnic"];
      this.isAmericanIndianOrAlaskaNative =
        _data["isAmericanIndianOrAlaskaNative"];
      this.nameOfEnrolledOrPrincipalTribe =
        _data["nameOfEnrolledOrPrincipalTribe"];
      this.isAsian = _data["isAsian"];
      this.isAsianIndian = _data["isAsianIndian"];
      this.isChinese = _data["isChinese"];
      this.isFilipino = _data["isFilipino"];
      this.isJapanese = _data["isJapanese"];
      this.isKorean = _data["isKorean"];
      this.isVietnamese = _data["isVietnamese"];
      this.isOtherAsian = _data["isOtherAsian"];
      this.isBlackOrAfricanAmerican = _data["isBlackOrAfricanAmerican"];
      this.isNativeHawaiianOrOtherPacificIslander =
        _data["isNativeHawaiianOrOtherPacificIslander"];
      this.isNativeHawaiian = _data["isNativeHawaiian"];
      this.isGuamanianOrChamorro = _data["isGuamanianOrChamorro"];
      this.isSamoan = _data["isSamoan"];
      this.isOtherPacificIslander = _data["isOtherPacificIslander"];
      this.enterRace = _data["enterRace"];
      this.isWhite = _data["isWhite"];
      this.canNotProvideRace = _data["canNotProvideRace"];
      this.isMale = _data["isMale"];
      this.isFemale = _data["isFemale"];
      this.canNotProvideSex = _data["canNotProvideSex"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? Loanapplication.fromJS(_data["loanApplication"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Declarationborroweredemographicsinformation {
    data = typeof data === "object" ? data : {};
    let result = new Declarationborroweredemographicsinformation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["isHispanicOrLatino"] = this.isHispanicOrLatino;
    data["isMexican"] = this.isMexican;
    data["isPuertoRican"] = this.isPuertoRican;
    data["isCuban"] = this.isCuban;
    data["isOtherHispanicOrLatino"] = this.isOtherHispanicOrLatino;
    data["origin"] = this.origin;
    data["isNotHispanicOrLatino"] = this.isNotHispanicOrLatino;
    data["canNotProvideEthnic"] = this.canNotProvideEthnic;
    data[
      "isAmericanIndianOrAlaskaNative"
    ] = this.isAmericanIndianOrAlaskaNative;
    data[
      "nameOfEnrolledOrPrincipalTribe"
    ] = this.nameOfEnrolledOrPrincipalTribe;
    data["isAsian"] = this.isAsian;
    data["isAsianIndian"] = this.isAsianIndian;
    data["isChinese"] = this.isChinese;
    data["isFilipino"] = this.isFilipino;
    data["isJapanese"] = this.isJapanese;
    data["isKorean"] = this.isKorean;
    data["isVietnamese"] = this.isVietnamese;
    data["isOtherAsian"] = this.isOtherAsian;
    data["isBlackOrAfricanAmerican"] = this.isBlackOrAfricanAmerican;
    data[
      "isNativeHawaiianOrOtherPacificIslander"
    ] = this.isNativeHawaiianOrOtherPacificIslander;
    data["isNativeHawaiian"] = this.isNativeHawaiian;
    data["isGuamanianOrChamorro"] = this.isGuamanianOrChamorro;
    data["isSamoan"] = this.isSamoan;
    data["isOtherPacificIslander"] = this.isOtherPacificIslander;
    data["enterRace"] = this.enterRace;
    data["isWhite"] = this.isWhite;
    data["canNotProvideRace"] = this.canNotProvideRace;
    data["isMale"] = this.isMale;
    data["isFemale"] = this.isFemale;
    data["canNotProvideSex"] = this.canNotProvideSex;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Declarationborroweredemographicsinformation {
    const json = this.toJSON();
    let result = new Declarationborroweredemographicsinformation();
    result.init(json);
    return result;
  }
}

export interface IDeclarationborroweredemographicsinformation {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isHispanicOrLatino: boolean | undefined;
  isMexican: boolean | undefined;
  isPuertoRican: boolean | undefined;
  isCuban: boolean | undefined;
  isOtherHispanicOrLatino: boolean | undefined;
  origin: string | undefined;
  isNotHispanicOrLatino: boolean | undefined;
  canNotProvideEthnic: boolean | undefined;
  isAmericanIndianOrAlaskaNative: boolean | undefined;
  nameOfEnrolledOrPrincipalTribe: string | undefined;
  isAsian: boolean | undefined;
  isAsianIndian: boolean | undefined;
  isChinese: boolean | undefined;
  isFilipino: boolean | undefined;
  isJapanese: boolean | undefined;
  isKorean: boolean | undefined;
  isVietnamese: boolean | undefined;
  isOtherAsian: boolean | undefined;
  isBlackOrAfricanAmerican: boolean | undefined;
  isNativeHawaiianOrOtherPacificIslander: boolean | undefined;
  isNativeHawaiian: boolean | undefined;
  isGuamanianOrChamorro: boolean | undefined;
  isSamoan: boolean | undefined;
  isOtherPacificIslander: boolean | undefined;
  enterRace: string | undefined;
  isWhite: boolean | undefined;
  canNotProvideRace: boolean | undefined;
  isMale: boolean | undefined;
  isFemale: boolean | undefined;
  canNotProvideSex: boolean | undefined;
  borrowerTypeId: number;
  loanApplicationId: number;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;
}

export class DemographicDto implements IDemographicDto {
  id: number | undefined;
  ethnicity: DemographicTypeDto[] | undefined;
  race: DemographicTypeDto[] | undefined;
  sex: DemographicTypeDto[] | undefined;

  constructor(data?: IDemographicDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      if (Array.isArray(_data["ethnicity"])) {
        this.ethnicity = [] as any;
        for (let item of _data["ethnicity"])
          this.ethnicity.push(DemographicTypeDto.fromJS(item));
      }
      if (Array.isArray(_data["race"])) {
        this.race = [] as any;
        for (let item of _data["race"])
          this.race.push(DemographicTypeDto.fromJS(item));
      }
      if (Array.isArray(_data["sex"])) {
        this.sex = [] as any;
        for (let item of _data["sex"])
          this.sex.push(DemographicTypeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DemographicDto {
    data = typeof data === "object" ? data : {};
    let result = new DemographicDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    if (Array.isArray(this.ethnicity)) {
      data["ethnicity"] = [];
      for (let item of this.ethnicity) data["ethnicity"].push(item.toJSON());
    }
    if (Array.isArray(this.race)) {
      data["race"] = [];
      for (let item of this.race) data["race"].push(item.toJSON());
    }
    if (Array.isArray(this.sex)) {
      data["sex"] = [];
      for (let item of this.sex) data["sex"].push(item.toJSON());
    }
    return data;
  }

  clone(): DemographicDto {
    const json = this.toJSON();
    let result = new DemographicDto();
    result.init(json);
    return result;
  }
}

export interface IDemographicDto {
  id: number | undefined;
  ethnicity: DemographicTypeDto[] | undefined;
  race: DemographicTypeDto[] | undefined;
  sex: DemographicTypeDto[] | undefined;
}

export class DemographicInformationDetail
  implements IDemographicInformationDetail {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSource87: string | undefined;

  constructor(data?: IDemographicInformationDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.ethnicity81 = _data["ethnicity81"];
      this.gender82 = _data["gender82"];
      this.race83 = _data["race83"];
      this.isEthnicityByObservation84 = _data["isEthnicityByObservation84"];
      this.isGenderByObservation85 = _data["isGenderByObservation85"];
      this.isRaceByObservation86 = _data["isRaceByObservation86"];
      this.demographicInfoSource87 = _data["demographicInfoSource87"];
    }
  }

  static fromJS(data: any): DemographicInformationDetail {
    data = typeof data === "object" ? data : {};
    let result = new DemographicInformationDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["ethnicity81"] = this.ethnicity81;
    data["gender82"] = this.gender82;
    data["race83"] = this.race83;
    data["isEthnicityByObservation84"] = this.isEthnicityByObservation84;
    data["isGenderByObservation85"] = this.isGenderByObservation85;
    data["isRaceByObservation86"] = this.isRaceByObservation86;
    data["demographicInfoSource87"] = this.demographicInfoSource87;
    return data;
  }

  clone(): DemographicInformationDetail {
    const json = this.toJSON();
    let result = new DemographicInformationDetail();
    result.init(json);
    return result;
  }
}

export interface IDemographicInformationDetail {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSource87: string | undefined;
}

export class DemographicTypeDto implements IDemographicTypeDto {
  id: number;
  otherValue: string | undefined;

  constructor(data?: IDemographicTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.otherValue = _data["otherValue"];
    }
  }

  static fromJS(data: any): DemographicTypeDto {
    data = typeof data === "object" ? data : {};
    let result = new DemographicTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["otherValue"] = this.otherValue;
    return data;
  }

  clone(): DemographicTypeDto {
    const json = this.toJSON();
    let result = new DemographicTypeDto();
    result.init(json);
    return result;
  }
}

export interface IDemographicTypeDto {
  id: number;
  otherValue: string | undefined;
}

export class EConsentDto implements IEConsentDto {
  id: number | undefined;
  agreeEConsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEConsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;

  constructor(data?: IEConsentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.agreeEConsent = _data["agreeEConsent"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.email = _data["email"];
      this.coborrowerAgreeEConsent = _data["coborrowerAgreeEConsent"];
      this.coborrowerFirstName = _data["coborrowerFirstName"];
      this.coborrowerLastName = _data["coborrowerLastName"];
      this.coborrowerEmail = _data["coborrowerEmail"];
    }
  }

  static fromJS(data: any): EConsentDto {
    data = typeof data === "object" ? data : {};
    let result = new EConsentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["agreeEConsent"] = this.agreeEConsent;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["email"] = this.email;
    data["coborrowerAgreeEConsent"] = this.coborrowerAgreeEConsent;
    data["coborrowerFirstName"] = this.coborrowerFirstName;
    data["coborrowerLastName"] = this.coborrowerLastName;
    data["coborrowerEmail"] = this.coborrowerEmail;
    return data;
  }

  clone(): EConsentDto {
    const json = this.toJSON();
    let result = new EConsentDto();
    result.init(json);
    return result;
  }
}

export interface IEConsentDto {
  id: number | undefined;
  agreeEConsent: boolean | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  email: string | undefined;
  coborrowerAgreeEConsent: boolean | undefined;
  coborrowerFirstName: string | undefined;
  coborrowerLastName: string | undefined;
  coborrowerEmail: string | undefined;
}

export class EConsentDtoPagedResultDto implements IEConsentDtoPagedResultDto {
  items: EConsentDto[] | undefined;
  totalCount: number;

  constructor(data?: IEConsentDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(EConsentDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): EConsentDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new EConsentDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): EConsentDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EConsentDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEConsentDtoPagedResultDto {
  items: EConsentDto[] | undefined;
  totalCount: number;
}

export class EmploymentIncomeDto implements IEmploymentIncomeDto {
  id: number | undefined;
  loanApplicationId: number | undefined;
  additionalIncomes: AdditionalIncomeDto[] | undefined;
  borrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  coBorrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  borrowerMonthlyIncome: BorrowerMonthlyIncomeDto;
  coBorrowerMonthlyIncome: BorrowerMonthlyIncomeDto;

  constructor(data?: IEmploymentIncomeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanApplicationId = _data["loanApplicationId"];
      if (Array.isArray(_data["additionalIncomes"])) {
        this.additionalIncomes = [] as any;
        for (let item of _data["additionalIncomes"])
          this.additionalIncomes.push(AdditionalIncomeDto.fromJS(item));
      }
      if (Array.isArray(_data["borrowerEmploymentInfo"])) {
        this.borrowerEmploymentInfo = [] as any;
        for (let item of _data["borrowerEmploymentInfo"])
          this.borrowerEmploymentInfo.push(
            BorrowerEmploymentInformationDto.fromJS(item)
          );
      }
      if (Array.isArray(_data["coBorrowerEmploymentInfo"])) {
        this.coBorrowerEmploymentInfo = [] as any;
        for (let item of _data["coBorrowerEmploymentInfo"])
          this.coBorrowerEmploymentInfo.push(
            BorrowerEmploymentInformationDto.fromJS(item)
          );
      }
      this.borrowerMonthlyIncome = _data["borrowerMonthlyIncome"]
        ? BorrowerMonthlyIncomeDto.fromJS(_data["borrowerMonthlyIncome"])
        : <any>undefined;
      this.coBorrowerMonthlyIncome = _data["coBorrowerMonthlyIncome"]
        ? BorrowerMonthlyIncomeDto.fromJS(_data["coBorrowerMonthlyIncome"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): EmploymentIncomeDto {
    data = typeof data === "object" ? data : {};
    let result = new EmploymentIncomeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["loanApplicationId"] = this.loanApplicationId;
    if (Array.isArray(this.additionalIncomes)) {
      data["additionalIncomes"] = [];
      for (let item of this.additionalIncomes)
        data["additionalIncomes"].push(item.toJSON());
    }
    if (Array.isArray(this.borrowerEmploymentInfo)) {
      data["borrowerEmploymentInfo"] = [];
      for (let item of this.borrowerEmploymentInfo)
        data["borrowerEmploymentInfo"].push(item.toJSON());
    }
    if (Array.isArray(this.coBorrowerEmploymentInfo)) {
      data["coBorrowerEmploymentInfo"] = [];
      for (let item of this.coBorrowerEmploymentInfo)
        data["coBorrowerEmploymentInfo"].push(item.toJSON());
    }
    data["borrowerMonthlyIncome"] = this.borrowerMonthlyIncome
      ? this.borrowerMonthlyIncome.toJSON()
      : <any>undefined;
    data["coBorrowerMonthlyIncome"] = this.coBorrowerMonthlyIncome
      ? this.coBorrowerMonthlyIncome.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): EmploymentIncomeDto {
    const json = this.toJSON();
    let result = new EmploymentIncomeDto();
    result.init(json);
    return result;
  }
}

export interface IEmploymentIncomeDto {
  id: number | undefined;
  loanApplicationId: number | undefined;
  additionalIncomes: AdditionalIncomeDto[] | undefined;
  borrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  coBorrowerEmploymentInfo: BorrowerEmploymentInformationDto[] | undefined;
  borrowerMonthlyIncome: BorrowerMonthlyIncomeDto;
  coBorrowerMonthlyIncome: BorrowerMonthlyIncomeDto;
}

export class EmploymentIncomeDtoPagedResultDto
  implements IEmploymentIncomeDtoPagedResultDto {
  items: EmploymentIncomeDto[] | undefined;
  totalCount: number;

  constructor(data?: IEmploymentIncomeDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(EmploymentIncomeDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): EmploymentIncomeDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new EmploymentIncomeDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): EmploymentIncomeDtoPagedResultDto {
    const json = this.toJSON();
    let result = new EmploymentIncomeDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IEmploymentIncomeDtoPagedResultDto {
  items: EmploymentIncomeDto[] | undefined;
  totalCount: number;
}

export enum EventAttributes {
  _0 = 0,
  _512 = 512,
  _1024 = 1024,
}

export class EventInfo implements IEventInfo {
  readonly name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  memberType: MemberTypes;
  attributes: EventAttributes;
  readonly isSpecialName: boolean;
  addMethod: MethodInfo;
  removeMethod: MethodInfo;
  raiseMethod: MethodInfo;
  readonly isMulticast: boolean;
  eventHandlerType: Type;

  constructor(data?: IEventInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data["name"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      this.memberType = _data["memberType"];
      this.attributes = _data["attributes"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      this.addMethod = _data["addMethod"]
        ? MethodInfo.fromJS(_data["addMethod"])
        : <any>undefined;
      this.removeMethod = _data["removeMethod"]
        ? MethodInfo.fromJS(_data["removeMethod"])
        : <any>undefined;
      this.raiseMethod = _data["raiseMethod"]
        ? MethodInfo.fromJS(_data["raiseMethod"])
        : <any>undefined;
      (<any>this).isMulticast = _data["isMulticast"];
      this.eventHandlerType = _data["eventHandlerType"]
        ? Type.fromJS(_data["eventHandlerType"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): EventInfo {
    data = typeof data === "object" ? data : {};
    let result = new EventInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["memberType"] = this.memberType;
    data["attributes"] = this.attributes;
    data["isSpecialName"] = this.isSpecialName;
    data["addMethod"] = this.addMethod
      ? this.addMethod.toJSON()
      : <any>undefined;
    data["removeMethod"] = this.removeMethod
      ? this.removeMethod.toJSON()
      : <any>undefined;
    data["raiseMethod"] = this.raiseMethod
      ? this.raiseMethod.toJSON()
      : <any>undefined;
    data["isMulticast"] = this.isMulticast;
    data["eventHandlerType"] = this.eventHandlerType
      ? this.eventHandlerType.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): EventInfo {
    const json = this.toJSON();
    let result = new EventInfo();
    result.init(json);
    return result;
  }
}

export interface IEventInfo {
  name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  memberType: MemberTypes;
  attributes: EventAttributes;
  isSpecialName: boolean;
  addMethod: MethodInfo;
  removeMethod: MethodInfo;
  raiseMethod: MethodInfo;
  isMulticast: boolean;
  eventHandlerType: Type;
}

export class Expense implements IExpense {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;
  loanapplications: Loanapplication[] | undefined;

  constructor(data?: IExpense) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.isLiveWithFamilySelectRent = _data["isLiveWithFamilySelectRent"];
      this.rent = _data["rent"];
      this.otherHousingExpenses = _data["otherHousingExpenses"];
      this.firstMortgage = _data["firstMortgage"];
      this.secondMortgage = _data["secondMortgage"];
      this.hazardInsurance = _data["hazardInsurance"];
      this.realEstateTaxes = _data["realEstateTaxes"];
      this.mortgageInsurance = _data["mortgageInsurance"];
      this.homeOwnersAssociation = _data["homeOwnersAssociation"];
      if (Array.isArray(_data["loanapplications"])) {
        this.loanapplications = [] as any;
        for (let item of _data["loanapplications"])
          this.loanapplications.push(Loanapplication.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Expense {
    data = typeof data === "object" ? data : {};
    let result = new Expense();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["isLiveWithFamilySelectRent"] = this.isLiveWithFamilySelectRent;
    data["rent"] = this.rent;
    data["otherHousingExpenses"] = this.otherHousingExpenses;
    data["firstMortgage"] = this.firstMortgage;
    data["secondMortgage"] = this.secondMortgage;
    data["hazardInsurance"] = this.hazardInsurance;
    data["realEstateTaxes"] = this.realEstateTaxes;
    data["mortgageInsurance"] = this.mortgageInsurance;
    data["homeOwnersAssociation"] = this.homeOwnersAssociation;
    if (Array.isArray(this.loanapplications)) {
      data["loanapplications"] = [];
      for (let item of this.loanapplications)
        data["loanapplications"].push(item.toJSON());
    }
    return data;
  }

  clone(): Expense {
    const json = this.toJSON();
    let result = new Expense();
    result.init(json);
    return result;
  }
}

export interface IExpense {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;
  loanapplications: Loanapplication[] | undefined;
}

export class ExpensesDto implements IExpensesDto {
  id: number | undefined;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;

  constructor(data?: IExpensesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isLiveWithFamilySelectRent = _data["isLiveWithFamilySelectRent"];
      this.rent = _data["rent"];
      this.otherHousingExpenses = _data["otherHousingExpenses"];
      this.firstMortgage = _data["firstMortgage"];
      this.secondMortgage = _data["secondMortgage"];
      this.hazardInsurance = _data["hazardInsurance"];
      this.realEstateTaxes = _data["realEstateTaxes"];
      this.mortgageInsurance = _data["mortgageInsurance"];
      this.homeOwnersAssociation = _data["homeOwnersAssociation"];
    }
  }

  static fromJS(data: any): ExpensesDto {
    data = typeof data === "object" ? data : {};
    let result = new ExpensesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isLiveWithFamilySelectRent"] = this.isLiveWithFamilySelectRent;
    data["rent"] = this.rent;
    data["otherHousingExpenses"] = this.otherHousingExpenses;
    data["firstMortgage"] = this.firstMortgage;
    data["secondMortgage"] = this.secondMortgage;
    data["hazardInsurance"] = this.hazardInsurance;
    data["realEstateTaxes"] = this.realEstateTaxes;
    data["mortgageInsurance"] = this.mortgageInsurance;
    data["homeOwnersAssociation"] = this.homeOwnersAssociation;
    return data;
  }

  clone(): ExpensesDto {
    const json = this.toJSON();
    let result = new ExpensesDto();
    result.init(json);
    return result;
  }
}

export interface IExpensesDto {
  id: number | undefined;
  isLiveWithFamilySelectRent: boolean | undefined;
  rent: number | undefined;
  otherHousingExpenses: number | undefined;
  firstMortgage: number | undefined;
  secondMortgage: number | undefined;
  hazardInsurance: number | undefined;
  realEstateTaxes: number | undefined;
  mortgageInsurance: number | undefined;
  homeOwnersAssociation: number | undefined;
}

export class ExpensesDtoPagedResultDto implements IExpensesDtoPagedResultDto {
  items: ExpensesDto[] | undefined;
  totalCount: number;

  constructor(data?: IExpensesDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(ExpensesDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): ExpensesDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new ExpensesDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): ExpensesDtoPagedResultDto {
    const json = this.toJSON();
    let result = new ExpensesDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IExpensesDtoPagedResultDto {
  items: ExpensesDto[] | undefined;
  totalCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;

  constructor(data?: IExternalAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authProvider = _data["authProvider"];
      this.providerKey = _data["providerKey"];
      this.providerAccessCode = _data["providerAccessCode"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["authProvider"] = this.authProvider;
    data["providerKey"] = this.providerKey;
    data["providerAccessCode"] = this.providerAccessCode;
    return data;
  }

  clone(): ExternalAuthenticateModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;
}

export class ExternalAuthenticateResultModel
  implements IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;

  constructor(data?: IExternalAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.waitingForActivation = _data["waitingForActivation"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["waitingForActivation"] = this.waitingForActivation;
    return data;
  }

  clone(): ExternalAuthenticateResultModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel
  implements IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;

  constructor(data?: IExternalLoginProviderInfoModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.clientId = _data["clientId"];
    }
  }

  static fromJS(data: any): ExternalLoginProviderInfoModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalLoginProviderInfoModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["clientId"] = this.clientId;
    return data;
  }

  clone(): ExternalLoginProviderInfoModel {
    const json = this.toJSON();
    let result = new ExternalLoginProviderInfoModel();
    result.init(json);
    return result;
  }
}

export interface IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;
}

export enum FieldAttributes {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7,
  _16 = 16,
  _32 = 32,
  _64 = 64,
  _128 = 128,
  _256 = 256,
  _512 = 512,
  _1024 = 1024,
  _4096 = 4096,
  _8192 = 8192,
  _32768 = 32768,
  _38144 = 38144,
}

export class FieldInfo implements IFieldInfo {
  readonly name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  memberType: MemberTypes;
  attributes: FieldAttributes;
  fieldType: Type;
  readonly isInitOnly: boolean;
  readonly isLiteral: boolean;
  readonly isNotSerialized: boolean;
  readonly isPinvokeImpl: boolean;
  readonly isSpecialName: boolean;
  readonly isStatic: boolean;
  readonly isAssembly: boolean;
  readonly isFamily: boolean;
  readonly isFamilyAndAssembly: boolean;
  readonly isFamilyOrAssembly: boolean;
  readonly isPrivate: boolean;
  readonly isPublic: boolean;
  readonly isSecurityCritical: boolean;
  readonly isSecuritySafeCritical: boolean;
  readonly isSecurityTransparent: boolean;
  fieldHandle: RuntimeFieldHandle;

  constructor(data?: IFieldInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data["name"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      this.memberType = _data["memberType"];
      this.attributes = _data["attributes"];
      this.fieldType = _data["fieldType"]
        ? Type.fromJS(_data["fieldType"])
        : <any>undefined;
      (<any>this).isInitOnly = _data["isInitOnly"];
      (<any>this).isLiteral = _data["isLiteral"];
      (<any>this).isNotSerialized = _data["isNotSerialized"];
      (<any>this).isPinvokeImpl = _data["isPinvokeImpl"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      (<any>this).isStatic = _data["isStatic"];
      (<any>this).isAssembly = _data["isAssembly"];
      (<any>this).isFamily = _data["isFamily"];
      (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
      (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
      (<any>this).isPrivate = _data["isPrivate"];
      (<any>this).isPublic = _data["isPublic"];
      (<any>this).isSecurityCritical = _data["isSecurityCritical"];
      (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
      (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
      this.fieldHandle = _data["fieldHandle"]
        ? RuntimeFieldHandle.fromJS(_data["fieldHandle"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): FieldInfo {
    data = typeof data === "object" ? data : {};
    let result = new FieldInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["memberType"] = this.memberType;
    data["attributes"] = this.attributes;
    data["fieldType"] = this.fieldType
      ? this.fieldType.toJSON()
      : <any>undefined;
    data["isInitOnly"] = this.isInitOnly;
    data["isLiteral"] = this.isLiteral;
    data["isNotSerialized"] = this.isNotSerialized;
    data["isPinvokeImpl"] = this.isPinvokeImpl;
    data["isSpecialName"] = this.isSpecialName;
    data["isStatic"] = this.isStatic;
    data["isAssembly"] = this.isAssembly;
    data["isFamily"] = this.isFamily;
    data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
    data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
    data["isPrivate"] = this.isPrivate;
    data["isPublic"] = this.isPublic;
    data["isSecurityCritical"] = this.isSecurityCritical;
    data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
    data["isSecurityTransparent"] = this.isSecurityTransparent;
    data["fieldHandle"] = this.fieldHandle
      ? this.fieldHandle.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): FieldInfo {
    const json = this.toJSON();
    let result = new FieldInfo();
    result.init(json);
    return result;
  }
}

export interface IFieldInfo {
  name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  memberType: MemberTypes;
  attributes: FieldAttributes;
  fieldType: Type;
  isInitOnly: boolean;
  isLiteral: boolean;
  isNotSerialized: boolean;
  isPinvokeImpl: boolean;
  isSpecialName: boolean;
  isStatic: boolean;
  isAssembly: boolean;
  isFamily: boolean;
  isFamilyAndAssembly: boolean;
  isFamilyOrAssembly: boolean;
  isPrivate: boolean;
  isPublic: boolean;
  isSecurityCritical: boolean;
  isSecuritySafeCritical: boolean;
  isSecurityTransparent: boolean;
  fieldHandle: RuntimeFieldHandle;
}

export class FinancialRealEstateDetail implements IFinancialRealEstateDetail {
  applicationPersonalInformationId: number | undefined;
  street3a21: string | undefined;
  unitNo3a22: string | undefined;
  zip3a25: string | undefined;
  country3a26: string | undefined;
  state3a24: string | undefined;
  city3a23: string | undefined;
  propertyValue3a3: number | undefined;
  financialPropertyStatus3a4: string | undefined;
  financialPropertyIntendedOccupancy3a5: string | undefined;
  monthlyMortagePayment3a6: number | undefined;
  monthlyRentalIncome3a7: number | undefined;
  netMonthlyRentalIncome3a8: number | undefined;
  mortageLoanOnPropertyDetails: MortageLoanOnPropertyDetail[] | undefined;

  constructor(data?: IFinancialRealEstateDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.street3a21 = _data["street3a21"];
      this.unitNo3a22 = _data["unitNo3a22"];
      this.zip3a25 = _data["zip3a25"];
      this.country3a26 = _data["country3a26"];
      this.state3a24 = _data["state3a24"];
      this.city3a23 = _data["city3a23"];
      this.propertyValue3a3 = _data["propertyValue3a3"];
      this.financialPropertyStatus3a4 = _data["financialPropertyStatus3a4"];
      this.financialPropertyIntendedOccupancy3a5 =
        _data["financialPropertyIntendedOccupancy3a5"];
      this.monthlyMortagePayment3a6 = _data["monthlyMortagePayment3a6"];
      this.monthlyRentalIncome3a7 = _data["monthlyRentalIncome3a7"];
      this.netMonthlyRentalIncome3a8 = _data["netMonthlyRentalIncome3a8"];
      if (Array.isArray(_data["mortageLoanOnPropertyDetails"])) {
        this.mortageLoanOnPropertyDetails = [] as any;
        for (let item of _data["mortageLoanOnPropertyDetails"])
          this.mortageLoanOnPropertyDetails.push(
            MortageLoanOnPropertyDetail.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): FinancialRealEstateDetail {
    data = typeof data === "object" ? data : {};
    let result = new FinancialRealEstateDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["street3a21"] = this.street3a21;
    data["unitNo3a22"] = this.unitNo3a22;
    data["zip3a25"] = this.zip3a25;
    data["country3a26"] = this.country3a26;
    data["state3a24"] = this.state3a24;
    data["city3a23"] = this.city3a23;
    data["propertyValue3a3"] = this.propertyValue3a3;
    data["financialPropertyStatus3a4"] = this.financialPropertyStatus3a4;
    data[
      "financialPropertyIntendedOccupancy3a5"
    ] = this.financialPropertyIntendedOccupancy3a5;
    data["monthlyMortagePayment3a6"] = this.monthlyMortagePayment3a6;
    data["monthlyRentalIncome3a7"] = this.monthlyRentalIncome3a7;
    data["netMonthlyRentalIncome3a8"] = this.netMonthlyRentalIncome3a8;
    if (Array.isArray(this.mortageLoanOnPropertyDetails)) {
      data["mortageLoanOnPropertyDetails"] = [];
      for (let item of this.mortageLoanOnPropertyDetails)
        data["mortageLoanOnPropertyDetails"].push(item.toJSON());
    }
    return data;
  }

  clone(): FinancialRealEstateDetail {
    const json = this.toJSON();
    let result = new FinancialRealEstateDetail();
    result.init(json);
    return result;
  }
}

export interface IFinancialRealEstateDetail {
  applicationPersonalInformationId: number | undefined;
  street3a21: string | undefined;
  unitNo3a22: string | undefined;
  zip3a25: string | undefined;
  country3a26: string | undefined;
  state3a24: string | undefined;
  city3a23: string | undefined;
  propertyValue3a3: number | undefined;
  financialPropertyStatus3a4: string | undefined;
  financialPropertyIntendedOccupancy3a5: string | undefined;
  monthlyMortagePayment3a6: number | undefined;
  monthlyRentalIncome3a7: number | undefined;
  netMonthlyRentalIncome3a8: number | undefined;
  mortageLoanOnPropertyDetails: MortageLoanOnPropertyDetail[] | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IFlatPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): FlatPermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new FlatPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): FlatPermissionDto {
    const json = this.toJSON();
    let result = new FlatPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export enum GenericParameterAttributes {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _8 = 8,
  _16 = 16,
  _28 = 28,
}

export class GetCurrentLoginInformationsOutput
  implements IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;

  constructor(data?: IGetCurrentLoginInformationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.application = _data["application"]
        ? ApplicationInfoDto.fromJS(_data["application"])
        : <any>undefined;
      this.user = _data["user"]
        ? UserLoginInfoDto.fromJS(_data["user"])
        : <any>undefined;
      this.tenant = _data["tenant"]
        ? TenantLoginInfoDto.fromJS(_data["tenant"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetCurrentLoginInformationsOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetCurrentLoginInformationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["application"] = this.application
      ? this.application.toJSON()
      : <any>undefined;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    return data;
  }

  clone(): GetCurrentLoginInformationsOutput {
    const json = this.toJSON();
    let result = new GetCurrentLoginInformationsOutput();
    result.init(json);
    return result;
  }
}

export interface IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;
}

export class GetPdfDataModel implements IGetPdfDataModel {
  id: number;
  applicationId: number;
  firstName1a1: string | undefined;
  middleName1a2: string | undefined;
  lastName1a3: string | undefined;
  suffix1a4: string | undefined;
  alternateFirstName1a21: string | undefined;
  alternateMiddleName1a22: string | undefined;
  alternateLastName1a23: string | undefined;
  alternateSuffix1a24: string | undefined;
  ssn1a3: string | undefined;
  dob1a4: moment.Moment | undefined;
  citizenshipType1a5: string | undefined;
  maritialStatusId1a7: number;
  dependents1a8: number | undefined;
  ages1a81: string | undefined;
  homePhone1a9: string | undefined;
  cellPhone1a10: string | undefined;
  workPhone1a11: string | undefined;
  ext1a111: string | undefined;
  email1a12: string | undefined;
  currentStreet1a131: string | undefined;
  currentUnit1a132: string | undefined;
  currentZip1a135: string | undefined;
  currentCountry1a136: string | undefined;
  currentState1a134: string | undefined;
  currentCity1a133: string | undefined;
  currentYears1a14: number | undefined;
  currentMonths1a15: number | undefined;
  currentHousingType1a141: string | undefined;
  currentRent1a142: number | undefined;
  formerStreet1a151: string | undefined;
  formerUnit1a152: string | undefined;
  formerZip1a155: string | undefined;
  formerCountry1a156: string | undefined;
  formerState1a154: string | undefined;
  formerCity1a153: string | undefined;
  formerYears1a16: number | undefined;
  formerMonths1a161: number | undefined;
  formerHousingType1a161: string | undefined;
  formerRent1a162: number | undefined;
  mailingStreet1a171: string | undefined;
  mailingUnit1a172: string | undefined;
  mailingZip1a175: string | undefined;
  mailingCountry1a176: string | undefined;
  mailingState1a174: string | undefined;
  mailingCity1a173: string | undefined;
  application: ApplicationDetail;
  additionalEmploymentDetails: AdditionalEmploymentDetail[] | undefined;
  applicationDeclarationQuestionDetail: DeclarationCategory[] | undefined;
  declarationQuestions: ApplicationDeclarationQuestion[] | undefined;
  applicationEmployementDetails: ApplicationEmployementDetail[] | undefined;
  applicationFinancialAssets: ApplicationFinancialAsset[] | undefined;
  applicationFinancialLaibilities:
    | ApplicationFinancialLiabilityDetail[]
    | undefined;
  applicationFinancialOtherAssets:
    | ApplicationFinancialOtherAssetDetail[]
    | undefined;
  applicationFinancialOtherLaibilities:
    | ApplicationFinancialOtherLaibilityDetail[]
    | undefined;
  applicationFinancialRealEstates: FinancialRealEstateDetail[] | undefined;
  applicationIncomeSources: ApplicationIncomeSourceDetail[] | undefined;
  applicationPreviousEmployementDetails:
    | PreviousEmployementDetail[]
    | undefined;
  demographicInformations: DemographicInformationDetail[] | undefined;
  loanAndPropertyInformationGifts:
    | LoanAndPropertyInformationGiftDetail[]
    | undefined;
  loanAndPropertyInformationOtherMortageLoans:
    | UpdateLoanAndPropertyInformationOtherMortageLoanRequest[]
    | undefined;
  loanAndPropertyInformationRentalIncomes:
    | UpdateLoanAndPropertyInformationRentalIncomeRequest[]
    | undefined;
  loanAndPropertyInformations: LoanAndPropertyInformationDetail[] | undefined;
  loanOriginatorInformations:
    | UpdateLoanOriginatorInformationRequest[]
    | undefined;
  militaryServices: UpdateMilitaryServiceRequest[] | undefined;

  constructor(data?: IGetPdfDataModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.applicationId = _data["applicationId"];
      this.firstName1a1 = _data["firstName1a1"];
      this.middleName1a2 = _data["middleName1a2"];
      this.lastName1a3 = _data["lastName1a3"];
      this.suffix1a4 = _data["suffix1a4"];
      this.alternateFirstName1a21 = _data["alternateFirstName1a21"];
      this.alternateMiddleName1a22 = _data["alternateMiddleName1a22"];
      this.alternateLastName1a23 = _data["alternateLastName1a23"];
      this.alternateSuffix1a24 = _data["alternateSuffix1a24"];
      this.ssn1a3 = _data["ssn1a3"];
      this.dob1a4 = _data["dob1a4"]
        ? moment(_data["dob1a4"].toString())
        : <any>undefined;
      this.citizenshipType1a5 = _data["citizenshipType1a5"];
      this.maritialStatusId1a7 = _data["maritialStatusId1a7"];
      this.dependents1a8 = _data["dependents1a8"];
      this.ages1a81 = _data["ages1a81"];
      this.homePhone1a9 = _data["homePhone1a9"];
      this.cellPhone1a10 = _data["cellPhone1a10"];
      this.workPhone1a11 = _data["workPhone1a11"];
      this.ext1a111 = _data["ext1a111"];
      this.email1a12 = _data["email1a12"];
      this.currentStreet1a131 = _data["currentStreet1a131"];
      this.currentUnit1a132 = _data["currentUnit1a132"];
      this.currentZip1a135 = _data["currentZip1a135"];
      this.currentCountry1a136 = _data["currentCountry1a136"];
      this.currentState1a134 = _data["currentState1a134"];
      this.currentCity1a133 = _data["currentCity1a133"];
      this.currentYears1a14 = _data["currentYears1a14"];
      this.currentMonths1a15 = _data["currentMonths1a15"];
      this.currentHousingType1a141 = _data["currentHousingType1a141"];
      this.currentRent1a142 = _data["currentRent1a142"];
      this.formerStreet1a151 = _data["formerStreet1a151"];
      this.formerUnit1a152 = _data["formerUnit1a152"];
      this.formerZip1a155 = _data["formerZip1a155"];
      this.formerCountry1a156 = _data["formerCountry1a156"];
      this.formerState1a154 = _data["formerState1a154"];
      this.formerCity1a153 = _data["formerCity1a153"];
      this.formerYears1a16 = _data["formerYears1a16"];
      this.formerMonths1a161 = _data["formerMonths1a161"];
      this.formerHousingType1a161 = _data["formerHousingType1a161"];
      this.formerRent1a162 = _data["formerRent1a162"];
      this.mailingStreet1a171 = _data["mailingStreet1a171"];
      this.mailingUnit1a172 = _data["mailingUnit1a172"];
      this.mailingZip1a175 = _data["mailingZip1a175"];
      this.mailingCountry1a176 = _data["mailingCountry1a176"];
      this.mailingState1a174 = _data["mailingState1a174"];
      this.mailingCity1a173 = _data["mailingCity1a173"];
      this.application = _data["application"]
        ? ApplicationDetail.fromJS(_data["application"])
        : <any>undefined;
      if (Array.isArray(_data["additionalEmploymentDetails"])) {
        this.additionalEmploymentDetails = [] as any;
        for (let item of _data["additionalEmploymentDetails"])
          this.additionalEmploymentDetails.push(
            AdditionalEmploymentDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationDeclarationQuestionDetail"])) {
        this.applicationDeclarationQuestionDetail = [] as any;
        for (let item of _data["applicationDeclarationQuestionDetail"])
          this.applicationDeclarationQuestionDetail.push(
            DeclarationCategory.fromJS(item)
          );
      }
      if (Array.isArray(_data["declarationQuestions"])) {
        this.declarationQuestions = [] as any;
        for (let item of _data["declarationQuestions"])
          this.declarationQuestions.push(
            ApplicationDeclarationQuestion.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationEmployementDetails"])) {
        this.applicationEmployementDetails = [] as any;
        for (let item of _data["applicationEmployementDetails"])
          this.applicationEmployementDetails.push(
            ApplicationEmployementDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationFinancialAssets"])) {
        this.applicationFinancialAssets = [] as any;
        for (let item of _data["applicationFinancialAssets"])
          this.applicationFinancialAssets.push(
            ApplicationFinancialAsset.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationFinancialLaibilities"])) {
        this.applicationFinancialLaibilities = [] as any;
        for (let item of _data["applicationFinancialLaibilities"])
          this.applicationFinancialLaibilities.push(
            ApplicationFinancialLiabilityDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationFinancialOtherAssets"])) {
        this.applicationFinancialOtherAssets = [] as any;
        for (let item of _data["applicationFinancialOtherAssets"])
          this.applicationFinancialOtherAssets.push(
            ApplicationFinancialOtherAssetDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationFinancialOtherLaibilities"])) {
        this.applicationFinancialOtherLaibilities = [] as any;
        for (let item of _data["applicationFinancialOtherLaibilities"])
          this.applicationFinancialOtherLaibilities.push(
            ApplicationFinancialOtherLaibilityDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationFinancialRealEstates"])) {
        this.applicationFinancialRealEstates = [] as any;
        for (let item of _data["applicationFinancialRealEstates"])
          this.applicationFinancialRealEstates.push(
            FinancialRealEstateDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationIncomeSources"])) {
        this.applicationIncomeSources = [] as any;
        for (let item of _data["applicationIncomeSources"])
          this.applicationIncomeSources.push(
            ApplicationIncomeSourceDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["applicationPreviousEmployementDetails"])) {
        this.applicationPreviousEmployementDetails = [] as any;
        for (let item of _data["applicationPreviousEmployementDetails"])
          this.applicationPreviousEmployementDetails.push(
            PreviousEmployementDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["demographicInformations"])) {
        this.demographicInformations = [] as any;
        for (let item of _data["demographicInformations"])
          this.demographicInformations.push(
            DemographicInformationDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["loanAndPropertyInformationGifts"])) {
        this.loanAndPropertyInformationGifts = [] as any;
        for (let item of _data["loanAndPropertyInformationGifts"])
          this.loanAndPropertyInformationGifts.push(
            LoanAndPropertyInformationGiftDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["loanAndPropertyInformationOtherMortageLoans"])) {
        this.loanAndPropertyInformationOtherMortageLoans = [] as any;
        for (let item of _data["loanAndPropertyInformationOtherMortageLoans"])
          this.loanAndPropertyInformationOtherMortageLoans.push(
            UpdateLoanAndPropertyInformationOtherMortageLoanRequest.fromJS(item)
          );
      }
      if (Array.isArray(_data["loanAndPropertyInformationRentalIncomes"])) {
        this.loanAndPropertyInformationRentalIncomes = [] as any;
        for (let item of _data["loanAndPropertyInformationRentalIncomes"])
          this.loanAndPropertyInformationRentalIncomes.push(
            UpdateLoanAndPropertyInformationRentalIncomeRequest.fromJS(item)
          );
      }
      if (Array.isArray(_data["loanAndPropertyInformations"])) {
        this.loanAndPropertyInformations = [] as any;
        for (let item of _data["loanAndPropertyInformations"])
          this.loanAndPropertyInformations.push(
            LoanAndPropertyInformationDetail.fromJS(item)
          );
      }
      if (Array.isArray(_data["loanOriginatorInformations"])) {
        this.loanOriginatorInformations = [] as any;
        for (let item of _data["loanOriginatorInformations"])
          this.loanOriginatorInformations.push(
            UpdateLoanOriginatorInformationRequest.fromJS(item)
          );
      }
      if (Array.isArray(_data["militaryServices"])) {
        this.militaryServices = [] as any;
        for (let item of _data["militaryServices"])
          this.militaryServices.push(UpdateMilitaryServiceRequest.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetPdfDataModel {
    data = typeof data === "object" ? data : {};
    let result = new GetPdfDataModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["applicationId"] = this.applicationId;
    data["firstName1a1"] = this.firstName1a1;
    data["middleName1a2"] = this.middleName1a2;
    data["lastName1a3"] = this.lastName1a3;
    data["suffix1a4"] = this.suffix1a4;
    data["alternateFirstName1a21"] = this.alternateFirstName1a21;
    data["alternateMiddleName1a22"] = this.alternateMiddleName1a22;
    data["alternateLastName1a23"] = this.alternateLastName1a23;
    data["alternateSuffix1a24"] = this.alternateSuffix1a24;
    data["ssn1a3"] = this.ssn1a3;
    data["dob1a4"] = this.dob1a4 ? this.dob1a4.toISOString() : <any>undefined;
    data["citizenshipType1a5"] = this.citizenshipType1a5;
    data["maritialStatusId1a7"] = this.maritialStatusId1a7;
    data["dependents1a8"] = this.dependents1a8;
    data["ages1a81"] = this.ages1a81;
    data["homePhone1a9"] = this.homePhone1a9;
    data["cellPhone1a10"] = this.cellPhone1a10;
    data["workPhone1a11"] = this.workPhone1a11;
    data["ext1a111"] = this.ext1a111;
    data["email1a12"] = this.email1a12;
    data["currentStreet1a131"] = this.currentStreet1a131;
    data["currentUnit1a132"] = this.currentUnit1a132;
    data["currentZip1a135"] = this.currentZip1a135;
    data["currentCountry1a136"] = this.currentCountry1a136;
    data["currentState1a134"] = this.currentState1a134;
    data["currentCity1a133"] = this.currentCity1a133;
    data["currentYears1a14"] = this.currentYears1a14;
    data["currentMonths1a15"] = this.currentMonths1a15;
    data["currentHousingType1a141"] = this.currentHousingType1a141;
    data["currentRent1a142"] = this.currentRent1a142;
    data["formerStreet1a151"] = this.formerStreet1a151;
    data["formerUnit1a152"] = this.formerUnit1a152;
    data["formerZip1a155"] = this.formerZip1a155;
    data["formerCountry1a156"] = this.formerCountry1a156;
    data["formerState1a154"] = this.formerState1a154;
    data["formerCity1a153"] = this.formerCity1a153;
    data["formerYears1a16"] = this.formerYears1a16;
    data["formerMonths1a161"] = this.formerMonths1a161;
    data["formerHousingType1a161"] = this.formerHousingType1a161;
    data["formerRent1a162"] = this.formerRent1a162;
    data["mailingStreet1a171"] = this.mailingStreet1a171;
    data["mailingUnit1a172"] = this.mailingUnit1a172;
    data["mailingZip1a175"] = this.mailingZip1a175;
    data["mailingCountry1a176"] = this.mailingCountry1a176;
    data["mailingState1a174"] = this.mailingState1a174;
    data["mailingCity1a173"] = this.mailingCity1a173;
    data["application"] = this.application
      ? this.application.toJSON()
      : <any>undefined;
    if (Array.isArray(this.additionalEmploymentDetails)) {
      data["additionalEmploymentDetails"] = [];
      for (let item of this.additionalEmploymentDetails)
        data["additionalEmploymentDetails"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationDeclarationQuestionDetail)) {
      data["applicationDeclarationQuestionDetail"] = [];
      for (let item of this.applicationDeclarationQuestionDetail)
        data["applicationDeclarationQuestionDetail"].push(item.toJSON());
    }
    if (Array.isArray(this.declarationQuestions)) {
      data["declarationQuestions"] = [];
      for (let item of this.declarationQuestions)
        data["declarationQuestions"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationEmployementDetails)) {
      data["applicationEmployementDetails"] = [];
      for (let item of this.applicationEmployementDetails)
        data["applicationEmployementDetails"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationFinancialAssets)) {
      data["applicationFinancialAssets"] = [];
      for (let item of this.applicationFinancialAssets)
        data["applicationFinancialAssets"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationFinancialLaibilities)) {
      data["applicationFinancialLaibilities"] = [];
      for (let item of this.applicationFinancialLaibilities)
        data["applicationFinancialLaibilities"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationFinancialOtherAssets)) {
      data["applicationFinancialOtherAssets"] = [];
      for (let item of this.applicationFinancialOtherAssets)
        data["applicationFinancialOtherAssets"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationFinancialOtherLaibilities)) {
      data["applicationFinancialOtherLaibilities"] = [];
      for (let item of this.applicationFinancialOtherLaibilities)
        data["applicationFinancialOtherLaibilities"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationFinancialRealEstates)) {
      data["applicationFinancialRealEstates"] = [];
      for (let item of this.applicationFinancialRealEstates)
        data["applicationFinancialRealEstates"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationIncomeSources)) {
      data["applicationIncomeSources"] = [];
      for (let item of this.applicationIncomeSources)
        data["applicationIncomeSources"].push(item.toJSON());
    }
    if (Array.isArray(this.applicationPreviousEmployementDetails)) {
      data["applicationPreviousEmployementDetails"] = [];
      for (let item of this.applicationPreviousEmployementDetails)
        data["applicationPreviousEmployementDetails"].push(item.toJSON());
    }
    if (Array.isArray(this.demographicInformations)) {
      data["demographicInformations"] = [];
      for (let item of this.demographicInformations)
        data["demographicInformations"].push(item.toJSON());
    }
    if (Array.isArray(this.loanAndPropertyInformationGifts)) {
      data["loanAndPropertyInformationGifts"] = [];
      for (let item of this.loanAndPropertyInformationGifts)
        data["loanAndPropertyInformationGifts"].push(item.toJSON());
    }
    if (Array.isArray(this.loanAndPropertyInformationOtherMortageLoans)) {
      data["loanAndPropertyInformationOtherMortageLoans"] = [];
      for (let item of this.loanAndPropertyInformationOtherMortageLoans)
        data["loanAndPropertyInformationOtherMortageLoans"].push(item.toJSON());
    }
    if (Array.isArray(this.loanAndPropertyInformationRentalIncomes)) {
      data["loanAndPropertyInformationRentalIncomes"] = [];
      for (let item of this.loanAndPropertyInformationRentalIncomes)
        data["loanAndPropertyInformationRentalIncomes"].push(item.toJSON());
    }
    if (Array.isArray(this.loanAndPropertyInformations)) {
      data["loanAndPropertyInformations"] = [];
      for (let item of this.loanAndPropertyInformations)
        data["loanAndPropertyInformations"].push(item.toJSON());
    }
    if (Array.isArray(this.loanOriginatorInformations)) {
      data["loanOriginatorInformations"] = [];
      for (let item of this.loanOriginatorInformations)
        data["loanOriginatorInformations"].push(item.toJSON());
    }
    if (Array.isArray(this.militaryServices)) {
      data["militaryServices"] = [];
      for (let item of this.militaryServices)
        data["militaryServices"].push(item.toJSON());
    }
    return data;
  }

  clone(): GetPdfDataModel {
    const json = this.toJSON();
    let result = new GetPdfDataModel();
    result.init(json);
    return result;
  }
}

export interface IGetPdfDataModel {
  id: number;
  applicationId: number;
  firstName1a1: string | undefined;
  middleName1a2: string | undefined;
  lastName1a3: string | undefined;
  suffix1a4: string | undefined;
  alternateFirstName1a21: string | undefined;
  alternateMiddleName1a22: string | undefined;
  alternateLastName1a23: string | undefined;
  alternateSuffix1a24: string | undefined;
  ssn1a3: string | undefined;
  dob1a4: moment.Moment | undefined;
  citizenshipType1a5: string | undefined;
  maritialStatusId1a7: number;
  dependents1a8: number | undefined;
  ages1a81: string | undefined;
  homePhone1a9: string | undefined;
  cellPhone1a10: string | undefined;
  workPhone1a11: string | undefined;
  ext1a111: string | undefined;
  email1a12: string | undefined;
  currentStreet1a131: string | undefined;
  currentUnit1a132: string | undefined;
  currentZip1a135: string | undefined;
  currentCountry1a136: string | undefined;
  currentState1a134: string | undefined;
  currentCity1a133: string | undefined;
  currentYears1a14: number | undefined;
  currentMonths1a15: number | undefined;
  currentHousingType1a141: string | undefined;
  currentRent1a142: number | undefined;
  formerStreet1a151: string | undefined;
  formerUnit1a152: string | undefined;
  formerZip1a155: string | undefined;
  formerCountry1a156: string | undefined;
  formerState1a154: string | undefined;
  formerCity1a153: string | undefined;
  formerYears1a16: number | undefined;
  formerMonths1a161: number | undefined;
  formerHousingType1a161: string | undefined;
  formerRent1a162: number | undefined;
  mailingStreet1a171: string | undefined;
  mailingUnit1a172: string | undefined;
  mailingZip1a175: string | undefined;
  mailingCountry1a176: string | undefined;
  mailingState1a174: string | undefined;
  mailingCity1a173: string | undefined;
  application: ApplicationDetail;
  additionalEmploymentDetails: AdditionalEmploymentDetail[] | undefined;
  applicationDeclarationQuestionDetail: DeclarationCategory[] | undefined;
  declarationQuestions: ApplicationDeclarationQuestion[] | undefined;
  applicationEmployementDetails: ApplicationEmployementDetail[] | undefined;
  applicationFinancialAssets: ApplicationFinancialAsset[] | undefined;
  applicationFinancialLaibilities:
    | ApplicationFinancialLiabilityDetail[]
    | undefined;
  applicationFinancialOtherAssets:
    | ApplicationFinancialOtherAssetDetail[]
    | undefined;
  applicationFinancialOtherLaibilities:
    | ApplicationFinancialOtherLaibilityDetail[]
    | undefined;
  applicationFinancialRealEstates: FinancialRealEstateDetail[] | undefined;
  applicationIncomeSources: ApplicationIncomeSourceDetail[] | undefined;
  applicationPreviousEmployementDetails:
    | PreviousEmployementDetail[]
    | undefined;
  demographicInformations: DemographicInformationDetail[] | undefined;
  loanAndPropertyInformationGifts:
    | LoanAndPropertyInformationGiftDetail[]
    | undefined;
  loanAndPropertyInformationOtherMortageLoans:
    | UpdateLoanAndPropertyInformationOtherMortageLoanRequest[]
    | undefined;
  loanAndPropertyInformationRentalIncomes:
    | UpdateLoanAndPropertyInformationRentalIncomeRequest[]
    | undefined;
  loanAndPropertyInformations: LoanAndPropertyInformationDetail[] | undefined;
  loanOriginatorInformations:
    | UpdateLoanOriginatorInformationRequest[]
    | undefined;
  militaryServices: UpdateMilitaryServiceRequest[] | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;

  constructor(data?: IGetRoleForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.role = _data["role"]
        ? RoleEditDto.fromJS(_data["role"])
        : <any>undefined;
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions.push(FlatPermissionDto.fromJS(item));
      }
      if (Array.isArray(_data["grantedPermissionNames"])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data["grantedPermissionNames"])
          this.grantedPermissionNames.push(item);
      }
    }
  }

  static fromJS(data: any): GetRoleForEditOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetRoleForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["role"] = this.role ? this.role.toJSON() : <any>undefined;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item.toJSON());
    }
    if (Array.isArray(this.grantedPermissionNames)) {
      data["grantedPermissionNames"] = [];
      for (let item of this.grantedPermissionNames)
        data["grantedPermissionNames"].push(item);
    }
    return data;
  }

  clone(): GetRoleForEditOutput {
    const json = this.toJSON();
    let result = new GetRoleForEditOutput();
    result.init(json);
    return result;
  }
}

export interface IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {
  constructor(data?: IICustomAttributeProvider) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): ICustomAttributeProvider {
    data = typeof data === "object" ? data : {};
    let result = new ICustomAttributeProvider();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }

  clone(): ICustomAttributeProvider {
    const json = this.toJSON();
    let result = new ICustomAttributeProvider();
    result.init(json);
    return result;
  }
}

export interface IICustomAttributeProvider {}

export class Incomesource1 implements IIncomesource1 {
  id: number;
  name: string | undefined;
  additionalincomes: Additionalincome[] | undefined;

  constructor(data?: IIncomesource1) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["additionalincomes"])) {
        this.additionalincomes = [] as any;
        for (let item of _data["additionalincomes"])
          this.additionalincomes.push(Additionalincome.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Incomesource1 {
    data = typeof data === "object" ? data : {};
    let result = new Incomesource1();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.additionalincomes)) {
      data["additionalincomes"] = [];
      for (let item of this.additionalincomes)
        data["additionalincomes"].push(item.toJSON());
    }
    return data;
  }

  clone(): Incomesource1 {
    const json = this.toJSON();
    let result = new Incomesource1();
    result.init(json);
    return result;
  }
}

export interface IIncomesource1 {
  id: number;
  name: string | undefined;
  additionalincomes: Additionalincome[] | undefined;
}

export class IntPtr implements IIntPtr {
  constructor(data?: IIntPtr) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): IntPtr {
    data = typeof data === "object" ? data : {};
    let result = new IntPtr();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }

  clone(): IntPtr {
    const json = this.toJSON();
    let result = new IntPtr();
    result.init(json);
    return result;
  }
}

export interface IIntPtr {}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
  tenancyName: string;

  constructor(data?: IIsTenantAvailableInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
    }
  }

  static fromJS(data: any): IsTenantAvailableInput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    return data;
  }

  clone(): IsTenantAvailableInput {
    const json = this.toJSON();
    let result = new IsTenantAvailableInput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableInput {
  tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;

  constructor(data?: IIsTenantAvailableOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data["state"];
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): IsTenantAvailableOutput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["state"] = this.state;
    data["tenantId"] = this.tenantId;
    return data;
  }

  clone(): IsTenantAvailableOutput {
    const json = this.toJSON();
    let result = new IsTenantAvailableOutput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;
}

export enum LayoutKind {
  _0 = 0,
  _2 = 2,
  _3 = 3,
}

export class LoanAndPropertyInformationDetail
  implements ILoanAndPropertyInformationDetail {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  country4a36: string | undefined;
  state4a34: string | undefined;
  city4a33: string | undefined;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancy4a6: string | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;

  constructor(data?: ILoanAndPropertyInformationDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanAmount4a1 = _data["loanAmount4a1"];
      this.loanPurpose4a2 = _data["loanPurpose4a2"];
      this.propertyStreet4a31 = _data["propertyStreet4a31"];
      this.propertyUnitNo4a32 = _data["propertyUnitNo4a32"];
      this.propertyZip4a35 = _data["propertyZip4a35"];
      this.country4a36 = _data["country4a36"];
      this.state4a34 = _data["state4a34"];
      this.city4a33 = _data["city4a33"];
      this.propertyNumberUnits4a4 = _data["propertyNumberUnits4a4"];
      this.propertyValue4a5 = _data["propertyValue4a5"];
      this.loanPropertyOccupancy4a6 = _data["loanPropertyOccupancy4a6"];
      this.fhaSecondaryResidance4a61 = _data["fhaSecondaryResidance4a61"];
      this.isMixedUseProperty4a7 = _data["isMixedUseProperty4a7"];
      this.isManufacturedHome4a8 = _data["isManufacturedHome4a8"];
    }
  }

  static fromJS(data: any): LoanAndPropertyInformationDetail {
    data = typeof data === "object" ? data : {};
    let result = new LoanAndPropertyInformationDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanAmount4a1"] = this.loanAmount4a1;
    data["loanPurpose4a2"] = this.loanPurpose4a2;
    data["propertyStreet4a31"] = this.propertyStreet4a31;
    data["propertyUnitNo4a32"] = this.propertyUnitNo4a32;
    data["propertyZip4a35"] = this.propertyZip4a35;
    data["country4a36"] = this.country4a36;
    data["state4a34"] = this.state4a34;
    data["city4a33"] = this.city4a33;
    data["propertyNumberUnits4a4"] = this.propertyNumberUnits4a4;
    data["propertyValue4a5"] = this.propertyValue4a5;
    data["loanPropertyOccupancy4a6"] = this.loanPropertyOccupancy4a6;
    data["fhaSecondaryResidance4a61"] = this.fhaSecondaryResidance4a61;
    data["isMixedUseProperty4a7"] = this.isMixedUseProperty4a7;
    data["isManufacturedHome4a8"] = this.isManufacturedHome4a8;
    return data;
  }

  clone(): LoanAndPropertyInformationDetail {
    const json = this.toJSON();
    let result = new LoanAndPropertyInformationDetail();
    result.init(json);
    return result;
  }
}

export interface ILoanAndPropertyInformationDetail {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  country4a36: string | undefined;
  state4a34: string | undefined;
  city4a33: string | undefined;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancy4a6: string | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;
}

export class LoanAndPropertyInformationGiftDetail
  implements ILoanAndPropertyInformationGiftDetail {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftType4d1: string | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;

  constructor(data?: ILoanAndPropertyInformationGiftDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanPropertyGiftType4d1 = _data["loanPropertyGiftType4d1"];
      this.deposited4d2 = _data["deposited4d2"];
      this.source4d3 = _data["source4d3"];
      this.value4d4 = _data["value4d4"];
    }
  }

  static fromJS(data: any): LoanAndPropertyInformationGiftDetail {
    data = typeof data === "object" ? data : {};
    let result = new LoanAndPropertyInformationGiftDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanPropertyGiftType4d1"] = this.loanPropertyGiftType4d1;
    data["deposited4d2"] = this.deposited4d2;
    data["source4d3"] = this.source4d3;
    data["value4d4"] = this.value4d4;
    return data;
  }

  clone(): LoanAndPropertyInformationGiftDetail {
    const json = this.toJSON();
    let result = new LoanAndPropertyInformationGiftDetail();
    result.init(json);
    return result;
  }
}

export interface ILoanAndPropertyInformationGiftDetail {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftType4d1: string | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;
}

export class LoanApplicationDto implements ILoanApplicationDto {
  id: number | undefined;
  loanDetails: LoanDetailDto;
  personalInformation: PersonalInformationDto;
  expenses: ExpensesDto;
  manualAssetEntries: ManualAssetEntryDto[] | undefined;
  employmentIncome: EmploymentIncomeDto;
  orderCredit: CreditAuthAgreementDto;
  additionalDetails: AdditionalDetailsDto;
  eConsent: EConsentDto;
  declaration: DeclarationDto;

  constructor(data?: ILoanApplicationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.loanDetails = _data["loanDetails"]
        ? LoanDetailDto.fromJS(_data["loanDetails"])
        : <any>undefined;
      this.personalInformation = _data["personalInformation"]
        ? PersonalInformationDto.fromJS(_data["personalInformation"])
        : <any>undefined;
      this.expenses = _data["expenses"]
        ? ExpensesDto.fromJS(_data["expenses"])
        : <any>undefined;
      if (Array.isArray(_data["manualAssetEntries"])) {
        this.manualAssetEntries = [] as any;
        for (let item of _data["manualAssetEntries"])
          this.manualAssetEntries.push(ManualAssetEntryDto.fromJS(item));
      }
      this.employmentIncome = _data["employmentIncome"]
        ? EmploymentIncomeDto.fromJS(_data["employmentIncome"])
        : <any>undefined;
      this.orderCredit = _data["orderCredit"]
        ? CreditAuthAgreementDto.fromJS(_data["orderCredit"])
        : <any>undefined;
      this.additionalDetails = _data["additionalDetails"]
        ? AdditionalDetailsDto.fromJS(_data["additionalDetails"])
        : <any>undefined;
      this.eConsent = _data["eConsent"]
        ? EConsentDto.fromJS(_data["eConsent"])
        : <any>undefined;
      this.declaration = _data["declaration"]
        ? DeclarationDto.fromJS(_data["declaration"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): LoanApplicationDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanApplicationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["loanDetails"] = this.loanDetails
      ? this.loanDetails.toJSON()
      : <any>undefined;
    data["personalInformation"] = this.personalInformation
      ? this.personalInformation.toJSON()
      : <any>undefined;
    data["expenses"] = this.expenses ? this.expenses.toJSON() : <any>undefined;
    if (Array.isArray(this.manualAssetEntries)) {
      data["manualAssetEntries"] = [];
      for (let item of this.manualAssetEntries)
        data["manualAssetEntries"].push(item.toJSON());
    }
    data["employmentIncome"] = this.employmentIncome
      ? this.employmentIncome.toJSON()
      : <any>undefined;
    data["orderCredit"] = this.orderCredit
      ? this.orderCredit.toJSON()
      : <any>undefined;
    data["additionalDetails"] = this.additionalDetails
      ? this.additionalDetails.toJSON()
      : <any>undefined;
    data["eConsent"] = this.eConsent ? this.eConsent.toJSON() : <any>undefined;
    data["declaration"] = this.declaration
      ? this.declaration.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): LoanApplicationDto {
    const json = this.toJSON();
    let result = new LoanApplicationDto();
    result.init(json);
    return result;
  }
}

export interface ILoanApplicationDto {
  id: number | undefined;
  loanDetails: LoanDetailDto;
  personalInformation: PersonalInformationDto;
  expenses: ExpensesDto;
  manualAssetEntries: ManualAssetEntryDto[] | undefined;
  employmentIncome: EmploymentIncomeDto;
  orderCredit: CreditAuthAgreementDto;
  additionalDetails: AdditionalDetailsDto;
  eConsent: EConsentDto;
  declaration: DeclarationDto;
}

export class LoanApplicationDtoPagedResultDto
  implements ILoanApplicationDtoPagedResultDto {
  items: LoanApplicationDto[] | undefined;
  totalCount: number;

  constructor(data?: ILoanApplicationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(LoanApplicationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): LoanApplicationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanApplicationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): LoanApplicationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new LoanApplicationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ILoanApplicationDtoPagedResultDto {
  items: LoanApplicationDto[] | undefined;
  totalCount: number;
}

export class LoanDetailDto implements ILoanDetailDto {
  id: number | undefined;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: string | undefined;
  whatStageAreyouIn: number | undefined;
  referredBy: string | undefined;
  estimatedAnnualTaxes: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  address: string | undefined;
  unit: string | undefined;
  zipCode: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  newConstruction: boolean | undefined;
  bankOwned: boolean | undefined;
  contractDate: string | undefined;
  creditScore: string | undefined;
  firstName: string | undefined;
  middleName: string | undefined;
  lastName: string | undefined;
  phoneNumber: string | undefined;
  emailAddress: string | undefined;
  typeOfHome: number | undefined;
  hoaDues: number | undefined;

  constructor(data?: ILoanDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isWorkingWithOfficer = _data["isWorkingWithOfficer"];
      this.loanOfficerId = _data["loanOfficerId"];
      this.whatStageAreyouIn = _data["whatStageAreyouIn"];
      this.referredBy = _data["referredBy"];
      this.estimatedAnnualTaxes = _data["estimatedAnnualTaxes"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.purposeOfLoan = _data["purposeOfLoan"];
      this.estimatedValue = _data["estimatedValue"];
      this.currentLoanAmount = _data["currentLoanAmount"];
      this.requestedLoanAmount = _data["requestedLoanAmount"];
      this.estimatedPurchasePrice = _data["estimatedPurchasePrice"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.sourceOfDownPayment = _data["sourceOfDownPayment"];
      this.giftAmount = _data["giftAmount"];
      this.giftExplanation = _data["giftExplanation"];
      this.haveSecondMortgage = _data["haveSecondMortgage"];
      this.secondMortgageAmount = _data["secondMortgageAmount"];
      this.payLoanWithNewLoan = _data["payLoanWithNewLoan"];
      this.refinancingCurrentHome = _data["refinancingCurrentHome"];
      this.yearAcquired = _data["yearAcquired"];
      this.originalPrice = _data["originalPrice"];
      this.address = _data["address"];
      this.unit = _data["unit"];
      this.zipCode = _data["zipCode"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.propertyTypeId = _data["propertyTypeId"];
      this.propertyUseId = _data["propertyUseId"];
      this.startedLookingForNewHome = _data["startedLookingForNewHome"];
      this.newConstruction = _data["newConstruction"];
      this.bankOwned = _data["bankOwned"];
      this.contractDate = _data["contractDate"];
      this.creditScore = _data["creditScore"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.phoneNumber = _data["phoneNumber"];
      this.emailAddress = _data["emailAddress"];
      this.typeOfHome = _data["typeOfHome"];
      this.hoaDues = _data["hoaDues"];
    }
  }

  static fromJS(data: any): LoanDetailDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isWorkingWithOfficer"] = this.isWorkingWithOfficer;
    data["loanOfficerId"] = this.loanOfficerId;
    data["whatStageAreyouIn"] = this.whatStageAreyouIn;
    data["referredBy"] = this.referredBy;
    data["estimatedAnnualTaxes"] = this.estimatedAnnualTaxes;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["purposeOfLoan"] = this.purposeOfLoan;
    data["estimatedValue"] = this.estimatedValue;
    data["currentLoanAmount"] = this.currentLoanAmount;
    data["requestedLoanAmount"] = this.requestedLoanAmount;
    data["estimatedPurchasePrice"] = this.estimatedPurchasePrice;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["sourceOfDownPayment"] = this.sourceOfDownPayment;
    data["giftAmount"] = this.giftAmount;
    data["giftExplanation"] = this.giftExplanation;
    data["haveSecondMortgage"] = this.haveSecondMortgage;
    data["secondMortgageAmount"] = this.secondMortgageAmount;
    data["payLoanWithNewLoan"] = this.payLoanWithNewLoan;
    data["refinancingCurrentHome"] = this.refinancingCurrentHome;
    data["yearAcquired"] = this.yearAcquired;
    data["originalPrice"] = this.originalPrice;
    data["address"] = this.address;
    data["unit"] = this.unit;
    data["zipCode"] = this.zipCode;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["propertyTypeId"] = this.propertyTypeId;
    data["propertyUseId"] = this.propertyUseId;
    data["startedLookingForNewHome"] = this.startedLookingForNewHome;
    data["newConstruction"] = this.newConstruction;
    data["bankOwned"] = this.bankOwned;
    data["contractDate"] = this.contractDate;
    data["creditScore"] = this.creditScore;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["phoneNumber"] = this.phoneNumber;
    data["emailAddress"] = this.emailAddress;
    data["typeOfHome"] = this.typeOfHome;
    data["hoaDues"] = this.hoaDues;
    return data;
  }

  clone(): LoanDetailDto {
    const json = this.toJSON();
    let result = new LoanDetailDto();
    result.init(json);
    return result;
  }
}

export interface ILoanDetailDto {
  id: number | undefined;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: string | undefined;
  whatStageAreyouIn: number | undefined;
  referredBy: string | undefined;
  estimatedAnnualTaxes: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  address: string | undefined;
  unit: string | undefined;
  zipCode: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  newConstruction: boolean | undefined;
  bankOwned: boolean | undefined;
  contractDate: string | undefined;
  creditScore: string | undefined;
  firstName: string | undefined;
  middleName: string | undefined;
  lastName: string | undefined;
  phoneNumber: string | undefined;
  emailAddress: string | undefined;
  typeOfHome: number | undefined;
  hoaDues: number | undefined;
}

export class LoanDetailDtoPagedResultDto
  implements ILoanDetailDtoPagedResultDto {
  items: LoanDetailDto[] | undefined;
  totalCount: number;

  constructor(data?: ILoanDetailDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(LoanDetailDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): LoanDetailDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanDetailDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): LoanDetailDtoPagedResultDto {
    const json = this.toJSON();
    let result = new LoanDetailDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ILoanDetailDtoPagedResultDto {
  items: LoanDetailDto[] | undefined;
  totalCount: number;
}

export class LoanListDto implements ILoanListDto {
  id: number;
  borrower: string | undefined;
  fileName: string | undefined;
  loanStatus: string | undefined;
  statusDate: string | undefined;
  estClose: string | undefined;
  rateLoc: string | undefined;
  processor: string | undefined;
  originator: string | undefined;
  contact: string | undefined;

  constructor(data?: ILoanListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.borrower = _data["borrower"];
      this.fileName = _data["fileName"];
      this.loanStatus = _data["loanStatus"];
      this.statusDate = _data["statusDate"];
      this.estClose = _data["estClose"];
      this.rateLoc = _data["rateLoc"];
      this.processor = _data["processor"];
      this.originator = _data["originator"];
      this.contact = _data["contact"];
    }
  }

  static fromJS(data: any): LoanListDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["borrower"] = this.borrower;
    data["fileName"] = this.fileName;
    data["loanStatus"] = this.loanStatus;
    data["statusDate"] = this.statusDate;
    data["estClose"] = this.estClose;
    data["rateLoc"] = this.rateLoc;
    data["processor"] = this.processor;
    data["originator"] = this.originator;
    data["contact"] = this.contact;
    return data;
  }

  clone(): LoanListDto {
    const json = this.toJSON();
    let result = new LoanListDto();
    result.init(json);
    return result;
  }
}

export interface ILoanListDto {
  id: number;
  borrower: string | undefined;
  fileName: string | undefined;
  loanStatus: string | undefined;
  statusDate: string | undefined;
  estClose: string | undefined;
  rateLoc: string | undefined;
  processor: string | undefined;
  originator: string | undefined;
  contact: string | undefined;
}

export class LoanListDtoPagedResultDto implements ILoanListDtoPagedResultDto {
  items: LoanListDto[] | undefined;
  totalCount: number;

  constructor(data?: ILoanListDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(LoanListDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): LoanListDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new LoanListDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): LoanListDtoPagedResultDto {
    const json = this.toJSON();
    let result = new LoanListDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ILoanListDtoPagedResultDto {
  items: LoanListDto[] | undefined;
  totalCount: number;
}

export class Loanapplication implements ILoanapplication {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  loanDetailId: number | undefined;
  additionalDetailId: number | undefined;
  personalDetailId: number | undefined;
  creditAuthAgreementId: number | undefined;
  consentDetailId: number | undefined;
  expenseId: number | undefined;
  updatedOn: moment.Moment;
  additionalDetail: Additionaldetail;
  consentDetail: Consentdetail;
  creditAuthAgreement: Creditauthagreement;
  expense: Expense;
  loanDetail: Loandetail;
  personalDetail: Personaldetail;
  additionalincomes: Additionalincome[] | undefined;
  borroweremploymentinformations: Borroweremploymentinformation[] | undefined;
  borrowermonthlyincomes: Borrowermonthlyincome[] | undefined;
  declarationborroweredemographicsinformations:
    | Declarationborroweredemographicsinformation[]
    | undefined;
  declarations: Declaration[] | undefined;
  manualassetentries: Manualassetentry[] | undefined;

  constructor(data?: ILoanapplication) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.loanDetailId = _data["loanDetailId"];
      this.additionalDetailId = _data["additionalDetailId"];
      this.personalDetailId = _data["personalDetailId"];
      this.creditAuthAgreementId = _data["creditAuthAgreementId"];
      this.consentDetailId = _data["consentDetailId"];
      this.expenseId = _data["expenseId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
      this.additionalDetail = _data["additionalDetail"]
        ? Additionaldetail.fromJS(_data["additionalDetail"])
        : <any>undefined;
      this.consentDetail = _data["consentDetail"]
        ? Consentdetail.fromJS(_data["consentDetail"])
        : <any>undefined;
      this.creditAuthAgreement = _data["creditAuthAgreement"]
        ? Creditauthagreement.fromJS(_data["creditAuthAgreement"])
        : <any>undefined;
      this.expense = _data["expense"]
        ? Expense.fromJS(_data["expense"])
        : <any>undefined;
      this.loanDetail = _data["loanDetail"]
        ? Loandetail.fromJS(_data["loanDetail"])
        : <any>undefined;
      this.personalDetail = _data["personalDetail"]
        ? Personaldetail.fromJS(_data["personalDetail"])
        : <any>undefined;
      if (Array.isArray(_data["additionalincomes"])) {
        this.additionalincomes = [] as any;
        for (let item of _data["additionalincomes"])
          this.additionalincomes.push(Additionalincome.fromJS(item));
      }
      if (Array.isArray(_data["borroweremploymentinformations"])) {
        this.borroweremploymentinformations = [] as any;
        for (let item of _data["borroweremploymentinformations"])
          this.borroweremploymentinformations.push(
            Borroweremploymentinformation.fromJS(item)
          );
      }
      if (Array.isArray(_data["borrowermonthlyincomes"])) {
        this.borrowermonthlyincomes = [] as any;
        for (let item of _data["borrowermonthlyincomes"])
          this.borrowermonthlyincomes.push(Borrowermonthlyincome.fromJS(item));
      }
      if (
        Array.isArray(_data["declarationborroweredemographicsinformations"])
      ) {
        this.declarationborroweredemographicsinformations = [] as any;
        for (let item of _data["declarationborroweredemographicsinformations"])
          this.declarationborroweredemographicsinformations.push(
            Declarationborroweredemographicsinformation.fromJS(item)
          );
      }
      if (Array.isArray(_data["declarations"])) {
        this.declarations = [] as any;
        for (let item of _data["declarations"])
          this.declarations.push(Declaration.fromJS(item));
      }
      if (Array.isArray(_data["manualassetentries"])) {
        this.manualassetentries = [] as any;
        for (let item of _data["manualassetentries"])
          this.manualassetentries.push(Manualassetentry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Loanapplication {
    data = typeof data === "object" ? data : {};
    let result = new Loanapplication();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["loanDetailId"] = this.loanDetailId;
    data["additionalDetailId"] = this.additionalDetailId;
    data["personalDetailId"] = this.personalDetailId;
    data["creditAuthAgreementId"] = this.creditAuthAgreementId;
    data["consentDetailId"] = this.consentDetailId;
    data["expenseId"] = this.expenseId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    data["additionalDetail"] = this.additionalDetail
      ? this.additionalDetail.toJSON()
      : <any>undefined;
    data["consentDetail"] = this.consentDetail
      ? this.consentDetail.toJSON()
      : <any>undefined;
    data["creditAuthAgreement"] = this.creditAuthAgreement
      ? this.creditAuthAgreement.toJSON()
      : <any>undefined;
    data["expense"] = this.expense ? this.expense.toJSON() : <any>undefined;
    data["loanDetail"] = this.loanDetail
      ? this.loanDetail.toJSON()
      : <any>undefined;
    data["personalDetail"] = this.personalDetail
      ? this.personalDetail.toJSON()
      : <any>undefined;
    if (Array.isArray(this.additionalincomes)) {
      data["additionalincomes"] = [];
      for (let item of this.additionalincomes)
        data["additionalincomes"].push(item.toJSON());
    }
    if (Array.isArray(this.borroweremploymentinformations)) {
      data["borroweremploymentinformations"] = [];
      for (let item of this.borroweremploymentinformations)
        data["borroweremploymentinformations"].push(item.toJSON());
    }
    if (Array.isArray(this.borrowermonthlyincomes)) {
      data["borrowermonthlyincomes"] = [];
      for (let item of this.borrowermonthlyincomes)
        data["borrowermonthlyincomes"].push(item.toJSON());
    }
    if (Array.isArray(this.declarationborroweredemographicsinformations)) {
      data["declarationborroweredemographicsinformations"] = [];
      for (let item of this.declarationborroweredemographicsinformations)
        data["declarationborroweredemographicsinformations"].push(
          item.toJSON()
        );
    }
    if (Array.isArray(this.declarations)) {
      data["declarations"] = [];
      for (let item of this.declarations)
        data["declarations"].push(item.toJSON());
    }
    if (Array.isArray(this.manualassetentries)) {
      data["manualassetentries"] = [];
      for (let item of this.manualassetentries)
        data["manualassetentries"].push(item.toJSON());
    }
    return data;
  }

  clone(): Loanapplication {
    const json = this.toJSON();
    let result = new Loanapplication();
    result.init(json);
    return result;
  }
}

export interface ILoanapplication {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  loanDetailId: number | undefined;
  additionalDetailId: number | undefined;
  personalDetailId: number | undefined;
  creditAuthAgreementId: number | undefined;
  consentDetailId: number | undefined;
  expenseId: number | undefined;
  updatedOn: moment.Moment;
  additionalDetail: Additionaldetail;
  consentDetail: Consentdetail;
  creditAuthAgreement: Creditauthagreement;
  expense: Expense;
  loanDetail: Loandetail;
  personalDetail: Personaldetail;
  additionalincomes: Additionalincome[] | undefined;
  borroweremploymentinformations: Borroweremploymentinformation[] | undefined;
  borrowermonthlyincomes: Borrowermonthlyincome[] | undefined;
  declarationborroweredemographicsinformations:
    | Declarationborroweredemographicsinformation[]
    | undefined;
  declarations: Declaration[] | undefined;
  manualassetentries: Manualassetentry[] | undefined;
}

export class Loandetail implements ILoandetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: number | undefined;
  referredBy: string | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  loanapplications: Loanapplication[] | undefined;

  constructor(data?: ILoandetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.isWorkingWithOfficer = _data["isWorkingWithOfficer"];
      this.loanOfficerId = _data["loanOfficerId"];
      this.referredBy = _data["referredBy"];
      this.purposeOfLoan = _data["purposeOfLoan"];
      this.estimatedValue = _data["estimatedValue"];
      this.currentLoanAmount = _data["currentLoanAmount"];
      this.requestedLoanAmount = _data["requestedLoanAmount"];
      this.estimatedPurchasePrice = _data["estimatedPurchasePrice"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.sourceOfDownPayment = _data["sourceOfDownPayment"];
      this.giftAmount = _data["giftAmount"];
      this.giftExplanation = _data["giftExplanation"];
      this.haveSecondMortgage = _data["haveSecondMortgage"];
      this.secondMortgageAmount = _data["secondMortgageAmount"];
      this.payLoanWithNewLoan = _data["payLoanWithNewLoan"];
      this.refinancingCurrentHome = _data["refinancingCurrentHome"];
      this.yearAcquired = _data["yearAcquired"];
      this.originalPrice = _data["originalPrice"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.propertyTypeId = _data["propertyTypeId"];
      this.propertyUseId = _data["propertyUseId"];
      this.startedLookingForNewHome = _data["startedLookingForNewHome"];
      if (Array.isArray(_data["loanapplications"])) {
        this.loanapplications = [] as any;
        for (let item of _data["loanapplications"])
          this.loanapplications.push(Loanapplication.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Loandetail {
    data = typeof data === "object" ? data : {};
    let result = new Loandetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["isWorkingWithOfficer"] = this.isWorkingWithOfficer;
    data["loanOfficerId"] = this.loanOfficerId;
    data["referredBy"] = this.referredBy;
    data["purposeOfLoan"] = this.purposeOfLoan;
    data["estimatedValue"] = this.estimatedValue;
    data["currentLoanAmount"] = this.currentLoanAmount;
    data["requestedLoanAmount"] = this.requestedLoanAmount;
    data["estimatedPurchasePrice"] = this.estimatedPurchasePrice;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["sourceOfDownPayment"] = this.sourceOfDownPayment;
    data["giftAmount"] = this.giftAmount;
    data["giftExplanation"] = this.giftExplanation;
    data["haveSecondMortgage"] = this.haveSecondMortgage;
    data["secondMortgageAmount"] = this.secondMortgageAmount;
    data["payLoanWithNewLoan"] = this.payLoanWithNewLoan;
    data["refinancingCurrentHome"] = this.refinancingCurrentHome;
    data["yearAcquired"] = this.yearAcquired;
    data["originalPrice"] = this.originalPrice;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["propertyTypeId"] = this.propertyTypeId;
    data["propertyUseId"] = this.propertyUseId;
    data["startedLookingForNewHome"] = this.startedLookingForNewHome;
    if (Array.isArray(this.loanapplications)) {
      data["loanapplications"] = [];
      for (let item of this.loanapplications)
        data["loanapplications"].push(item.toJSON());
    }
    return data;
  }

  clone(): Loandetail {
    const json = this.toJSON();
    let result = new Loandetail();
    result.init(json);
    return result;
  }
}

export interface ILoandetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isWorkingWithOfficer: boolean | undefined;
  loanOfficerId: number | undefined;
  referredBy: string | undefined;
  purposeOfLoan: number | undefined;
  estimatedValue: number | undefined;
  currentLoanAmount: number | undefined;
  requestedLoanAmount: number | undefined;
  estimatedPurchasePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  sourceOfDownPayment: number | undefined;
  giftAmount: number | undefined;
  giftExplanation: string | undefined;
  haveSecondMortgage: boolean | undefined;
  secondMortgageAmount: number | undefined;
  payLoanWithNewLoan: boolean | undefined;
  refinancingCurrentHome: boolean | undefined;
  yearAcquired: string | undefined;
  originalPrice: number | undefined;
  city: string | undefined;
  stateId: number | undefined;
  propertyTypeId: number | undefined;
  propertyUseId: number | undefined;
  startedLookingForNewHome: boolean | undefined;
  loanapplications: Loanapplication[] | undefined;
}

export class ManualAssetEntryDto implements IManualAssetEntryDto {
  id: number | undefined;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  stockAndBonds: StockAndBondViewModel[] | undefined;

  constructor(data?: IManualAssetEntryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.assetTypeId = _data["assetTypeId"];
      this.accountNumber = _data["accountNumber"];
      this.cashValue = _data["cashValue"];
      this.address = _data["address"];
      this.address2 = _data["address2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.description = _data["description"];
      this.name = _data["name"];
      this.bankName = _data["bankName"];
      this.propertyStatus = _data["propertyStatus"];
      this.propertyIsUsedAs = _data["propertyIsUsedAs"];
      this.propertyType = _data["propertyType"];
      this.presentMarketValue = _data["presentMarketValue"];
      this.outstandingMortgageBalance = _data["outstandingMortgageBalance"];
      this.monthlyMortgagePayment = _data["monthlyMortgagePayment"];
      this.purchasePrice = _data["purchasePrice"];
      this.grossRentalIncome = _data["grossRentalIncome"];
      this.taxesInsuranceAndOther = _data["taxesInsuranceAndOther"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      if (Array.isArray(_data["stockAndBonds"])) {
        this.stockAndBonds = [] as any;
        for (let item of _data["stockAndBonds"])
          this.stockAndBonds.push(StockAndBondViewModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ManualAssetEntryDto {
    data = typeof data === "object" ? data : {};
    let result = new ManualAssetEntryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["assetTypeId"] = this.assetTypeId;
    data["accountNumber"] = this.accountNumber;
    data["cashValue"] = this.cashValue;
    data["address"] = this.address;
    data["address2"] = this.address2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["description"] = this.description;
    data["name"] = this.name;
    data["bankName"] = this.bankName;
    data["propertyStatus"] = this.propertyStatus;
    data["propertyIsUsedAs"] = this.propertyIsUsedAs;
    data["propertyType"] = this.propertyType;
    data["presentMarketValue"] = this.presentMarketValue;
    data["outstandingMortgageBalance"] = this.outstandingMortgageBalance;
    data["monthlyMortgagePayment"] = this.monthlyMortgagePayment;
    data["purchasePrice"] = this.purchasePrice;
    data["grossRentalIncome"] = this.grossRentalIncome;
    data["taxesInsuranceAndOther"] = this.taxesInsuranceAndOther;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    if (Array.isArray(this.stockAndBonds)) {
      data["stockAndBonds"] = [];
      for (let item of this.stockAndBonds)
        data["stockAndBonds"].push(item.toJSON());
    }
    return data;
  }

  clone(): ManualAssetEntryDto {
    const json = this.toJSON();
    let result = new ManualAssetEntryDto();
    result.init(json);
    return result;
  }
}

export interface IManualAssetEntryDto {
  id: number | undefined;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number | undefined;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  stockAndBonds: StockAndBondViewModel[] | undefined;
}

export class ManualAssetEntryDtoPagedResultDto
  implements IManualAssetEntryDtoPagedResultDto {
  items: ManualAssetEntryDto[] | undefined;
  totalCount: number;

  constructor(data?: IManualAssetEntryDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(ManualAssetEntryDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): ManualAssetEntryDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new ManualAssetEntryDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): ManualAssetEntryDtoPagedResultDto {
    const json = this.toJSON();
    let result = new ManualAssetEntryDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IManualAssetEntryDtoPagedResultDto {
  items: ManualAssetEntryDto[] | undefined;
  totalCount: number;
}

export class Manualassetentry implements IManualassetentry {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  assetType: Assettype;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;
  state: State;
  stockandbonds: Stockandbond[] | undefined;

  constructor(data?: IManualassetentry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.assetTypeId = _data["assetTypeId"];
      this.accountNumber = _data["accountNumber"];
      this.cashValue = _data["cashValue"];
      this.address = _data["address"];
      this.address2 = _data["address2"];
      this.city = _data["city"];
      this.stateId = _data["stateId"];
      this.zipCode = _data["zipCode"];
      this.description = _data["description"];
      this.name = _data["name"];
      this.bankName = _data["bankName"];
      this.propertyStatus = _data["propertyStatus"];
      this.propertyIsUsedAs = _data["propertyIsUsedAs"];
      this.propertyType = _data["propertyType"];
      this.presentMarketValue = _data["presentMarketValue"];
      this.outstandingMortgageBalance = _data["outstandingMortgageBalance"];
      this.monthlyMortgagePayment = _data["monthlyMortgagePayment"];
      this.purchasePrice = _data["purchasePrice"];
      this.grossRentalIncome = _data["grossRentalIncome"];
      this.taxesInsuranceAndOther = _data["taxesInsuranceAndOther"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.borrowerTypeId = _data["borrowerTypeId"];
      this.assetType = _data["assetType"]
        ? Assettype.fromJS(_data["assetType"])
        : <any>undefined;
      this.borrowerType = _data["borrowerType"]
        ? Borrowertype.fromJS(_data["borrowerType"])
        : <any>undefined;
      this.loanApplication = _data["loanApplication"]
        ? Loanapplication.fromJS(_data["loanApplication"])
        : <any>undefined;
      this.state = _data["state"]
        ? State.fromJS(_data["state"])
        : <any>undefined;
      if (Array.isArray(_data["stockandbonds"])) {
        this.stockandbonds = [] as any;
        for (let item of _data["stockandbonds"])
          this.stockandbonds.push(Stockandbond.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Manualassetentry {
    data = typeof data === "object" ? data : {};
    let result = new Manualassetentry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["assetTypeId"] = this.assetTypeId;
    data["accountNumber"] = this.accountNumber;
    data["cashValue"] = this.cashValue;
    data["address"] = this.address;
    data["address2"] = this.address2;
    data["city"] = this.city;
    data["stateId"] = this.stateId;
    data["zipCode"] = this.zipCode;
    data["description"] = this.description;
    data["name"] = this.name;
    data["bankName"] = this.bankName;
    data["propertyStatus"] = this.propertyStatus;
    data["propertyIsUsedAs"] = this.propertyIsUsedAs;
    data["propertyType"] = this.propertyType;
    data["presentMarketValue"] = this.presentMarketValue;
    data["outstandingMortgageBalance"] = this.outstandingMortgageBalance;
    data["monthlyMortgagePayment"] = this.monthlyMortgagePayment;
    data["purchasePrice"] = this.purchasePrice;
    data["grossRentalIncome"] = this.grossRentalIncome;
    data["taxesInsuranceAndOther"] = this.taxesInsuranceAndOther;
    data["loanApplicationId"] = this.loanApplicationId;
    data["borrowerTypeId"] = this.borrowerTypeId;
    data["assetType"] = this.assetType
      ? this.assetType.toJSON()
      : <any>undefined;
    data["borrowerType"] = this.borrowerType
      ? this.borrowerType.toJSON()
      : <any>undefined;
    data["loanApplication"] = this.loanApplication
      ? this.loanApplication.toJSON()
      : <any>undefined;
    data["state"] = this.state ? this.state.toJSON() : <any>undefined;
    if (Array.isArray(this.stockandbonds)) {
      data["stockandbonds"] = [];
      for (let item of this.stockandbonds)
        data["stockandbonds"].push(item.toJSON());
    }
    return data;
  }

  clone(): Manualassetentry {
    const json = this.toJSON();
    let result = new Manualassetentry();
    result.init(json);
    return result;
  }
}

export interface IManualassetentry {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  assetTypeId: number;
  accountNumber: string | undefined;
  cashValue: number | undefined;
  address: string | undefined;
  address2: string | undefined;
  city: string | undefined;
  stateId: number;
  zipCode: string | undefined;
  description: string | undefined;
  name: string | undefined;
  bankName: string | undefined;
  propertyStatus: string | undefined;
  propertyIsUsedAs: string | undefined;
  propertyType: string | undefined;
  presentMarketValue: number | undefined;
  outstandingMortgageBalance: number | undefined;
  monthlyMortgagePayment: number | undefined;
  purchasePrice: number | undefined;
  grossRentalIncome: number | undefined;
  taxesInsuranceAndOther: number | undefined;
  loanApplicationId: number;
  borrowerTypeId: number;
  assetType: Assettype;
  borrowerType: Borrowertype;
  loanApplication: Loanapplication;
  state: State;
  stockandbonds: Stockandbond[] | undefined;
}

export class MemberInfo implements IMemberInfo {
  memberType: MemberTypes;
  declaringType: Type;
  reflectedType: Type;
  readonly name: string | undefined;
  module: Module;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;

  constructor(data?: IMemberInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.memberType = _data["memberType"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      (<any>this).name = _data["name"];
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
    }
  }

  static fromJS(data: any): MemberInfo {
    data = typeof data === "object" ? data : {};
    let result = new MemberInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["memberType"] = this.memberType;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["name"] = this.name;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    return data;
  }

  clone(): MemberInfo {
    const json = this.toJSON();
    let result = new MemberInfo();
    result.init(json);
    return result;
  }
}

export interface IMemberInfo {
  memberType: MemberTypes;
  declaringType: Type;
  reflectedType: Type;
  name: string | undefined;
  module: Module;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
}

export enum MemberTypes {
  _1 = 1,
  _2 = 2,
  _4 = 4,
  _8 = 8,
  _16 = 16,
  _32 = 32,
  _64 = 64,
  _128 = 128,
  _191 = 191,
}

export enum MethodAttributes {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7,
  _8 = 8,
  _16 = 16,
  _32 = 32,
  _64 = 64,
  _128 = 128,
  _256 = 256,
  _512 = 512,
  _1024 = 1024,
  _2048 = 2048,
  _4096 = 4096,
  _8192 = 8192,
  _16384 = 16384,
  _32768 = 32768,
  _53248 = 53248,
}

export class MethodBase implements IMethodBase {
  memberType: MemberTypes;
  readonly name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  attributes: MethodAttributes;
  methodImplementationFlags: MethodImplAttributes;
  callingConvention: CallingConventions;
  readonly isAbstract: boolean;
  readonly isConstructor: boolean;
  readonly isFinal: boolean;
  readonly isHideBySig: boolean;
  readonly isSpecialName: boolean;
  readonly isStatic: boolean;
  readonly isVirtual: boolean;
  readonly isAssembly: boolean;
  readonly isFamily: boolean;
  readonly isFamilyAndAssembly: boolean;
  readonly isFamilyOrAssembly: boolean;
  readonly isPrivate: boolean;
  readonly isPublic: boolean;
  readonly isConstructedGenericMethod: boolean;
  readonly isGenericMethod: boolean;
  readonly isGenericMethodDefinition: boolean;
  readonly containsGenericParameters: boolean;
  methodHandle: RuntimeMethodHandle;
  readonly isSecurityCritical: boolean;
  readonly isSecuritySafeCritical: boolean;
  readonly isSecurityTransparent: boolean;

  constructor(data?: IMethodBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.memberType = _data["memberType"];
      (<any>this).name = _data["name"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      this.attributes = _data["attributes"];
      this.methodImplementationFlags = _data["methodImplementationFlags"];
      this.callingConvention = _data["callingConvention"];
      (<any>this).isAbstract = _data["isAbstract"];
      (<any>this).isConstructor = _data["isConstructor"];
      (<any>this).isFinal = _data["isFinal"];
      (<any>this).isHideBySig = _data["isHideBySig"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      (<any>this).isStatic = _data["isStatic"];
      (<any>this).isVirtual = _data["isVirtual"];
      (<any>this).isAssembly = _data["isAssembly"];
      (<any>this).isFamily = _data["isFamily"];
      (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
      (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
      (<any>this).isPrivate = _data["isPrivate"];
      (<any>this).isPublic = _data["isPublic"];
      (<any>this).isConstructedGenericMethod =
        _data["isConstructedGenericMethod"];
      (<any>this).isGenericMethod = _data["isGenericMethod"];
      (<any>this).isGenericMethodDefinition =
        _data["isGenericMethodDefinition"];
      (<any>this).containsGenericParameters =
        _data["containsGenericParameters"];
      this.methodHandle = _data["methodHandle"]
        ? RuntimeMethodHandle.fromJS(_data["methodHandle"])
        : <any>undefined;
      (<any>this).isSecurityCritical = _data["isSecurityCritical"];
      (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
      (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
    }
  }

  static fromJS(data: any): MethodBase {
    data = typeof data === "object" ? data : {};
    let result = new MethodBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["memberType"] = this.memberType;
    data["name"] = this.name;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["attributes"] = this.attributes;
    data["methodImplementationFlags"] = this.methodImplementationFlags;
    data["callingConvention"] = this.callingConvention;
    data["isAbstract"] = this.isAbstract;
    data["isConstructor"] = this.isConstructor;
    data["isFinal"] = this.isFinal;
    data["isHideBySig"] = this.isHideBySig;
    data["isSpecialName"] = this.isSpecialName;
    data["isStatic"] = this.isStatic;
    data["isVirtual"] = this.isVirtual;
    data["isAssembly"] = this.isAssembly;
    data["isFamily"] = this.isFamily;
    data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
    data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
    data["isPrivate"] = this.isPrivate;
    data["isPublic"] = this.isPublic;
    data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
    data["isGenericMethod"] = this.isGenericMethod;
    data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
    data["containsGenericParameters"] = this.containsGenericParameters;
    data["methodHandle"] = this.methodHandle
      ? this.methodHandle.toJSON()
      : <any>undefined;
    data["isSecurityCritical"] = this.isSecurityCritical;
    data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
    data["isSecurityTransparent"] = this.isSecurityTransparent;
    return data;
  }

  clone(): MethodBase {
    const json = this.toJSON();
    let result = new MethodBase();
    result.init(json);
    return result;
  }
}

export interface IMethodBase {
  memberType: MemberTypes;
  name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  attributes: MethodAttributes;
  methodImplementationFlags: MethodImplAttributes;
  callingConvention: CallingConventions;
  isAbstract: boolean;
  isConstructor: boolean;
  isFinal: boolean;
  isHideBySig: boolean;
  isSpecialName: boolean;
  isStatic: boolean;
  isVirtual: boolean;
  isAssembly: boolean;
  isFamily: boolean;
  isFamilyAndAssembly: boolean;
  isFamilyOrAssembly: boolean;
  isPrivate: boolean;
  isPublic: boolean;
  isConstructedGenericMethod: boolean;
  isGenericMethod: boolean;
  isGenericMethodDefinition: boolean;
  containsGenericParameters: boolean;
  methodHandle: RuntimeMethodHandle;
  isSecurityCritical: boolean;
  isSecuritySafeCritical: boolean;
  isSecurityTransparent: boolean;
}

export enum MethodImplAttributes {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _8 = 8,
  _16 = 16,
  _32 = 32,
  _64 = 64,
  _128 = 128,
  _256 = 256,
  _512 = 512,
  _4096 = 4096,
  _65535 = 65535,
}

export class MethodInfo implements IMethodInfo {
  readonly name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  attributes: MethodAttributes;
  methodImplementationFlags: MethodImplAttributes;
  callingConvention: CallingConventions;
  readonly isAbstract: boolean;
  readonly isConstructor: boolean;
  readonly isFinal: boolean;
  readonly isHideBySig: boolean;
  readonly isSpecialName: boolean;
  readonly isStatic: boolean;
  readonly isVirtual: boolean;
  readonly isAssembly: boolean;
  readonly isFamily: boolean;
  readonly isFamilyAndAssembly: boolean;
  readonly isFamilyOrAssembly: boolean;
  readonly isPrivate: boolean;
  readonly isPublic: boolean;
  readonly isConstructedGenericMethod: boolean;
  readonly isGenericMethod: boolean;
  readonly isGenericMethodDefinition: boolean;
  readonly containsGenericParameters: boolean;
  methodHandle: RuntimeMethodHandle;
  readonly isSecurityCritical: boolean;
  readonly isSecuritySafeCritical: boolean;
  readonly isSecurityTransparent: boolean;
  memberType: MemberTypes;
  returnParameter: ParameterInfo;
  returnType: Type;
  returnTypeCustomAttributes: ICustomAttributeProvider;

  constructor(data?: IMethodInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data["name"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      this.attributes = _data["attributes"];
      this.methodImplementationFlags = _data["methodImplementationFlags"];
      this.callingConvention = _data["callingConvention"];
      (<any>this).isAbstract = _data["isAbstract"];
      (<any>this).isConstructor = _data["isConstructor"];
      (<any>this).isFinal = _data["isFinal"];
      (<any>this).isHideBySig = _data["isHideBySig"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      (<any>this).isStatic = _data["isStatic"];
      (<any>this).isVirtual = _data["isVirtual"];
      (<any>this).isAssembly = _data["isAssembly"];
      (<any>this).isFamily = _data["isFamily"];
      (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
      (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
      (<any>this).isPrivate = _data["isPrivate"];
      (<any>this).isPublic = _data["isPublic"];
      (<any>this).isConstructedGenericMethod =
        _data["isConstructedGenericMethod"];
      (<any>this).isGenericMethod = _data["isGenericMethod"];
      (<any>this).isGenericMethodDefinition =
        _data["isGenericMethodDefinition"];
      (<any>this).containsGenericParameters =
        _data["containsGenericParameters"];
      this.methodHandle = _data["methodHandle"]
        ? RuntimeMethodHandle.fromJS(_data["methodHandle"])
        : <any>undefined;
      (<any>this).isSecurityCritical = _data["isSecurityCritical"];
      (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
      (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
      this.memberType = _data["memberType"];
      this.returnParameter = _data["returnParameter"]
        ? ParameterInfo.fromJS(_data["returnParameter"])
        : <any>undefined;
      this.returnType = _data["returnType"]
        ? Type.fromJS(_data["returnType"])
        : <any>undefined;
      this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"]
        ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): MethodInfo {
    data = typeof data === "object" ? data : {};
    let result = new MethodInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["attributes"] = this.attributes;
    data["methodImplementationFlags"] = this.methodImplementationFlags;
    data["callingConvention"] = this.callingConvention;
    data["isAbstract"] = this.isAbstract;
    data["isConstructor"] = this.isConstructor;
    data["isFinal"] = this.isFinal;
    data["isHideBySig"] = this.isHideBySig;
    data["isSpecialName"] = this.isSpecialName;
    data["isStatic"] = this.isStatic;
    data["isVirtual"] = this.isVirtual;
    data["isAssembly"] = this.isAssembly;
    data["isFamily"] = this.isFamily;
    data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
    data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
    data["isPrivate"] = this.isPrivate;
    data["isPublic"] = this.isPublic;
    data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
    data["isGenericMethod"] = this.isGenericMethod;
    data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
    data["containsGenericParameters"] = this.containsGenericParameters;
    data["methodHandle"] = this.methodHandle
      ? this.methodHandle.toJSON()
      : <any>undefined;
    data["isSecurityCritical"] = this.isSecurityCritical;
    data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
    data["isSecurityTransparent"] = this.isSecurityTransparent;
    data["memberType"] = this.memberType;
    data["returnParameter"] = this.returnParameter
      ? this.returnParameter.toJSON()
      : <any>undefined;
    data["returnType"] = this.returnType
      ? this.returnType.toJSON()
      : <any>undefined;
    data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes
      ? this.returnTypeCustomAttributes.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): MethodInfo {
    const json = this.toJSON();
    let result = new MethodInfo();
    result.init(json);
    return result;
  }
}

export interface IMethodInfo {
  name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  attributes: MethodAttributes;
  methodImplementationFlags: MethodImplAttributes;
  callingConvention: CallingConventions;
  isAbstract: boolean;
  isConstructor: boolean;
  isFinal: boolean;
  isHideBySig: boolean;
  isSpecialName: boolean;
  isStatic: boolean;
  isVirtual: boolean;
  isAssembly: boolean;
  isFamily: boolean;
  isFamilyAndAssembly: boolean;
  isFamilyOrAssembly: boolean;
  isPrivate: boolean;
  isPublic: boolean;
  isConstructedGenericMethod: boolean;
  isGenericMethod: boolean;
  isGenericMethodDefinition: boolean;
  containsGenericParameters: boolean;
  methodHandle: RuntimeMethodHandle;
  isSecurityCritical: boolean;
  isSecuritySafeCritical: boolean;
  isSecurityTransparent: boolean;
  memberType: MemberTypes;
  returnParameter: ParameterInfo;
  returnType: Type;
  returnTypeCustomAttributes: ICustomAttributeProvider;
}

export class Module implements IModule {
  assembly: Assembly;
  readonly fullyQualifiedName: string | undefined;
  readonly name: string | undefined;
  readonly mdStreamVersion: number;
  readonly moduleVersionId: string;
  readonly scopeName: string | undefined;
  moduleHandle: ModuleHandle;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly metadataToken: number;

  constructor(data?: IModule) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.assembly = _data["assembly"]
        ? Assembly.fromJS(_data["assembly"])
        : <any>undefined;
      (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
      (<any>this).name = _data["name"];
      (<any>this).mdStreamVersion = _data["mdStreamVersion"];
      (<any>this).moduleVersionId = _data["moduleVersionId"];
      (<any>this).scopeName = _data["scopeName"];
      this.moduleHandle = _data["moduleHandle"]
        ? ModuleHandle.fromJS(_data["moduleHandle"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).metadataToken = _data["metadataToken"];
    }
  }

  static fromJS(data: any): Module {
    data = typeof data === "object" ? data : {};
    let result = new Module();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
    data["fullyQualifiedName"] = this.fullyQualifiedName;
    data["name"] = this.name;
    data["mdStreamVersion"] = this.mdStreamVersion;
    data["moduleVersionId"] = this.moduleVersionId;
    data["scopeName"] = this.scopeName;
    data["moduleHandle"] = this.moduleHandle
      ? this.moduleHandle.toJSON()
      : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["metadataToken"] = this.metadataToken;
    return data;
  }

  clone(): Module {
    const json = this.toJSON();
    let result = new Module();
    result.init(json);
    return result;
  }
}

export interface IModule {
  assembly: Assembly;
  fullyQualifiedName: string | undefined;
  name: string | undefined;
  mdStreamVersion: number;
  moduleVersionId: string;
  scopeName: string | undefined;
  moduleHandle: ModuleHandle;
  customAttributes: CustomAttributeData[] | undefined;
  metadataToken: number;
}

export class ModuleHandle implements IModuleHandle {
  readonly mdStreamVersion: number;

  constructor(data?: IModuleHandle) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).mdStreamVersion = _data["mdStreamVersion"];
    }
  }

  static fromJS(data: any): ModuleHandle {
    data = typeof data === "object" ? data : {};
    let result = new ModuleHandle();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["mdStreamVersion"] = this.mdStreamVersion;
    return data;
  }

  clone(): ModuleHandle {
    const json = this.toJSON();
    let result = new ModuleHandle();
    result.init(json);
    return result;
  }
}

export interface IModuleHandle {
  mdStreamVersion: number;
}

export class MortageLoanOnPropertyDetail
  implements IMortageLoanOnPropertyDetail {
  id: number;
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanType3a14: string | undefined;
  creditLimit3a15: number | undefined;

  constructor(data?: IMortageLoanOnPropertyDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.applicationFinancialRealEstateId =
        _data["applicationFinancialRealEstateId"];
      this.creditorName3a9 = _data["creditorName3a9"];
      this.accountNumber3a10 = _data["accountNumber3a10"];
      this.monthlyMortagePayment3a11 = _data["monthlyMortagePayment3a11"];
      this.unpaidBalance3a12 = _data["unpaidBalance3a12"];
      this.paidOff3a13 = _data["paidOff3a13"];
      this.mortageLoanType3a14 = _data["mortageLoanType3a14"];
      this.creditLimit3a15 = _data["creditLimit3a15"];
    }
  }

  static fromJS(data: any): MortageLoanOnPropertyDetail {
    data = typeof data === "object" ? data : {};
    let result = new MortageLoanOnPropertyDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data[
      "applicationFinancialRealEstateId"
    ] = this.applicationFinancialRealEstateId;
    data["creditorName3a9"] = this.creditorName3a9;
    data["accountNumber3a10"] = this.accountNumber3a10;
    data["monthlyMortagePayment3a11"] = this.monthlyMortagePayment3a11;
    data["unpaidBalance3a12"] = this.unpaidBalance3a12;
    data["paidOff3a13"] = this.paidOff3a13;
    data["mortageLoanType3a14"] = this.mortageLoanType3a14;
    data["creditLimit3a15"] = this.creditLimit3a15;
    return data;
  }

  clone(): MortageLoanOnPropertyDetail {
    const json = this.toJSON();
    let result = new MortageLoanOnPropertyDetail();
    result.init(json);
    return result;
  }
}

export interface IMortageLoanOnPropertyDetail {
  id: number;
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanType3a14: string | undefined;
  creditLimit3a15: number | undefined;
}

export class NotificationData implements INotificationData {
  readonly type: string | undefined;
  properties: { [key: string]: any } | undefined;

  constructor(data?: INotificationData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).type = _data["type"];
      if (_data["properties"]) {
        this.properties = {} as any;
        for (let key in _data["properties"]) {
          if (_data["properties"].hasOwnProperty(key))
            (<any>this.properties)[key] = _data["properties"][key];
        }
      }
    }
  }

  static fromJS(data: any): NotificationData {
    data = typeof data === "object" ? data : {};
    let result = new NotificationData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["type"] = this.type;
    if (this.properties) {
      data["properties"] = {};
      for (let key in this.properties) {
        if (this.properties.hasOwnProperty(key))
          (<any>data["properties"])[key] = this.properties[key];
      }
    }
    return data;
  }

  clone(): NotificationData {
    const json = this.toJSON();
    let result = new NotificationData();
    result.init(json);
    return result;
  }
}

export interface INotificationData {
  type: string | undefined;
  properties: { [key: string]: any } | undefined;
}

export enum NotificationSeverity {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
}

export enum ParameterAttributes {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _4 = 4,
  _8 = 8,
  _16 = 16,
  _4096 = 4096,
  _8192 = 8192,
  _16384 = 16384,
  _32768 = 32768,
  _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
  attributes: ParameterAttributes;
  member: MemberInfo;
  readonly name: string | undefined;
  parameterType: Type;
  readonly position: number;
  readonly isIn: boolean;
  readonly isLcid: boolean;
  readonly isOptional: boolean;
  readonly isOut: boolean;
  readonly isRetval: boolean;
  readonly defaultValue: any | undefined;
  readonly rawDefaultValue: any | undefined;
  readonly hasDefaultValue: boolean;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly metadataToken: number;

  constructor(data?: IParameterInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attributes = _data["attributes"];
      this.member = _data["member"]
        ? MemberInfo.fromJS(_data["member"])
        : <any>undefined;
      (<any>this).name = _data["name"];
      this.parameterType = _data["parameterType"]
        ? Type.fromJS(_data["parameterType"])
        : <any>undefined;
      (<any>this).position = _data["position"];
      (<any>this).isIn = _data["isIn"];
      (<any>this).isLcid = _data["isLcid"];
      (<any>this).isOptional = _data["isOptional"];
      (<any>this).isOut = _data["isOut"];
      (<any>this).isRetval = _data["isRetval"];
      (<any>this).defaultValue = _data["defaultValue"];
      (<any>this).rawDefaultValue = _data["rawDefaultValue"];
      (<any>this).hasDefaultValue = _data["hasDefaultValue"];
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).metadataToken = _data["metadataToken"];
    }
  }

  static fromJS(data: any): ParameterInfo {
    data = typeof data === "object" ? data : {};
    let result = new ParameterInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["attributes"] = this.attributes;
    data["member"] = this.member ? this.member.toJSON() : <any>undefined;
    data["name"] = this.name;
    data["parameterType"] = this.parameterType
      ? this.parameterType.toJSON()
      : <any>undefined;
    data["position"] = this.position;
    data["isIn"] = this.isIn;
    data["isLcid"] = this.isLcid;
    data["isOptional"] = this.isOptional;
    data["isOut"] = this.isOut;
    data["isRetval"] = this.isRetval;
    data["defaultValue"] = this.defaultValue;
    data["rawDefaultValue"] = this.rawDefaultValue;
    data["hasDefaultValue"] = this.hasDefaultValue;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["metadataToken"] = this.metadataToken;
    return data;
  }

  clone(): ParameterInfo {
    const json = this.toJSON();
    let result = new ParameterInfo();
    result.init(json);
    return result;
  }
}

export interface IParameterInfo {
  attributes: ParameterAttributes;
  member: MemberInfo;
  name: string | undefined;
  parameterType: Type;
  position: number;
  isIn: boolean;
  isLcid: boolean;
  isOptional: boolean;
  isOut: boolean;
  isRetval: boolean;
  defaultValue: any | undefined;
  rawDefaultValue: any | undefined;
  hasDefaultValue: boolean;
  customAttributes: CustomAttributeData[] | undefined;
  metadataToken: number;
}

export class PermissionDto implements IPermissionDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): PermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): PermissionDto {
    const json = this.toJSON();
    let result = new PermissionDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;

  constructor(data?: IPermissionDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PermissionDtoListResultDto {
    const json = this.toJSON();
    let result = new PermissionDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;
}

export class PersonalInformationDto implements IPersonalInformationDto {
  id: number | undefined;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrower: BorrowerDto;
  coBorrower: BorrowerDto;
  residentialAddress: AddressDto;
  coBorrowerResidentialAddress: AddressDto;
  previousAddresses: AddressDto[] | undefined;
  mailingAddress: AddressDto;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerPreviousAddresses: AddressDto[] | undefined;
  coBorrowerMailingAddress: AddressDto;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  loanApplicationId: number;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;

  constructor(data?: IPersonalInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isApplyingWithCoBorrower = _data["isApplyingWithCoBorrower"];
      this.useIncomeOfPersonOtherThanBorrower =
        _data["useIncomeOfPersonOtherThanBorrower"];
      this.agreePrivacyPolicy = _data["agreePrivacyPolicy"];
      this.borrower = _data["borrower"]
        ? BorrowerDto.fromJS(_data["borrower"])
        : <any>undefined;
      this.coBorrower = _data["coBorrower"]
        ? BorrowerDto.fromJS(_data["coBorrower"])
        : <any>undefined;
      this.residentialAddress = _data["residentialAddress"]
        ? AddressDto.fromJS(_data["residentialAddress"])
        : <any>undefined;
      this.coBorrowerResidentialAddress = _data["coBorrowerResidentialAddress"]
        ? AddressDto.fromJS(_data["coBorrowerResidentialAddress"])
        : <any>undefined;
      if (Array.isArray(_data["previousAddresses"])) {
        this.previousAddresses = [] as any;
        for (let item of _data["previousAddresses"])
          this.previousAddresses.push(AddressDto.fromJS(item));
      }
      this.mailingAddress = _data["mailingAddress"]
        ? AddressDto.fromJS(_data["mailingAddress"])
        : <any>undefined;
      this.isMailingAddressSameAsResidential =
        _data["isMailingAddressSameAsResidential"];
      if (Array.isArray(_data["coBorrowerPreviousAddresses"])) {
        this.coBorrowerPreviousAddresses = [] as any;
        for (let item of _data["coBorrowerPreviousAddresses"])
          this.coBorrowerPreviousAddresses.push(AddressDto.fromJS(item));
      }
      this.coBorrowerMailingAddress = _data["coBorrowerMailingAddress"]
        ? AddressDto.fromJS(_data["coBorrowerMailingAddress"])
        : <any>undefined;
      this.coBorrowerIsMailingAddressSameAsResidential =
        _data["coBorrowerIsMailingAddressSameAsResidential"];
      this.loanApplicationId = _data["loanApplicationId"];
      this.coBorrowerResidentialAddressSameAsBorrowerResidential =
        _data["coBorrowerResidentialAddressSameAsBorrowerResidential"];
    }
  }

  static fromJS(data: any): PersonalInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new PersonalInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["isApplyingWithCoBorrower"] = this.isApplyingWithCoBorrower;
    data[
      "useIncomeOfPersonOtherThanBorrower"
    ] = this.useIncomeOfPersonOtherThanBorrower;
    data["agreePrivacyPolicy"] = this.agreePrivacyPolicy;
    data["borrower"] = this.borrower ? this.borrower.toJSON() : <any>undefined;
    data["coBorrower"] = this.coBorrower
      ? this.coBorrower.toJSON()
      : <any>undefined;
    data["residentialAddress"] = this.residentialAddress
      ? this.residentialAddress.toJSON()
      : <any>undefined;
    data["coBorrowerResidentialAddress"] = this.coBorrowerResidentialAddress
      ? this.coBorrowerResidentialAddress.toJSON()
      : <any>undefined;
    if (Array.isArray(this.previousAddresses)) {
      data["previousAddresses"] = [];
      for (let item of this.previousAddresses)
        data["previousAddresses"].push(item.toJSON());
    }
    data["mailingAddress"] = this.mailingAddress
      ? this.mailingAddress.toJSON()
      : <any>undefined;
    data[
      "isMailingAddressSameAsResidential"
    ] = this.isMailingAddressSameAsResidential;
    if (Array.isArray(this.coBorrowerPreviousAddresses)) {
      data["coBorrowerPreviousAddresses"] = [];
      for (let item of this.coBorrowerPreviousAddresses)
        data["coBorrowerPreviousAddresses"].push(item.toJSON());
    }
    data["coBorrowerMailingAddress"] = this.coBorrowerMailingAddress
      ? this.coBorrowerMailingAddress.toJSON()
      : <any>undefined;
    data[
      "coBorrowerIsMailingAddressSameAsResidential"
    ] = this.coBorrowerIsMailingAddressSameAsResidential;
    data["loanApplicationId"] = this.loanApplicationId;
    data[
      "coBorrowerResidentialAddressSameAsBorrowerResidential"
    ] = this.coBorrowerResidentialAddressSameAsBorrowerResidential;
    return data;
  }

  clone(): PersonalInformationDto {
    const json = this.toJSON();
    let result = new PersonalInformationDto();
    result.init(json);
    return result;
  }
}

export interface IPersonalInformationDto {
  id: number | undefined;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrower: BorrowerDto;
  coBorrower: BorrowerDto;
  residentialAddress: AddressDto;
  coBorrowerResidentialAddress: AddressDto;
  previousAddresses: AddressDto[] | undefined;
  mailingAddress: AddressDto;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerPreviousAddresses: AddressDto[] | undefined;
  coBorrowerMailingAddress: AddressDto;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  loanApplicationId: number;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;
}

export class PersonalInformationDtoPagedResultDto
  implements IPersonalInformationDtoPagedResultDto {
  items: PersonalInformationDto[] | undefined;
  totalCount: number;

  constructor(data?: IPersonalInformationDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PersonalInformationDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): PersonalInformationDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PersonalInformationDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): PersonalInformationDtoPagedResultDto {
    const json = this.toJSON();
    let result = new PersonalInformationDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IPersonalInformationDtoPagedResultDto {
  items: PersonalInformationDto[] | undefined;
  totalCount: number;
}

export class Personaldetail implements IPersonaldetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrowerId: number | undefined;
  coBorrowerId: number | undefined;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;
  borrower: Borrower;
  coBorrower: Borrower;
  loanapplication: Loanapplication;
  addresses: Address[] | undefined;

  constructor(data?: IPersonaldetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.isApplyingWithCoBorrower = _data["isApplyingWithCoBorrower"];
      this.useIncomeOfPersonOtherThanBorrower =
        _data["useIncomeOfPersonOtherThanBorrower"];
      this.agreePrivacyPolicy = _data["agreePrivacyPolicy"];
      this.borrowerId = _data["borrowerId"];
      this.coBorrowerId = _data["coBorrowerId"];
      this.isMailingAddressSameAsResidential =
        _data["isMailingAddressSameAsResidential"];
      this.coBorrowerIsMailingAddressSameAsResidential =
        _data["coBorrowerIsMailingAddressSameAsResidential"];
      this.coBorrowerResidentialAddressSameAsBorrowerResidential =
        _data["coBorrowerResidentialAddressSameAsBorrowerResidential"];
      this.borrower = _data["borrower"]
        ? Borrower.fromJS(_data["borrower"])
        : <any>undefined;
      this.coBorrower = _data["coBorrower"]
        ? Borrower.fromJS(_data["coBorrower"])
        : <any>undefined;
      this.loanapplication = _data["loanapplication"]
        ? Loanapplication.fromJS(_data["loanapplication"])
        : <any>undefined;
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses.push(Address.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Personaldetail {
    data = typeof data === "object" ? data : {};
    let result = new Personaldetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["isApplyingWithCoBorrower"] = this.isApplyingWithCoBorrower;
    data[
      "useIncomeOfPersonOtherThanBorrower"
    ] = this.useIncomeOfPersonOtherThanBorrower;
    data["agreePrivacyPolicy"] = this.agreePrivacyPolicy;
    data["borrowerId"] = this.borrowerId;
    data["coBorrowerId"] = this.coBorrowerId;
    data[
      "isMailingAddressSameAsResidential"
    ] = this.isMailingAddressSameAsResidential;
    data[
      "coBorrowerIsMailingAddressSameAsResidential"
    ] = this.coBorrowerIsMailingAddressSameAsResidential;
    data[
      "coBorrowerResidentialAddressSameAsBorrowerResidential"
    ] = this.coBorrowerResidentialAddressSameAsBorrowerResidential;
    data["borrower"] = this.borrower ? this.borrower.toJSON() : <any>undefined;
    data["coBorrower"] = this.coBorrower
      ? this.coBorrower.toJSON()
      : <any>undefined;
    data["loanapplication"] = this.loanapplication
      ? this.loanapplication.toJSON()
      : <any>undefined;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    return data;
  }

  clone(): Personaldetail {
    const json = this.toJSON();
    let result = new Personaldetail();
    result.init(json);
    return result;
  }
}

export interface IPersonaldetail {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  isApplyingWithCoBorrower: boolean | undefined;
  useIncomeOfPersonOtherThanBorrower: boolean | undefined;
  agreePrivacyPolicy: boolean | undefined;
  borrowerId: number | undefined;
  coBorrowerId: number | undefined;
  isMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerIsMailingAddressSameAsResidential: boolean | undefined;
  coBorrowerResidentialAddressSameAsBorrowerResidential: boolean | undefined;
  borrower: Borrower;
  coBorrower: Borrower;
  loanapplication: Loanapplication;
  addresses: Address[] | undefined;
}

export class PreviousEmployementDetail implements IPreviousEmployementDetail {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1d2: string | undefined;
  street1d31: string | undefined;
  unit1d32: string | undefined;
  zip1d35: string | undefined;
  country1d36: string | undefined;
  stateId1d34: string | undefined;
  city1d33: string | undefined;
  positionTitle1d4: string | undefined;
  startDate1d5: moment.Moment | undefined;
  endDate1d6: moment.Moment | undefined;
  isSelfEmployed1d7: number | undefined;
  grossMonthlyIncome1d8: number | undefined;

  constructor(data?: IPreviousEmployementDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.employerBusinessName1d2 = _data["employerBusinessName1d2"];
      this.street1d31 = _data["street1d31"];
      this.unit1d32 = _data["unit1d32"];
      this.zip1d35 = _data["zip1d35"];
      this.country1d36 = _data["country1d36"];
      this.stateId1d34 = _data["stateId1d34"];
      this.city1d33 = _data["city1d33"];
      this.positionTitle1d4 = _data["positionTitle1d4"];
      this.startDate1d5 = _data["startDate1d5"]
        ? moment(_data["startDate1d5"].toString())
        : <any>undefined;
      this.endDate1d6 = _data["endDate1d6"]
        ? moment(_data["endDate1d6"].toString())
        : <any>undefined;
      this.isSelfEmployed1d7 = _data["isSelfEmployed1d7"];
      this.grossMonthlyIncome1d8 = _data["grossMonthlyIncome1d8"];
    }
  }

  static fromJS(data: any): PreviousEmployementDetail {
    data = typeof data === "object" ? data : {};
    let result = new PreviousEmployementDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["employerBusinessName1d2"] = this.employerBusinessName1d2;
    data["street1d31"] = this.street1d31;
    data["unit1d32"] = this.unit1d32;
    data["zip1d35"] = this.zip1d35;
    data["country1d36"] = this.country1d36;
    data["stateId1d34"] = this.stateId1d34;
    data["city1d33"] = this.city1d33;
    data["positionTitle1d4"] = this.positionTitle1d4;
    data["startDate1d5"] = this.startDate1d5
      ? this.startDate1d5.toISOString()
      : <any>undefined;
    data["endDate1d6"] = this.endDate1d6
      ? this.endDate1d6.toISOString()
      : <any>undefined;
    data["isSelfEmployed1d7"] = this.isSelfEmployed1d7;
    data["grossMonthlyIncome1d8"] = this.grossMonthlyIncome1d8;
    return data;
  }

  clone(): PreviousEmployementDetail {
    const json = this.toJSON();
    let result = new PreviousEmployementDetail();
    result.init(json);
    return result;
  }
}

export interface IPreviousEmployementDetail {
  applicationPersonalInformationId: number | undefined;
  employerBusinessName1d2: string | undefined;
  street1d31: string | undefined;
  unit1d32: string | undefined;
  zip1d35: string | undefined;
  country1d36: string | undefined;
  stateId1d34: string | undefined;
  city1d33: string | undefined;
  positionTitle1d4: string | undefined;
  startDate1d5: moment.Moment | undefined;
  endDate1d6: moment.Moment | undefined;
  isSelfEmployed1d7: number | undefined;
  grossMonthlyIncome1d8: number | undefined;
}

export enum PropertyAttributes {
  _0 = 0,
  _512 = 512,
  _1024 = 1024,
  _4096 = 4096,
  _8192 = 8192,
  _16384 = 16384,
  _32768 = 32768,
  _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
  readonly name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  memberType: MemberTypes;
  propertyType: Type;
  attributes: PropertyAttributes;
  readonly isSpecialName: boolean;
  readonly canRead: boolean;
  readonly canWrite: boolean;
  getMethod: MethodInfo;
  setMethod: MethodInfo;

  constructor(data?: IPropertyInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data["name"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      this.memberType = _data["memberType"];
      this.propertyType = _data["propertyType"]
        ? Type.fromJS(_data["propertyType"])
        : <any>undefined;
      this.attributes = _data["attributes"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      (<any>this).canRead = _data["canRead"];
      (<any>this).canWrite = _data["canWrite"];
      this.getMethod = _data["getMethod"]
        ? MethodInfo.fromJS(_data["getMethod"])
        : <any>undefined;
      this.setMethod = _data["setMethod"]
        ? MethodInfo.fromJS(_data["setMethod"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PropertyInfo {
    data = typeof data === "object" ? data : {};
    let result = new PropertyInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["memberType"] = this.memberType;
    data["propertyType"] = this.propertyType
      ? this.propertyType.toJSON()
      : <any>undefined;
    data["attributes"] = this.attributes;
    data["isSpecialName"] = this.isSpecialName;
    data["canRead"] = this.canRead;
    data["canWrite"] = this.canWrite;
    data["getMethod"] = this.getMethod
      ? this.getMethod.toJSON()
      : <any>undefined;
    data["setMethod"] = this.setMethod
      ? this.setMethod.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): PropertyInfo {
    const json = this.toJSON();
    let result = new PropertyInfo();
    result.init(json);
    return result;
  }
}

export interface IPropertyInfo {
  name: string | undefined;
  declaringType: Type;
  reflectedType: Type;
  module: Module;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  memberType: MemberTypes;
  propertyType: Type;
  attributes: PropertyAttributes;
  isSpecialName: boolean;
  canRead: boolean;
  canWrite: boolean;
  getMethod: MethodInfo;
  setMethod: MethodInfo;
}

export class RefinanceHomeBuyingDto implements IRefinanceHomeBuyingDto {
  id: number | undefined;
  propertyLocated: string | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  wantRefinance: string | undefined;
  homePrice: number;
  owe: number;
  cashBorrow: number;
  fhaLoan: string | undefined;
  militarySevice: boolean;
  foreclosurePastTwoYears: boolean;
  bankruptcyPastThreeYears: boolean;
  lateMortgagePayments: string | undefined;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;

  constructor(data?: IRefinanceHomeBuyingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.propertyLocated = _data["propertyLocated"];
      this.propertyType = _data["propertyType"];
      this.propertyUse = _data["propertyUse"];
      this.wantRefinance = _data["wantRefinance"];
      this.homePrice = _data["homePrice"];
      this.owe = _data["owe"];
      this.cashBorrow = _data["cashBorrow"];
      this.fhaLoan = _data["fhaLoan"];
      this.militarySevice = _data["militarySevice"];
      this.foreclosurePastTwoYears = _data["foreclosurePastTwoYears"];
      this.bankruptcyPastThreeYears = _data["bankruptcyPastThreeYears"];
      this.lateMortgagePayments = _data["lateMortgagePayments"];
      this.currentEmployed = _data["currentEmployed"];
      this.houseHoldIncome = _data["houseHoldIncome"];
      this.proofOfincome = _data["proofOfincome"];
      this.rateCredit = _data["rateCredit"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.emailAddress = _data["emailAddress"];
      this.phoneNumber = _data["phoneNumber"];
      this.refferedBy = _data["refferedBy"];
    }
  }

  static fromJS(data: any): RefinanceHomeBuyingDto {
    data = typeof data === "object" ? data : {};
    let result = new RefinanceHomeBuyingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["propertyLocated"] = this.propertyLocated;
    data["propertyType"] = this.propertyType;
    data["propertyUse"] = this.propertyUse;
    data["wantRefinance"] = this.wantRefinance;
    data["homePrice"] = this.homePrice;
    data["owe"] = this.owe;
    data["cashBorrow"] = this.cashBorrow;
    data["fhaLoan"] = this.fhaLoan;
    data["militarySevice"] = this.militarySevice;
    data["foreclosurePastTwoYears"] = this.foreclosurePastTwoYears;
    data["bankruptcyPastThreeYears"] = this.bankruptcyPastThreeYears;
    data["lateMortgagePayments"] = this.lateMortgagePayments;
    data["currentEmployed"] = this.currentEmployed;
    data["houseHoldIncome"] = this.houseHoldIncome;
    data["proofOfincome"] = this.proofOfincome;
    data["rateCredit"] = this.rateCredit;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["emailAddress"] = this.emailAddress;
    data["phoneNumber"] = this.phoneNumber;
    data["refferedBy"] = this.refferedBy;
    return data;
  }

  clone(): RefinanceHomeBuyingDto {
    const json = this.toJSON();
    let result = new RefinanceHomeBuyingDto();
    result.init(json);
    return result;
  }
}

export interface IRefinanceHomeBuyingDto {
  id: number | undefined;
  propertyLocated: string | undefined;
  propertyType: string | undefined;
  propertyUse: string | undefined;
  wantRefinance: string | undefined;
  homePrice: number;
  owe: number;
  cashBorrow: number;
  fhaLoan: string | undefined;
  militarySevice: boolean;
  foreclosurePastTwoYears: boolean;
  bankruptcyPastThreeYears: boolean;
  lateMortgagePayments: string | undefined;
  currentEmployed: string | undefined;
  houseHoldIncome: string | undefined;
  proofOfincome: boolean;
  rateCredit: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  emailAddress: string | undefined;
  phoneNumber: string | undefined;
  refferedBy: string | undefined;
}

export class RefinanceHomeBuyingDtoPagedResultDto
  implements IRefinanceHomeBuyingDtoPagedResultDto {
  items: RefinanceHomeBuyingDto[] | undefined;
  totalCount: number;

  constructor(data?: IRefinanceHomeBuyingDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RefinanceHomeBuyingDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RefinanceHomeBuyingDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RefinanceHomeBuyingDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RefinanceHomeBuyingDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RefinanceHomeBuyingDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRefinanceHomeBuyingDtoPagedResultDto {
  items: RefinanceHomeBuyingDto[] | undefined;
  totalCount: number;
}

export class RegisterInput implements IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;

  constructor(data?: IRegisterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
      this.password = _data["password"];
      this.captchaResponse = _data["captchaResponse"];
    }
  }

  static fromJS(data: any): RegisterInput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    data["password"] = this.password;
    data["captchaResponse"] = this.captchaResponse;
    return data;
  }

  clone(): RegisterInput {
    const json = this.toJSON();
    let result = new RegisterInput();
    result.init(json);
    return result;
  }
}

export interface IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
  canLogin: boolean;

  constructor(data?: IRegisterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canLogin = _data["canLogin"];
    }
  }

  static fromJS(data: any): RegisterOutput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canLogin"] = this.canLogin;
    return data;
  }

  clone(): RegisterOutput {
    const json = this.toJSON();
    let result = new RegisterOutput();
    result.init(json);
    return result;
  }
}

export interface IRegisterOutput {
  canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;

  constructor(data?: IResetPasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.adminPassword = _data["adminPassword"];
      this.userId = _data["userId"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ResetPasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ResetPasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["adminPassword"] = this.adminPassword;
    data["userId"] = this.userId;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ResetPasswordDto {
    const json = this.toJSON();
    let result = new ResetPasswordDto();
    result.init(json);
    return result;
  }
}

export interface IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;
}

export class RoleDto implements IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: IRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): RoleDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): RoleDto {
    const json = this.toJSON();
    let result = new RoleDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
  items: RoleDto[] | undefined;

  constructor(data?: IRoleDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoListResultDto {
  items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;

  constructor(data?: IRoleDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RoleDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RoleDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RoleDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;

  constructor(data?: IRoleEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
      this.isStatic = _data["isStatic"];
    }
  }

  static fromJS(data: any): RoleEditDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    data["isStatic"] = this.isStatic;
    return data;
  }

  clone(): RoleEditDto {
    const json = this.toJSON();
    let result = new RoleEditDto();
    result.init(json);
    return result;
  }
}

export interface IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;

  constructor(data?: IRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.isStatic = _data["isStatic"];
      this.isDefault = _data["isDefault"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): RoleListDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["isStatic"] = this.isStatic;
    data["isDefault"] = this.isDefault;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): RoleListDto {
    const json = this.toJSON();
    let result = new RoleListDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;

  constructor(data?: IRoleListDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RoleListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleListDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleListDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleListDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
  value: IntPtr;

  constructor(data?: IRuntimeFieldHandle) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"]
        ? IntPtr.fromJS(_data["value"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): RuntimeFieldHandle {
    data = typeof data === "object" ? data : {};
    let result = new RuntimeFieldHandle();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value ? this.value.toJSON() : <any>undefined;
    return data;
  }

  clone(): RuntimeFieldHandle {
    const json = this.toJSON();
    let result = new RuntimeFieldHandle();
    result.init(json);
    return result;
  }
}

export interface IRuntimeFieldHandle {
  value: IntPtr;
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
  value: IntPtr;

  constructor(data?: IRuntimeMethodHandle) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"]
        ? IntPtr.fromJS(_data["value"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): RuntimeMethodHandle {
    data = typeof data === "object" ? data : {};
    let result = new RuntimeMethodHandle();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value ? this.value.toJSON() : <any>undefined;
    return data;
  }

  clone(): RuntimeMethodHandle {
    const json = this.toJSON();
    let result = new RuntimeMethodHandle();
    result.init(json);
    return result;
  }
}

export interface IRuntimeMethodHandle {
  value: IntPtr;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
  value: IntPtr;

  constructor(data?: IRuntimeTypeHandle) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"]
        ? IntPtr.fromJS(_data["value"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): RuntimeTypeHandle {
    data = typeof data === "object" ? data : {};
    let result = new RuntimeTypeHandle();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value ? this.value.toJSON() : <any>undefined;
    return data;
  }

  clone(): RuntimeTypeHandle {
    const json = this.toJSON();
    let result = new RuntimeTypeHandle();
    result.init(json);
    return result;
  }
}

export interface IRuntimeTypeHandle {
  value: IntPtr;
}

export enum SecurityRuleSet {
  _0 = 0,
  _1 = 1,
  _2 = 2,
}

export class SiteSettingDto implements ISiteSettingDto {
  id: number;
  pageIdentifier: string | undefined;
  pageName: string | undefined;
  pageSetting: string | undefined;

  constructor(data?: ISiteSettingDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.pageIdentifier = _data["pageIdentifier"];
      this.pageName = _data["pageName"];
      this.pageSetting = _data["pageSetting"];
    }
  }

  static fromJS(data: any): SiteSettingDto {
    data = typeof data === "object" ? data : {};
    let result = new SiteSettingDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["pageIdentifier"] = this.pageIdentifier;
    data["pageName"] = this.pageName;
    data["pageSetting"] = this.pageSetting;
    return data;
  }

  clone(): SiteSettingDto {
    const json = this.toJSON();
    let result = new SiteSettingDto();
    result.init(json);
    return result;
  }
}

export interface ISiteSettingDto {
  id: number;
  pageIdentifier: string | undefined;
  pageName: string | undefined;
  pageSetting: string | undefined;
}

export class SiteSettingDtoPagedResultDto
  implements ISiteSettingDtoPagedResultDto {
  items: SiteSettingDto[] | undefined;
  totalCount: number;

  constructor(data?: ISiteSettingDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(SiteSettingDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): SiteSettingDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new SiteSettingDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): SiteSettingDtoPagedResultDto {
    const json = this.toJSON();
    let result = new SiteSettingDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ISiteSettingDtoPagedResultDto {
  items: SiteSettingDto[] | undefined;
  totalCount: number;
}

export class State implements IState {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  name: string | undefined;
  addresses: Address[] | undefined;
  manualassetentries: Manualassetentry[] | undefined;

  constructor(data?: IState) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.name = _data["name"];
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"])
          this.addresses.push(Address.fromJS(item));
      }
      if (Array.isArray(_data["manualassetentries"])) {
        this.manualassetentries = [] as any;
        for (let item of _data["manualassetentries"])
          this.manualassetentries.push(Manualassetentry.fromJS(item));
      }
    }
  }

  static fromJS(data: any): State {
    data = typeof data === "object" ? data : {};
    let result = new State();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["name"] = this.name;
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item.toJSON());
    }
    if (Array.isArray(this.manualassetentries)) {
      data["manualassetentries"] = [];
      for (let item of this.manualassetentries)
        data["manualassetentries"].push(item.toJSON());
    }
    return data;
  }

  clone(): State {
    const json = this.toJSON();
    let result = new State();
    result.init(json);
    return result;
  }
}

export interface IState {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  name: string | undefined;
  addresses: Address[] | undefined;
  manualassetentries: Manualassetentry[] | undefined;
}

export class StockAndBondViewModel implements IStockAndBondViewModel {
  id: number | undefined;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number | undefined;
  manualAssetEntryId: number;

  constructor(data?: IStockAndBondViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.companyName = _data["companyName"];
      this.accountNumber = _data["accountNumber"];
      this.value = _data["value"];
      this.manualAssetEntryId = _data["manualAssetEntryId"];
    }
  }

  static fromJS(data: any): StockAndBondViewModel {
    data = typeof data === "object" ? data : {};
    let result = new StockAndBondViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["companyName"] = this.companyName;
    data["accountNumber"] = this.accountNumber;
    data["value"] = this.value;
    data["manualAssetEntryId"] = this.manualAssetEntryId;
    return data;
  }

  clone(): StockAndBondViewModel {
    const json = this.toJSON();
    let result = new StockAndBondViewModel();
    result.init(json);
    return result;
  }
}

export interface IStockAndBondViewModel {
  id: number | undefined;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number | undefined;
  manualAssetEntryId: number;
}

export class Stockandbond implements IStockandbond {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number;
  manualAssetEntryId: number;
  manualAssetEntry: Manualassetentry;

  constructor(data?: IStockandbond) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      this.creatorUserId = _data["creatorUserId"];
      this.lastModificationTime = _data["lastModificationTime"]
        ? moment(_data["lastModificationTime"].toString())
        : <any>undefined;
      this.lastModifierUserId = _data["lastModifierUserId"];
      this.isDeleted = _data["isDeleted"];
      this.deleterUserId = _data["deleterUserId"];
      this.deletionTime = _data["deletionTime"]
        ? moment(_data["deletionTime"].toString())
        : <any>undefined;
      this.companyName = _data["companyName"];
      this.accountNumber = _data["accountNumber"];
      this.value = _data["value"];
      this.manualAssetEntryId = _data["manualAssetEntryId"];
      this.manualAssetEntry = _data["manualAssetEntry"]
        ? Manualassetentry.fromJS(_data["manualAssetEntry"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Stockandbond {
    data = typeof data === "object" ? data : {};
    let result = new Stockandbond();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    data["creatorUserId"] = this.creatorUserId;
    data["lastModificationTime"] = this.lastModificationTime
      ? this.lastModificationTime.toISOString()
      : <any>undefined;
    data["lastModifierUserId"] = this.lastModifierUserId;
    data["isDeleted"] = this.isDeleted;
    data["deleterUserId"] = this.deleterUserId;
    data["deletionTime"] = this.deletionTime
      ? this.deletionTime.toISOString()
      : <any>undefined;
    data["companyName"] = this.companyName;
    data["accountNumber"] = this.accountNumber;
    data["value"] = this.value;
    data["manualAssetEntryId"] = this.manualAssetEntryId;
    data["manualAssetEntry"] = this.manualAssetEntry
      ? this.manualAssetEntry.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): Stockandbond {
    const json = this.toJSON();
    let result = new Stockandbond();
    result.init(json);
    return result;
  }
}

export interface IStockandbond {
  id: number;
  creationTime: moment.Moment;
  creatorUserId: number | undefined;
  lastModificationTime: moment.Moment | undefined;
  lastModifierUserId: number | undefined;
  isDeleted: boolean;
  deleterUserId: number | undefined;
  deletionTime: moment.Moment | undefined;
  companyName: string | undefined;
  accountNumber: string | undefined;
  value: number;
  manualAssetEntryId: number;
  manualAssetEntry: Manualassetentry;
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
  readonly typeId: any | undefined;
  value: LayoutKind;

  constructor(data?: IStructLayoutAttribute) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).typeId = _data["typeId"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): StructLayoutAttribute {
    data = typeof data === "object" ? data : {};
    let result = new StructLayoutAttribute();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["typeId"] = this.typeId;
    data["value"] = this.value;
    return data;
  }

  clone(): StructLayoutAttribute {
    const json = this.toJSON();
    let result = new StructLayoutAttribute();
    result.init(json);
    return result;
  }
}

export interface IStructLayoutAttribute {
  typeId: any | undefined;
  value: LayoutKind;
}

export enum TenantAvailabilityState {
  _1 = 1,
  _2 = 2,
  _3 = 3,
}

export class TenantDto implements ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): TenantDto {
    const json = this.toJSON();
    let result = new TenantDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;

  constructor(data?: ITenantDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(TenantDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): TenantDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): TenantDtoPagedResultDto {
    const json = this.toJSON();
    let result = new TenantDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;

  constructor(data?: ITenantLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): TenantLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    return data;
  }

  clone(): TenantLoginInfoDto {
    const json = this.toJSON();
    let result = new TenantLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;
}

export class TenantNotification implements ITenantNotification {
  id: string;
  tenantId: number | undefined;
  notificationName: string | undefined;
  data: NotificationData;
  entityType: Type;
  entityTypeName: string | undefined;
  entityId: any | undefined;
  severity: NotificationSeverity;
  creationTime: moment.Moment;

  constructor(data?: ITenantNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenantId = _data["tenantId"];
      this.notificationName = _data["notificationName"];
      this.data = _data["data"]
        ? NotificationData.fromJS(_data["data"])
        : <any>undefined;
      this.entityType = _data["entityType"]
        ? Type.fromJS(_data["entityType"])
        : <any>undefined;
      this.entityTypeName = _data["entityTypeName"];
      this.entityId = _data["entityId"];
      this.severity = _data["severity"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): TenantNotification {
    data = typeof data === "object" ? data : {};
    let result = new TenantNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenantId"] = this.tenantId;
    data["notificationName"] = this.notificationName;
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["entityType"] = this.entityType
      ? this.entityType.toJSON()
      : <any>undefined;
    data["entityTypeName"] = this.entityTypeName;
    data["entityId"] = this.entityId;
    data["severity"] = this.severity;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): TenantNotification {
    const json = this.toJSON();
    let result = new TenantNotification();
    result.init(json);
    return result;
  }
}

export interface ITenantNotification {
  id: string;
  tenantId: number | undefined;
  notificationName: string | undefined;
  data: NotificationData;
  entityType: Type;
  entityTypeName: string | undefined;
  entityId: any | undefined;
  severity: NotificationSeverity;
  creationTime: moment.Moment;
}

export class Type implements IType {
  readonly name: string | undefined;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  readonly isInterface: boolean;
  memberType: MemberTypes;
  readonly namespace: string | undefined;
  readonly assemblyQualifiedName: string | undefined;
  readonly fullName: string | undefined;
  assembly: Assembly;
  module: Module;
  readonly isNested: boolean;
  declaringType: Type;
  declaringMethod: MethodBase;
  reflectedType: Type;
  underlyingSystemType: Type;
  readonly isTypeDefinition: boolean;
  readonly isArray: boolean;
  readonly isByRef: boolean;
  readonly isPointer: boolean;
  readonly isConstructedGenericType: boolean;
  readonly isGenericParameter: boolean;
  readonly isGenericTypeParameter: boolean;
  readonly isGenericMethodParameter: boolean;
  readonly isGenericType: boolean;
  readonly isGenericTypeDefinition: boolean;
  readonly isSZArray: boolean;
  readonly isVariableBoundArray: boolean;
  readonly isByRefLike: boolean;
  readonly hasElementType: boolean;
  readonly genericTypeArguments: Type[] | undefined;
  readonly genericParameterPosition: number;
  genericParameterAttributes: GenericParameterAttributes;
  attributes: TypeAttributes;
  readonly isAbstract: boolean;
  readonly isImport: boolean;
  readonly isSealed: boolean;
  readonly isSpecialName: boolean;
  readonly isClass: boolean;
  readonly isNestedAssembly: boolean;
  readonly isNestedFamANDAssem: boolean;
  readonly isNestedFamily: boolean;
  readonly isNestedFamORAssem: boolean;
  readonly isNestedPrivate: boolean;
  readonly isNestedPublic: boolean;
  readonly isNotPublic: boolean;
  readonly isPublic: boolean;
  readonly isAutoLayout: boolean;
  readonly isExplicitLayout: boolean;
  readonly isLayoutSequential: boolean;
  readonly isAnsiClass: boolean;
  readonly isAutoClass: boolean;
  readonly isUnicodeClass: boolean;
  readonly isCOMObject: boolean;
  readonly isContextful: boolean;
  readonly isEnum: boolean;
  readonly isMarshalByRef: boolean;
  readonly isPrimitive: boolean;
  readonly isValueType: boolean;
  readonly isSignatureType: boolean;
  readonly isSecurityCritical: boolean;
  readonly isSecuritySafeCritical: boolean;
  readonly isSecurityTransparent: boolean;
  structLayoutAttribute: StructLayoutAttribute;
  typeInitializer: ConstructorInfo;
  typeHandle: RuntimeTypeHandle;
  readonly guid: string;
  baseType: Type;
  readonly isSerializable: boolean;
  readonly containsGenericParameters: boolean;
  readonly isVisible: boolean;

  constructor(data?: IType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data["name"];
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      (<any>this).isInterface = _data["isInterface"];
      this.memberType = _data["memberType"];
      (<any>this).namespace = _data["namespace"];
      (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
      (<any>this).fullName = _data["fullName"];
      this.assembly = _data["assembly"]
        ? Assembly.fromJS(_data["assembly"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      (<any>this).isNested = _data["isNested"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.declaringMethod = _data["declaringMethod"]
        ? MethodBase.fromJS(_data["declaringMethod"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.underlyingSystemType = _data["underlyingSystemType"]
        ? Type.fromJS(_data["underlyingSystemType"])
        : <any>undefined;
      (<any>this).isTypeDefinition = _data["isTypeDefinition"];
      (<any>this).isArray = _data["isArray"];
      (<any>this).isByRef = _data["isByRef"];
      (<any>this).isPointer = _data["isPointer"];
      (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
      (<any>this).isGenericParameter = _data["isGenericParameter"];
      (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
      (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
      (<any>this).isGenericType = _data["isGenericType"];
      (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
      (<any>this).isSZArray = _data["isSZArray"];
      (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
      (<any>this).isByRefLike = _data["isByRefLike"];
      (<any>this).hasElementType = _data["hasElementType"];
      if (Array.isArray(_data["genericTypeArguments"])) {
        (<any>this).genericTypeArguments = [] as any;
        for (let item of _data["genericTypeArguments"])
          (<any>this).genericTypeArguments.push(Type.fromJS(item));
      }
      (<any>this).genericParameterPosition = _data["genericParameterPosition"];
      this.genericParameterAttributes = _data["genericParameterAttributes"];
      this.attributes = _data["attributes"];
      (<any>this).isAbstract = _data["isAbstract"];
      (<any>this).isImport = _data["isImport"];
      (<any>this).isSealed = _data["isSealed"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      (<any>this).isClass = _data["isClass"];
      (<any>this).isNestedAssembly = _data["isNestedAssembly"];
      (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
      (<any>this).isNestedFamily = _data["isNestedFamily"];
      (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
      (<any>this).isNestedPrivate = _data["isNestedPrivate"];
      (<any>this).isNestedPublic = _data["isNestedPublic"];
      (<any>this).isNotPublic = _data["isNotPublic"];
      (<any>this).isPublic = _data["isPublic"];
      (<any>this).isAutoLayout = _data["isAutoLayout"];
      (<any>this).isExplicitLayout = _data["isExplicitLayout"];
      (<any>this).isLayoutSequential = _data["isLayoutSequential"];
      (<any>this).isAnsiClass = _data["isAnsiClass"];
      (<any>this).isAutoClass = _data["isAutoClass"];
      (<any>this).isUnicodeClass = _data["isUnicodeClass"];
      (<any>this).isCOMObject = _data["isCOMObject"];
      (<any>this).isContextful = _data["isContextful"];
      (<any>this).isEnum = _data["isEnum"];
      (<any>this).isMarshalByRef = _data["isMarshalByRef"];
      (<any>this).isPrimitive = _data["isPrimitive"];
      (<any>this).isValueType = _data["isValueType"];
      (<any>this).isSignatureType = _data["isSignatureType"];
      (<any>this).isSecurityCritical = _data["isSecurityCritical"];
      (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
      (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
      this.structLayoutAttribute = _data["structLayoutAttribute"]
        ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"])
        : <any>undefined;
      this.typeInitializer = _data["typeInitializer"]
        ? ConstructorInfo.fromJS(_data["typeInitializer"])
        : <any>undefined;
      this.typeHandle = _data["typeHandle"]
        ? RuntimeTypeHandle.fromJS(_data["typeHandle"])
        : <any>undefined;
      (<any>this).guid = _data["guid"];
      this.baseType = _data["baseType"]
        ? Type.fromJS(_data["baseType"])
        : <any>undefined;
      (<any>this).isSerializable = _data["isSerializable"];
      (<any>this).containsGenericParameters =
        _data["containsGenericParameters"];
      (<any>this).isVisible = _data["isVisible"];
    }
  }

  static fromJS(data: any): Type {
    data = typeof data === "object" ? data : {};
    let result = new Type();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["isInterface"] = this.isInterface;
    data["memberType"] = this.memberType;
    data["namespace"] = this.namespace;
    data["assemblyQualifiedName"] = this.assemblyQualifiedName;
    data["fullName"] = this.fullName;
    data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    data["isNested"] = this.isNested;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["declaringMethod"] = this.declaringMethod
      ? this.declaringMethod.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["underlyingSystemType"] = this.underlyingSystemType
      ? this.underlyingSystemType.toJSON()
      : <any>undefined;
    data["isTypeDefinition"] = this.isTypeDefinition;
    data["isArray"] = this.isArray;
    data["isByRef"] = this.isByRef;
    data["isPointer"] = this.isPointer;
    data["isConstructedGenericType"] = this.isConstructedGenericType;
    data["isGenericParameter"] = this.isGenericParameter;
    data["isGenericTypeParameter"] = this.isGenericTypeParameter;
    data["isGenericMethodParameter"] = this.isGenericMethodParameter;
    data["isGenericType"] = this.isGenericType;
    data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
    data["isSZArray"] = this.isSZArray;
    data["isVariableBoundArray"] = this.isVariableBoundArray;
    data["isByRefLike"] = this.isByRefLike;
    data["hasElementType"] = this.hasElementType;
    if (Array.isArray(this.genericTypeArguments)) {
      data["genericTypeArguments"] = [];
      for (let item of this.genericTypeArguments)
        data["genericTypeArguments"].push(item.toJSON());
    }
    data["genericParameterPosition"] = this.genericParameterPosition;
    data["genericParameterAttributes"] = this.genericParameterAttributes;
    data["attributes"] = this.attributes;
    data["isAbstract"] = this.isAbstract;
    data["isImport"] = this.isImport;
    data["isSealed"] = this.isSealed;
    data["isSpecialName"] = this.isSpecialName;
    data["isClass"] = this.isClass;
    data["isNestedAssembly"] = this.isNestedAssembly;
    data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
    data["isNestedFamily"] = this.isNestedFamily;
    data["isNestedFamORAssem"] = this.isNestedFamORAssem;
    data["isNestedPrivate"] = this.isNestedPrivate;
    data["isNestedPublic"] = this.isNestedPublic;
    data["isNotPublic"] = this.isNotPublic;
    data["isPublic"] = this.isPublic;
    data["isAutoLayout"] = this.isAutoLayout;
    data["isExplicitLayout"] = this.isExplicitLayout;
    data["isLayoutSequential"] = this.isLayoutSequential;
    data["isAnsiClass"] = this.isAnsiClass;
    data["isAutoClass"] = this.isAutoClass;
    data["isUnicodeClass"] = this.isUnicodeClass;
    data["isCOMObject"] = this.isCOMObject;
    data["isContextful"] = this.isContextful;
    data["isEnum"] = this.isEnum;
    data["isMarshalByRef"] = this.isMarshalByRef;
    data["isPrimitive"] = this.isPrimitive;
    data["isValueType"] = this.isValueType;
    data["isSignatureType"] = this.isSignatureType;
    data["isSecurityCritical"] = this.isSecurityCritical;
    data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
    data["isSecurityTransparent"] = this.isSecurityTransparent;
    data["structLayoutAttribute"] = this.structLayoutAttribute
      ? this.structLayoutAttribute.toJSON()
      : <any>undefined;
    data["typeInitializer"] = this.typeInitializer
      ? this.typeInitializer.toJSON()
      : <any>undefined;
    data["typeHandle"] = this.typeHandle
      ? this.typeHandle.toJSON()
      : <any>undefined;
    data["guid"] = this.guid;
    data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
    data["isSerializable"] = this.isSerializable;
    data["containsGenericParameters"] = this.containsGenericParameters;
    data["isVisible"] = this.isVisible;
    return data;
  }

  clone(): Type {
    const json = this.toJSON();
    let result = new Type();
    result.init(json);
    return result;
  }
}

export interface IType {
  name: string | undefined;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  isInterface: boolean;
  memberType: MemberTypes;
  namespace: string | undefined;
  assemblyQualifiedName: string | undefined;
  fullName: string | undefined;
  assembly: Assembly;
  module: Module;
  isNested: boolean;
  declaringType: Type;
  declaringMethod: MethodBase;
  reflectedType: Type;
  underlyingSystemType: Type;
  isTypeDefinition: boolean;
  isArray: boolean;
  isByRef: boolean;
  isPointer: boolean;
  isConstructedGenericType: boolean;
  isGenericParameter: boolean;
  isGenericTypeParameter: boolean;
  isGenericMethodParameter: boolean;
  isGenericType: boolean;
  isGenericTypeDefinition: boolean;
  isSZArray: boolean;
  isVariableBoundArray: boolean;
  isByRefLike: boolean;
  hasElementType: boolean;
  genericTypeArguments: Type[] | undefined;
  genericParameterPosition: number;
  genericParameterAttributes: GenericParameterAttributes;
  attributes: TypeAttributes;
  isAbstract: boolean;
  isImport: boolean;
  isSealed: boolean;
  isSpecialName: boolean;
  isClass: boolean;
  isNestedAssembly: boolean;
  isNestedFamANDAssem: boolean;
  isNestedFamily: boolean;
  isNestedFamORAssem: boolean;
  isNestedPrivate: boolean;
  isNestedPublic: boolean;
  isNotPublic: boolean;
  isPublic: boolean;
  isAutoLayout: boolean;
  isExplicitLayout: boolean;
  isLayoutSequential: boolean;
  isAnsiClass: boolean;
  isAutoClass: boolean;
  isUnicodeClass: boolean;
  isCOMObject: boolean;
  isContextful: boolean;
  isEnum: boolean;
  isMarshalByRef: boolean;
  isPrimitive: boolean;
  isValueType: boolean;
  isSignatureType: boolean;
  isSecurityCritical: boolean;
  isSecuritySafeCritical: boolean;
  isSecurityTransparent: boolean;
  structLayoutAttribute: StructLayoutAttribute;
  typeInitializer: ConstructorInfo;
  typeHandle: RuntimeTypeHandle;
  guid: string;
  baseType: Type;
  isSerializable: boolean;
  containsGenericParameters: boolean;
  isVisible: boolean;
}

export enum TypeAttributes {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7,
  _8 = 8,
  _16 = 16,
  _24 = 24,
  _32 = 32,
  _128 = 128,
  _256 = 256,
  _1024 = 1024,
  _2048 = 2048,
  _4096 = 4096,
  _8192 = 8192,
  _16384 = 16384,
  _65536 = 65536,
  _131072 = 131072,
  _196608 = 196608,
  _262144 = 262144,
  _264192 = 264192,
  _1048576 = 1048576,
  _12582912 = 12582912,
}

export class TypeInfo implements ITypeInfo {
  readonly name: string | undefined;
  readonly customAttributes: CustomAttributeData[] | undefined;
  readonly isCollectible: boolean;
  readonly metadataToken: number;
  readonly isInterface: boolean;
  memberType: MemberTypes;
  readonly namespace: string | undefined;
  readonly assemblyQualifiedName: string | undefined;
  readonly fullName: string | undefined;
  assembly: Assembly;
  module: Module;
  readonly isNested: boolean;
  declaringType: Type;
  declaringMethod: MethodBase;
  reflectedType: Type;
  underlyingSystemType: Type;
  readonly isTypeDefinition: boolean;
  readonly isArray: boolean;
  readonly isByRef: boolean;
  readonly isPointer: boolean;
  readonly isConstructedGenericType: boolean;
  readonly isGenericParameter: boolean;
  readonly isGenericTypeParameter: boolean;
  readonly isGenericMethodParameter: boolean;
  readonly isGenericType: boolean;
  readonly isGenericTypeDefinition: boolean;
  readonly isSZArray: boolean;
  readonly isVariableBoundArray: boolean;
  readonly isByRefLike: boolean;
  readonly hasElementType: boolean;
  readonly genericTypeArguments: Type[] | undefined;
  readonly genericParameterPosition: number;
  genericParameterAttributes: GenericParameterAttributes;
  attributes: TypeAttributes;
  readonly isAbstract: boolean;
  readonly isImport: boolean;
  readonly isSealed: boolean;
  readonly isSpecialName: boolean;
  readonly isClass: boolean;
  readonly isNestedAssembly: boolean;
  readonly isNestedFamANDAssem: boolean;
  readonly isNestedFamily: boolean;
  readonly isNestedFamORAssem: boolean;
  readonly isNestedPrivate: boolean;
  readonly isNestedPublic: boolean;
  readonly isNotPublic: boolean;
  readonly isPublic: boolean;
  readonly isAutoLayout: boolean;
  readonly isExplicitLayout: boolean;
  readonly isLayoutSequential: boolean;
  readonly isAnsiClass: boolean;
  readonly isAutoClass: boolean;
  readonly isUnicodeClass: boolean;
  readonly isCOMObject: boolean;
  readonly isContextful: boolean;
  readonly isEnum: boolean;
  readonly isMarshalByRef: boolean;
  readonly isPrimitive: boolean;
  readonly isValueType: boolean;
  readonly isSignatureType: boolean;
  readonly isSecurityCritical: boolean;
  readonly isSecuritySafeCritical: boolean;
  readonly isSecurityTransparent: boolean;
  structLayoutAttribute: StructLayoutAttribute;
  typeInitializer: ConstructorInfo;
  typeHandle: RuntimeTypeHandle;
  readonly guid: string;
  baseType: Type;
  readonly isSerializable: boolean;
  readonly containsGenericParameters: boolean;
  readonly isVisible: boolean;
  readonly genericTypeParameters: Type[] | undefined;
  readonly declaredConstructors: ConstructorInfo[] | undefined;
  readonly declaredEvents: EventInfo[] | undefined;
  readonly declaredFields: FieldInfo[] | undefined;
  readonly declaredMembers: MemberInfo[] | undefined;
  readonly declaredMethods: MethodInfo[] | undefined;
  readonly declaredNestedTypes: TypeInfo[] | undefined;
  readonly declaredProperties: PropertyInfo[] | undefined;
  readonly implementedInterfaces: Type[] | undefined;

  constructor(data?: ITypeInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).name = _data["name"];
      if (Array.isArray(_data["customAttributes"])) {
        (<any>this).customAttributes = [] as any;
        for (let item of _data["customAttributes"])
          (<any>this).customAttributes.push(CustomAttributeData.fromJS(item));
      }
      (<any>this).isCollectible = _data["isCollectible"];
      (<any>this).metadataToken = _data["metadataToken"];
      (<any>this).isInterface = _data["isInterface"];
      this.memberType = _data["memberType"];
      (<any>this).namespace = _data["namespace"];
      (<any>this).assemblyQualifiedName = _data["assemblyQualifiedName"];
      (<any>this).fullName = _data["fullName"];
      this.assembly = _data["assembly"]
        ? Assembly.fromJS(_data["assembly"])
        : <any>undefined;
      this.module = _data["module"]
        ? Module.fromJS(_data["module"])
        : <any>undefined;
      (<any>this).isNested = _data["isNested"];
      this.declaringType = _data["declaringType"]
        ? Type.fromJS(_data["declaringType"])
        : <any>undefined;
      this.declaringMethod = _data["declaringMethod"]
        ? MethodBase.fromJS(_data["declaringMethod"])
        : <any>undefined;
      this.reflectedType = _data["reflectedType"]
        ? Type.fromJS(_data["reflectedType"])
        : <any>undefined;
      this.underlyingSystemType = _data["underlyingSystemType"]
        ? Type.fromJS(_data["underlyingSystemType"])
        : <any>undefined;
      (<any>this).isTypeDefinition = _data["isTypeDefinition"];
      (<any>this).isArray = _data["isArray"];
      (<any>this).isByRef = _data["isByRef"];
      (<any>this).isPointer = _data["isPointer"];
      (<any>this).isConstructedGenericType = _data["isConstructedGenericType"];
      (<any>this).isGenericParameter = _data["isGenericParameter"];
      (<any>this).isGenericTypeParameter = _data["isGenericTypeParameter"];
      (<any>this).isGenericMethodParameter = _data["isGenericMethodParameter"];
      (<any>this).isGenericType = _data["isGenericType"];
      (<any>this).isGenericTypeDefinition = _data["isGenericTypeDefinition"];
      (<any>this).isSZArray = _data["isSZArray"];
      (<any>this).isVariableBoundArray = _data["isVariableBoundArray"];
      (<any>this).isByRefLike = _data["isByRefLike"];
      (<any>this).hasElementType = _data["hasElementType"];
      if (Array.isArray(_data["genericTypeArguments"])) {
        (<any>this).genericTypeArguments = [] as any;
        for (let item of _data["genericTypeArguments"])
          (<any>this).genericTypeArguments.push(Type.fromJS(item));
      }
      (<any>this).genericParameterPosition = _data["genericParameterPosition"];
      this.genericParameterAttributes = _data["genericParameterAttributes"];
      this.attributes = _data["attributes"];
      (<any>this).isAbstract = _data["isAbstract"];
      (<any>this).isImport = _data["isImport"];
      (<any>this).isSealed = _data["isSealed"];
      (<any>this).isSpecialName = _data["isSpecialName"];
      (<any>this).isClass = _data["isClass"];
      (<any>this).isNestedAssembly = _data["isNestedAssembly"];
      (<any>this).isNestedFamANDAssem = _data["isNestedFamANDAssem"];
      (<any>this).isNestedFamily = _data["isNestedFamily"];
      (<any>this).isNestedFamORAssem = _data["isNestedFamORAssem"];
      (<any>this).isNestedPrivate = _data["isNestedPrivate"];
      (<any>this).isNestedPublic = _data["isNestedPublic"];
      (<any>this).isNotPublic = _data["isNotPublic"];
      (<any>this).isPublic = _data["isPublic"];
      (<any>this).isAutoLayout = _data["isAutoLayout"];
      (<any>this).isExplicitLayout = _data["isExplicitLayout"];
      (<any>this).isLayoutSequential = _data["isLayoutSequential"];
      (<any>this).isAnsiClass = _data["isAnsiClass"];
      (<any>this).isAutoClass = _data["isAutoClass"];
      (<any>this).isUnicodeClass = _data["isUnicodeClass"];
      (<any>this).isCOMObject = _data["isCOMObject"];
      (<any>this).isContextful = _data["isContextful"];
      (<any>this).isEnum = _data["isEnum"];
      (<any>this).isMarshalByRef = _data["isMarshalByRef"];
      (<any>this).isPrimitive = _data["isPrimitive"];
      (<any>this).isValueType = _data["isValueType"];
      (<any>this).isSignatureType = _data["isSignatureType"];
      (<any>this).isSecurityCritical = _data["isSecurityCritical"];
      (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
      (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
      this.structLayoutAttribute = _data["structLayoutAttribute"]
        ? StructLayoutAttribute.fromJS(_data["structLayoutAttribute"])
        : <any>undefined;
      this.typeInitializer = _data["typeInitializer"]
        ? ConstructorInfo.fromJS(_data["typeInitializer"])
        : <any>undefined;
      this.typeHandle = _data["typeHandle"]
        ? RuntimeTypeHandle.fromJS(_data["typeHandle"])
        : <any>undefined;
      (<any>this).guid = _data["guid"];
      this.baseType = _data["baseType"]
        ? Type.fromJS(_data["baseType"])
        : <any>undefined;
      (<any>this).isSerializable = _data["isSerializable"];
      (<any>this).containsGenericParameters =
        _data["containsGenericParameters"];
      (<any>this).isVisible = _data["isVisible"];
      if (Array.isArray(_data["genericTypeParameters"])) {
        (<any>this).genericTypeParameters = [] as any;
        for (let item of _data["genericTypeParameters"])
          (<any>this).genericTypeParameters.push(Type.fromJS(item));
      }
      if (Array.isArray(_data["declaredConstructors"])) {
        (<any>this).declaredConstructors = [] as any;
        for (let item of _data["declaredConstructors"])
          (<any>this).declaredConstructors.push(ConstructorInfo.fromJS(item));
      }
      if (Array.isArray(_data["declaredEvents"])) {
        (<any>this).declaredEvents = [] as any;
        for (let item of _data["declaredEvents"])
          (<any>this).declaredEvents.push(EventInfo.fromJS(item));
      }
      if (Array.isArray(_data["declaredFields"])) {
        (<any>this).declaredFields = [] as any;
        for (let item of _data["declaredFields"])
          (<any>this).declaredFields.push(FieldInfo.fromJS(item));
      }
      if (Array.isArray(_data["declaredMembers"])) {
        (<any>this).declaredMembers = [] as any;
        for (let item of _data["declaredMembers"])
          (<any>this).declaredMembers.push(MemberInfo.fromJS(item));
      }
      if (Array.isArray(_data["declaredMethods"])) {
        (<any>this).declaredMethods = [] as any;
        for (let item of _data["declaredMethods"])
          (<any>this).declaredMethods.push(MethodInfo.fromJS(item));
      }
      if (Array.isArray(_data["declaredNestedTypes"])) {
        (<any>this).declaredNestedTypes = [] as any;
        for (let item of _data["declaredNestedTypes"])
          (<any>this).declaredNestedTypes.push(TypeInfo.fromJS(item));
      }
      if (Array.isArray(_data["declaredProperties"])) {
        (<any>this).declaredProperties = [] as any;
        for (let item of _data["declaredProperties"])
          (<any>this).declaredProperties.push(PropertyInfo.fromJS(item));
      }
      if (Array.isArray(_data["implementedInterfaces"])) {
        (<any>this).implementedInterfaces = [] as any;
        for (let item of _data["implementedInterfaces"])
          (<any>this).implementedInterfaces.push(Type.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TypeInfo {
    data = typeof data === "object" ? data : {};
    let result = new TypeInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    if (Array.isArray(this.customAttributes)) {
      data["customAttributes"] = [];
      for (let item of this.customAttributes)
        data["customAttributes"].push(item.toJSON());
    }
    data["isCollectible"] = this.isCollectible;
    data["metadataToken"] = this.metadataToken;
    data["isInterface"] = this.isInterface;
    data["memberType"] = this.memberType;
    data["namespace"] = this.namespace;
    data["assemblyQualifiedName"] = this.assemblyQualifiedName;
    data["fullName"] = this.fullName;
    data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
    data["module"] = this.module ? this.module.toJSON() : <any>undefined;
    data["isNested"] = this.isNested;
    data["declaringType"] = this.declaringType
      ? this.declaringType.toJSON()
      : <any>undefined;
    data["declaringMethod"] = this.declaringMethod
      ? this.declaringMethod.toJSON()
      : <any>undefined;
    data["reflectedType"] = this.reflectedType
      ? this.reflectedType.toJSON()
      : <any>undefined;
    data["underlyingSystemType"] = this.underlyingSystemType
      ? this.underlyingSystemType.toJSON()
      : <any>undefined;
    data["isTypeDefinition"] = this.isTypeDefinition;
    data["isArray"] = this.isArray;
    data["isByRef"] = this.isByRef;
    data["isPointer"] = this.isPointer;
    data["isConstructedGenericType"] = this.isConstructedGenericType;
    data["isGenericParameter"] = this.isGenericParameter;
    data["isGenericTypeParameter"] = this.isGenericTypeParameter;
    data["isGenericMethodParameter"] = this.isGenericMethodParameter;
    data["isGenericType"] = this.isGenericType;
    data["isGenericTypeDefinition"] = this.isGenericTypeDefinition;
    data["isSZArray"] = this.isSZArray;
    data["isVariableBoundArray"] = this.isVariableBoundArray;
    data["isByRefLike"] = this.isByRefLike;
    data["hasElementType"] = this.hasElementType;
    if (Array.isArray(this.genericTypeArguments)) {
      data["genericTypeArguments"] = [];
      for (let item of this.genericTypeArguments)
        data["genericTypeArguments"].push(item.toJSON());
    }
    data["genericParameterPosition"] = this.genericParameterPosition;
    data["genericParameterAttributes"] = this.genericParameterAttributes;
    data["attributes"] = this.attributes;
    data["isAbstract"] = this.isAbstract;
    data["isImport"] = this.isImport;
    data["isSealed"] = this.isSealed;
    data["isSpecialName"] = this.isSpecialName;
    data["isClass"] = this.isClass;
    data["isNestedAssembly"] = this.isNestedAssembly;
    data["isNestedFamANDAssem"] = this.isNestedFamANDAssem;
    data["isNestedFamily"] = this.isNestedFamily;
    data["isNestedFamORAssem"] = this.isNestedFamORAssem;
    data["isNestedPrivate"] = this.isNestedPrivate;
    data["isNestedPublic"] = this.isNestedPublic;
    data["isNotPublic"] = this.isNotPublic;
    data["isPublic"] = this.isPublic;
    data["isAutoLayout"] = this.isAutoLayout;
    data["isExplicitLayout"] = this.isExplicitLayout;
    data["isLayoutSequential"] = this.isLayoutSequential;
    data["isAnsiClass"] = this.isAnsiClass;
    data["isAutoClass"] = this.isAutoClass;
    data["isUnicodeClass"] = this.isUnicodeClass;
    data["isCOMObject"] = this.isCOMObject;
    data["isContextful"] = this.isContextful;
    data["isEnum"] = this.isEnum;
    data["isMarshalByRef"] = this.isMarshalByRef;
    data["isPrimitive"] = this.isPrimitive;
    data["isValueType"] = this.isValueType;
    data["isSignatureType"] = this.isSignatureType;
    data["isSecurityCritical"] = this.isSecurityCritical;
    data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
    data["isSecurityTransparent"] = this.isSecurityTransparent;
    data["structLayoutAttribute"] = this.structLayoutAttribute
      ? this.structLayoutAttribute.toJSON()
      : <any>undefined;
    data["typeInitializer"] = this.typeInitializer
      ? this.typeInitializer.toJSON()
      : <any>undefined;
    data["typeHandle"] = this.typeHandle
      ? this.typeHandle.toJSON()
      : <any>undefined;
    data["guid"] = this.guid;
    data["baseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
    data["isSerializable"] = this.isSerializable;
    data["containsGenericParameters"] = this.containsGenericParameters;
    data["isVisible"] = this.isVisible;
    if (Array.isArray(this.genericTypeParameters)) {
      data["genericTypeParameters"] = [];
      for (let item of this.genericTypeParameters)
        data["genericTypeParameters"].push(item.toJSON());
    }
    if (Array.isArray(this.declaredConstructors)) {
      data["declaredConstructors"] = [];
      for (let item of this.declaredConstructors)
        data["declaredConstructors"].push(item.toJSON());
    }
    if (Array.isArray(this.declaredEvents)) {
      data["declaredEvents"] = [];
      for (let item of this.declaredEvents)
        data["declaredEvents"].push(item.toJSON());
    }
    if (Array.isArray(this.declaredFields)) {
      data["declaredFields"] = [];
      for (let item of this.declaredFields)
        data["declaredFields"].push(item.toJSON());
    }
    if (Array.isArray(this.declaredMembers)) {
      data["declaredMembers"] = [];
      for (let item of this.declaredMembers)
        data["declaredMembers"].push(item.toJSON());
    }
    if (Array.isArray(this.declaredMethods)) {
      data["declaredMethods"] = [];
      for (let item of this.declaredMethods)
        data["declaredMethods"].push(item.toJSON());
    }
    if (Array.isArray(this.declaredNestedTypes)) {
      data["declaredNestedTypes"] = [];
      for (let item of this.declaredNestedTypes)
        data["declaredNestedTypes"].push(item.toJSON());
    }
    if (Array.isArray(this.declaredProperties)) {
      data["declaredProperties"] = [];
      for (let item of this.declaredProperties)
        data["declaredProperties"].push(item.toJSON());
    }
    if (Array.isArray(this.implementedInterfaces)) {
      data["implementedInterfaces"] = [];
      for (let item of this.implementedInterfaces)
        data["implementedInterfaces"].push(item.toJSON());
    }
    return data;
  }

  clone(): TypeInfo {
    const json = this.toJSON();
    let result = new TypeInfo();
    result.init(json);
    return result;
  }
}

export interface ITypeInfo {
  name: string | undefined;
  customAttributes: CustomAttributeData[] | undefined;
  isCollectible: boolean;
  metadataToken: number;
  isInterface: boolean;
  memberType: MemberTypes;
  namespace: string | undefined;
  assemblyQualifiedName: string | undefined;
  fullName: string | undefined;
  assembly: Assembly;
  module: Module;
  isNested: boolean;
  declaringType: Type;
  declaringMethod: MethodBase;
  reflectedType: Type;
  underlyingSystemType: Type;
  isTypeDefinition: boolean;
  isArray: boolean;
  isByRef: boolean;
  isPointer: boolean;
  isConstructedGenericType: boolean;
  isGenericParameter: boolean;
  isGenericTypeParameter: boolean;
  isGenericMethodParameter: boolean;
  isGenericType: boolean;
  isGenericTypeDefinition: boolean;
  isSZArray: boolean;
  isVariableBoundArray: boolean;
  isByRefLike: boolean;
  hasElementType: boolean;
  genericTypeArguments: Type[] | undefined;
  genericParameterPosition: number;
  genericParameterAttributes: GenericParameterAttributes;
  attributes: TypeAttributes;
  isAbstract: boolean;
  isImport: boolean;
  isSealed: boolean;
  isSpecialName: boolean;
  isClass: boolean;
  isNestedAssembly: boolean;
  isNestedFamANDAssem: boolean;
  isNestedFamily: boolean;
  isNestedFamORAssem: boolean;
  isNestedPrivate: boolean;
  isNestedPublic: boolean;
  isNotPublic: boolean;
  isPublic: boolean;
  isAutoLayout: boolean;
  isExplicitLayout: boolean;
  isLayoutSequential: boolean;
  isAnsiClass: boolean;
  isAutoClass: boolean;
  isUnicodeClass: boolean;
  isCOMObject: boolean;
  isContextful: boolean;
  isEnum: boolean;
  isMarshalByRef: boolean;
  isPrimitive: boolean;
  isValueType: boolean;
  isSignatureType: boolean;
  isSecurityCritical: boolean;
  isSecuritySafeCritical: boolean;
  isSecurityTransparent: boolean;
  structLayoutAttribute: StructLayoutAttribute;
  typeInitializer: ConstructorInfo;
  typeHandle: RuntimeTypeHandle;
  guid: string;
  baseType: Type;
  isSerializable: boolean;
  containsGenericParameters: boolean;
  isVisible: boolean;
  genericTypeParameters: Type[] | undefined;
  declaredConstructors: ConstructorInfo[] | undefined;
  declaredEvents: EventInfo[] | undefined;
  declaredFields: FieldInfo[] | undefined;
  declaredMembers: MemberInfo[] | undefined;
  declaredMethods: MethodInfo[] | undefined;
  declaredNestedTypes: TypeInfo[] | undefined;
  declaredProperties: PropertyInfo[] | undefined;
  implementedInterfaces: Type[] | undefined;
}

export class UpdateAccountTypeRequest implements IUpdateAccountTypeRequest {
  financialAccountType1: string | undefined;
  id: number;

  constructor(data?: IUpdateAccountTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialAccountType1 = _data["financialAccountType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAccountTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAccountTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialAccountType1"] = this.financialAccountType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAccountTypeRequest {
    const json = this.toJSON();
    let result = new UpdateAccountTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateAccountTypeRequest {
  financialAccountType1: string | undefined;
  id: number;
}

export class UpdateAdminDisclosure implements IUpdateAdminDisclosure {
  title: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminDisclosure) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminDisclosure {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminDisclosure();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["title"] = this.title;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminDisclosure {
    const json = this.toJSON();
    let result = new UpdateAdminDisclosure();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminDisclosure {
  title: string | undefined;
  id: number;
}

export class UpdateAdminLoanApplicationDocument
  implements IUpdateAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number | undefined;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanApplicationDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.disclosureId = _data["disclosureId"];
      this.userId = _data["userId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
      this.documentPath = _data["documentPath"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanApplicationDocument {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanApplicationDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["disclosureId"] = this.disclosureId;
    data["userId"] = this.userId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    data["documentPath"] = this.documentPath;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanApplicationDocument {
    const json = this.toJSON();
    let result = new UpdateAdminLoanApplicationDocument();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number | undefined;
  updatedOn: moment.Moment | undefined;
  documentPath: string | undefined;
  id: number;
}

export class UpdateAdminLoanDetail implements IUpdateAdminLoanDetail {
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanApplicationId = _data["loanApplicationId"];
      this.loanNo = _data["loanNo"];
      this.mortageConsultant = _data["mortageConsultant"];
      this.nmlsId = _data["nmlsId"];
      this.borrowerName = _data["borrowerName"];
      this.propertyAddress = _data["propertyAddress"];
      this.loanProgramId = _data["loanProgramId"];
      this.loanAmount = _data["loanAmount"];
      this.loanPurpose = _data["loanPurpose"];
      this.interestRate = _data["interestRate"];
      this.applicationDate = _data["applicationDate"]
        ? moment(_data["applicationDate"].toString())
        : <any>undefined;
      this.rateLockDate = _data["rateLockDate"]
        ? moment(_data["rateLockDate"].toString())
        : <any>undefined;
      this.rateLockExpirationDate = _data["rateLockExpirationDate"]
        ? moment(_data["rateLockExpirationDate"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanDetail {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanApplicationId"] = this.loanApplicationId;
    data["loanNo"] = this.loanNo;
    data["mortageConsultant"] = this.mortageConsultant;
    data["nmlsId"] = this.nmlsId;
    data["borrowerName"] = this.borrowerName;
    data["propertyAddress"] = this.propertyAddress;
    data["loanProgramId"] = this.loanProgramId;
    data["loanAmount"] = this.loanAmount;
    data["loanPurpose"] = this.loanPurpose;
    data["interestRate"] = this.interestRate;
    data["applicationDate"] = this.applicationDate
      ? this.applicationDate.toISOString()
      : <any>undefined;
    data["rateLockDate"] = this.rateLockDate
      ? this.rateLockDate.toISOString()
      : <any>undefined;
    data["rateLockExpirationDate"] = this.rateLockExpirationDate
      ? this.rateLockExpirationDate.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanDetail {
    const json = this.toJSON();
    let result = new UpdateAdminLoanDetail();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanDetail {
  loanApplicationId: number;
  loanNo: string | undefined;
  mortageConsultant: string | undefined;
  nmlsId: string | undefined;
  borrowerName: string | undefined;
  propertyAddress: string | undefined;
  loanProgramId: number;
  loanAmount: number | undefined;
  loanPurpose: string | undefined;
  interestRate: number | undefined;
  applicationDate: moment.Moment | undefined;
  rateLockDate: moment.Moment | undefined;
  rateLockExpirationDate: moment.Moment | undefined;
  id: number;
}

export class UpdateAdminLoanProgram implements IUpdateAdminLoanProgram {
  loanProgram: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanProgram) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanProgram = _data["loanProgram"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanProgram {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanProgram();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanProgram"] = this.loanProgram;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanProgram {
    const json = this.toJSON();
    let result = new UpdateAdminLoanProgram();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanProgram {
  loanProgram: string | undefined;
  id: number;
}

export class UpdateAdminLoanStatus implements IUpdateAdminLoanStatus {
  status: string | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data["status"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanStatus {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["status"] = this.status;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanStatus {
    const json = this.toJSON();
    let result = new UpdateAdminLoanStatus();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanStatus {
  status: string | undefined;
  id: number;
}

export class UpdateAdminLoanSummaryStatus
  implements IUpdateAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateAdminLoanSummaryStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.statusId = _data["statusId"];
      this.updatedOn = _data["updatedOn"]
        ? moment(_data["updatedOn"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminLoanSummaryStatus {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminLoanSummaryStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["statusId"] = this.statusId;
    data["updatedOn"] = this.updatedOn
      ? this.updatedOn.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminLoanSummaryStatus {
    const json = this.toJSON();
    let result = new UpdateAdminLoanSummaryStatus();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminLoanSummaryStatus {
  loanId: number;
  statusId: number;
  updatedOn: moment.Moment | undefined;
  id: number;
}

export class UpdateAdminUserEnabledDevice
  implements IUpdateAdminUserEnabledDevice {
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;
  id: number;

  constructor(data?: IUpdateAdminUserEnabledDevice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deviceId = _data["deviceId"];
      this.bioMetricData = _data["bioMetricData"];
      this.isEnabled = _data["isEnabled"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateAdminUserEnabledDevice {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminUserEnabledDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["deviceId"] = this.deviceId;
    data["bioMetricData"] = this.bioMetricData;
    data["isEnabled"] = this.isEnabled;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateAdminUserEnabledDevice {
    const json = this.toJSON();
    let result = new UpdateAdminUserEnabledDevice();
    result.init(json);
    return result;
  }
}

export interface IUpdateAdminUserEnabledDevice {
  deviceId: string | undefined;
  bioMetricData: string | undefined;
  isEnabled: number | undefined;
  id: number;
}

export class UpdateCitizenshipTypeRequest
  implements IUpdateCitizenshipTypeRequest {
  citizenshipType1: string | undefined;
  id: number;

  constructor(data?: IUpdateCitizenshipTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.citizenshipType1 = _data["citizenshipType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCitizenshipTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCitizenshipTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["citizenshipType1"] = this.citizenshipType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCitizenshipTypeRequest {
    const json = this.toJSON();
    let result = new UpdateCitizenshipTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCitizenshipTypeRequest {
  citizenshipType1: string | undefined;
  id: number;
}

export class UpdateCityRequest implements IUpdateCityRequest {
  stateId: number;
  cityName: string | undefined;
  id: number;

  constructor(data?: IUpdateCityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stateId = _data["stateId"];
      this.cityName = _data["cityName"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCityRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stateId"] = this.stateId;
    data["cityName"] = this.cityName;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCityRequest {
    const json = this.toJSON();
    let result = new UpdateCityRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCityRequest {
  stateId: number;
  cityName: string | undefined;
  id: number;
}

export class UpdateCountryRequest implements IUpdateCountryRequest {
  countryName: string | undefined;
  id: number;

  constructor(data?: IUpdateCountryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryName = _data["countryName"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCountryRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCountryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryName"] = this.countryName;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCountryRequest {
    const json = this.toJSON();
    let result = new UpdateCountryRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCountryRequest {
  countryName: string | undefined;
  id: number;
}

export class UpdateCreditTypeRequest implements IUpdateCreditTypeRequest {
  creditType1: string | undefined;
  id: number;

  constructor(data?: IUpdateCreditTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creditType1 = _data["creditType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateCreditTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCreditTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["creditType1"] = this.creditType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateCreditTypeRequest {
    const json = this.toJSON();
    let result = new UpdateCreditTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateCreditTypeRequest {
  creditType1: string | undefined;
  id: number;
}

export class UpdateDeclarationCategoryRequest
  implements IUpdateDeclarationCategoryRequest {
  declarationCategory1: string | undefined;
  id: number;

  constructor(data?: IUpdateDeclarationCategoryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategory1 = _data["declarationCategory1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDeclarationCategoryRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDeclarationCategoryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategory1"] = this.declarationCategory1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDeclarationCategoryRequest {
    const json = this.toJSON();
    let result = new UpdateDeclarationCategoryRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDeclarationCategoryRequest {
  declarationCategory1: string | undefined;
  id: number;
}

export class UpdateDeclarationQuestionRequest
  implements IUpdateDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;
  id: number;

  constructor(data?: IUpdateDeclarationQuestionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationCategoryId = _data["declarationCategoryId"];
      this.parentQuestionId = _data["parentQuestionId"];
      this.question = _data["question"];
      this.isActive = _data["isActive"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDeclarationQuestionRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDeclarationQuestionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationCategoryId"] = this.declarationCategoryId;
    data["parentQuestionId"] = this.parentQuestionId;
    data["question"] = this.question;
    data["isActive"] = this.isActive;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDeclarationQuestionRequest {
    const json = this.toJSON();
    let result = new UpdateDeclarationQuestionRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDeclarationQuestionRequest {
  declarationCategoryId: number | undefined;
  parentQuestionId: number | undefined;
  question: string | undefined;
  isActive: number | undefined;
  id: number;
}

export class UpdateDemographicInfoSourceRequest
  implements IUpdateDemographicInfoSourceRequest {
  value: string | undefined;
  id: number;

  constructor(data?: IUpdateDemographicInfoSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDemographicInfoSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDemographicInfoSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDemographicInfoSourceRequest {
    const json = this.toJSON();
    let result = new UpdateDemographicInfoSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDemographicInfoSourceRequest {
  value: string | undefined;
  id: number;
}

export class UpdateDemographicInformationRequest
  implements IUpdateDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;
  id: number;

  constructor(data?: IUpdateDemographicInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.ethnicity81 = _data["ethnicity81"];
      this.gender82 = _data["gender82"];
      this.race83 = _data["race83"];
      this.isEthnicityByObservation84 = _data["isEthnicityByObservation84"];
      this.isGenderByObservation85 = _data["isGenderByObservation85"];
      this.isRaceByObservation86 = _data["isRaceByObservation86"];
      this.demographicInfoSourceId87 = _data["demographicInfoSourceId87"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateDemographicInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDemographicInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["ethnicity81"] = this.ethnicity81;
    data["gender82"] = this.gender82;
    data["race83"] = this.race83;
    data["isEthnicityByObservation84"] = this.isEthnicityByObservation84;
    data["isGenderByObservation85"] = this.isGenderByObservation85;
    data["isRaceByObservation86"] = this.isRaceByObservation86;
    data["demographicInfoSourceId87"] = this.demographicInfoSourceId87;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateDemographicInformationRequest {
    const json = this.toJSON();
    let result = new UpdateDemographicInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateDemographicInformationRequest {
  applicationPersonalInformationId: number | undefined;
  ethnicity81: string | undefined;
  gender82: string | undefined;
  race83: string | undefined;
  isEthnicityByObservation84: number | undefined;
  isGenderByObservation85: number | undefined;
  isRaceByObservation86: number | undefined;
  demographicInfoSourceId87: number | undefined;
  id: number;
}

export class UpdateHousingTypeRequest implements IUpdateHousingTypeRequest {
  housingType1: string | undefined;
  id: number;

  constructor(data?: IUpdateHousingTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.housingType1 = _data["housingType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateHousingTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateHousingTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["housingType1"] = this.housingType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateHousingTypeRequest {
    const json = this.toJSON();
    let result = new UpdateHousingTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateHousingTypeRequest {
  housingType1: string | undefined;
  id: number;
}

export class UpdateIncomeSourceRequest implements IUpdateIncomeSourceRequest {
  incomeSource1: string | undefined;
  id: number;

  constructor(data?: IUpdateIncomeSourceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeSource1 = _data["incomeSource1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateIncomeSourceRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateIncomeSourceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeSource1"] = this.incomeSource1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateIncomeSourceRequest {
    const json = this.toJSON();
    let result = new UpdateIncomeSourceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateIncomeSourceRequest {
  incomeSource1: string | undefined;
  id: number;
}

export class UpdateIncomeTypeRequest implements IUpdateIncomeTypeRequest {
  incomeType1: string | undefined;
  id: number;

  constructor(data?: IUpdateIncomeTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType1 = _data["incomeType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateIncomeTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateIncomeTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType1"] = this.incomeType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateIncomeTypeRequest {
    const json = this.toJSON();
    let result = new UpdateIncomeTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateIncomeTypeRequest {
  incomeType1: string | undefined;
  id: number;
}

export class UpdateLaibilitiesTypeRequest
  implements IUpdateLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;
  id: number;

  constructor(data?: IUpdateLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialLaibilitiesType1 = _data["financialLaibilitiesType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialLaibilitiesType1"] = this.financialLaibilitiesType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new UpdateLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLaibilitiesTypeRequest {
  financialLaibilitiesType1: string | undefined;
  id: number;
}

export class UpdateLeadApplicationQuestions
  implements IUpdateLeadApplicationQuestions {
  question: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadApplicationQuestions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.question = _data["question"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadApplicationQuestions {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadApplicationQuestions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["question"] = this.question;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadApplicationQuestions {
    const json = this.toJSON();
    let result = new UpdateLeadApplicationQuestions();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadApplicationQuestions {
  question: string | undefined;
  id: number;
}

export class UpdateLeadApplicationType implements IUpdateLeadApplicationType {
  applicationType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadApplicationType) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationType = _data["applicationType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadApplicationType {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadApplicationType();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["applicationType"] = this.applicationType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadApplicationType {
    const json = this.toJSON();
    let result = new UpdateLeadApplicationType();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadApplicationType {
  applicationType: string | undefined;
  id: number;
}

export class UpdateLeadAssetDetails implements IUpdateLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;
  id: number;

  constructor(data?: IUpdateLeadAssetDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.assetTypeId = _data["assetTypeId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.financialInstitution = _data["financialInstitution"];
      this.balance = _data["balance"];
      this.ownerTypeId = _data["ownerTypeId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadAssetDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadAssetDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["assetTypeId"] = this.assetTypeId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["financialInstitution"] = this.financialInstitution;
    data["balance"] = this.balance;
    data["ownerTypeId"] = this.ownerTypeId;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadAssetDetails {
    const json = this.toJSON();
    let result = new UpdateLeadAssetDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadAssetDetails {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  assetTypeId: number;
  leadApplicationTypeId: number;
  financialInstitution: string | undefined;
  balance: number | undefined;
  ownerTypeId: number;
  id: number;
}

export class UpdateLeadAssetTypes implements IUpdateLeadAssetTypes {
  assetsType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadAssetTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.assetsType = _data["assetsType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadAssetTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadAssetTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["assetsType"] = this.assetsType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadAssetTypes {
    const json = this.toJSON();
    let result = new UpdateLeadAssetTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadAssetTypes {
  assetsType: string | undefined;
  id: number;
}

export class UpdateLeadEmploymentDetails
  implements IUpdateLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;
  id: number;

  constructor(data?: IUpdateLeadEmploymentDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employeeTypeId = _data["employeeTypeId"];
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.employerName = _data["employerName"];
      this.employementAddress = _data["employementAddress"];
      this.employementSuite = _data["employementSuite"];
      this.employementCity = _data["employementCity"];
      this.employementTaxeId = _data["employementTaxeId"];
      this.employementZip = _data["employementZip"];
      this.employerPhoneNumber = _data["employerPhoneNumber"];
      this.isCurrentJob = _data["isCurrentJob"];
      this.estimatedStartDate = _data["estimatedStartDate"]
        ? moment(_data["estimatedStartDate"].toString())
        : <any>undefined;
      this.jobTitle = _data["jobTitle"];
      this.estimatedAnnualBaseSalary = _data["estimatedAnnualBaseSalary"];
      this.estimatedAnnualBonus = _data["estimatedAnnualBonus"];
      this.estimatedAnnualCommission = _data["estimatedAnnualCommission"];
      this.estimatedAnnualOvertime = _data["estimatedAnnualOvertime"];
      this.isCoBorrower = _data["isCoBorrower"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadEmploymentDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadEmploymentDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employeeTypeId"] = this.employeeTypeId;
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["employerName"] = this.employerName;
    data["employementAddress"] = this.employementAddress;
    data["employementSuite"] = this.employementSuite;
    data["employementCity"] = this.employementCity;
    data["employementTaxeId"] = this.employementTaxeId;
    data["employementZip"] = this.employementZip;
    data["employerPhoneNumber"] = this.employerPhoneNumber;
    data["isCurrentJob"] = this.isCurrentJob;
    data["estimatedStartDate"] = this.estimatedStartDate
      ? this.estimatedStartDate.toISOString()
      : <any>undefined;
    data["jobTitle"] = this.jobTitle;
    data["estimatedAnnualBaseSalary"] = this.estimatedAnnualBaseSalary;
    data["estimatedAnnualBonus"] = this.estimatedAnnualBonus;
    data["estimatedAnnualCommission"] = this.estimatedAnnualCommission;
    data["estimatedAnnualOvertime"] = this.estimatedAnnualOvertime;
    data["isCoBorrower"] = this.isCoBorrower;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadEmploymentDetails {
    const json = this.toJSON();
    let result = new UpdateLeadEmploymentDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadEmploymentDetails {
  employeeTypeId: number;
  leadApplicationDetailPurchasingId: number | undefined;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number;
  employerName: string | undefined;
  employementAddress: string | undefined;
  employementSuite: string | undefined;
  employementCity: string | undefined;
  employementTaxeId: number;
  employementZip: string | undefined;
  employerPhoneNumber: string | undefined;
  isCurrentJob: number | undefined;
  estimatedStartDate: moment.Moment | undefined;
  jobTitle: string | undefined;
  estimatedAnnualBaseSalary: number | undefined;
  estimatedAnnualBonus: number | undefined;
  estimatedAnnualCommission: number | undefined;
  estimatedAnnualOvertime: number | undefined;
  isCoBorrower: number | undefined;
  id: number;
}

export class UpdateLeadEmploymentTypes implements IUpdateLeadEmploymentTypes {
  employementType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadEmploymentTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.employementType = _data["employementType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadEmploymentTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadEmploymentTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["employementType"] = this.employementType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadEmploymentTypes {
    const json = this.toJSON();
    let result = new UpdateLeadEmploymentTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadEmploymentTypes {
  employementType: string | undefined;
  id: number;
}

export class UpdateLeadIncomeTypes implements IUpdateLeadIncomeTypes {
  incomeType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadIncomeTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.incomeType = _data["incomeType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadIncomeTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadIncomeTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["incomeType"] = this.incomeType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadIncomeTypes {
    const json = this.toJSON();
    let result = new UpdateLeadIncomeTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadIncomeTypes {
  incomeType: string | undefined;
  id: number;
}

export class UpdateLeadOwnerTypes implements IUpdateLeadOwnerTypes {
  ownerType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadOwnerTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ownerType = _data["ownerType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadOwnerTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadOwnerTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ownerType"] = this.ownerType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadOwnerTypes {
    const json = this.toJSON();
    let result = new UpdateLeadOwnerTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadOwnerTypes {
  ownerType: string | undefined;
  id: number;
}

export class UpdateLeadPurchasingDetail implements IUpdateLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateLeadPurchasingDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.stage = _data["stage"];
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.newHomeAddress = _data["newHomeAddress"];
      this.newHomeUnit = _data["newHomeUnit"];
      this.newHomeCity = _data["newHomeCity"];
      this.newHomeStateId = _data["newHomeStateId"];
      this.newHomeZipCode = _data["newHomeZipCode"];
      this.contractClosingDate = _data["contractClosingDate"]
        ? moment(_data["contractClosingDate"].toString())
        : <any>undefined;
      this.contractType = _data["contractType"];
      this.estimatedHomePrice = _data["estimatedHomePrice"];
      this.downPaymentAmount = _data["downPaymentAmount"];
      this.downPaymentPercentage = _data["downPaymentPercentage"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.creditScore = _data["creditScore"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.typeOfNewHome = _data["typeOfNewHome"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isSomeOneRefer = _data["isSomeOneRefer"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isOtherSourceOfIncome = _data["isOtherSourceOfIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadPurchasingDetail {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadPurchasingDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["stage"] = this.stage;
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["newHomeAddress"] = this.newHomeAddress;
    data["newHomeUnit"] = this.newHomeUnit;
    data["newHomeCity"] = this.newHomeCity;
    data["newHomeStateId"] = this.newHomeStateId;
    data["newHomeZipCode"] = this.newHomeZipCode;
    data["contractClosingDate"] = this.contractClosingDate
      ? this.contractClosingDate.toISOString()
      : <any>undefined;
    data["contractType"] = this.contractType;
    data["estimatedHomePrice"] = this.estimatedHomePrice;
    data["downPaymentAmount"] = this.downPaymentAmount;
    data["downPaymentPercentage"] = this.downPaymentPercentage;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["creditScore"] = this.creditScore;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["typeOfNewHome"] = this.typeOfNewHome;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data["isSomeOneRefer"] = this.isSomeOneRefer;
    data["isApplyOwn"] = this.isApplyOwn;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isOtherSourceOfIncome"] = this.isOtherSourceOfIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadPurchasingDetail {
    const json = this.toJSON();
    let result = new UpdateLeadPurchasingDetail();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadPurchasingDetail {
  stage: string | undefined;
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  newHomeAddress: string | undefined;
  newHomeUnit: string | undefined;
  newHomeCity: string | undefined;
  newHomeStateId: number;
  newHomeZipCode: string | undefined;
  contractClosingDate: moment.Moment | undefined;
  contractType: string | undefined;
  estimatedHomePrice: number | undefined;
  downPaymentAmount: number | undefined;
  downPaymentPercentage: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  creditScore: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  typeOfNewHome: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isSomeOneRefer: number | undefined;
  isApplyOwn: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  isEmployementHistory: number | undefined;
  isOtherSourceOfIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;
}

export class UpdateLeadQuestionAnswers implements IUpdateLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;
  id: number;

  constructor(data?: IUpdateLeadQuestionAnswers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailPurchasingId =
        _data["leadApplicationDetailPurchasingId"];
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.questionId = _data["questionId"];
      this.isYes = _data["isYes"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadQuestionAnswers {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadQuestionAnswers();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailPurchasingId"
    ] = this.leadApplicationDetailPurchasingId;
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["questionId"] = this.questionId;
    data["isYes"] = this.isYes;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadQuestionAnswers {
    const json = this.toJSON();
    let result = new UpdateLeadQuestionAnswers();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadQuestionAnswers {
  leadApplicationDetailPurchasingId: number;
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  questionId: number;
  isYes: number | undefined;
  id: number;
}

export class UpdateLeadRefinancingDetails
  implements IUpdateLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateLeadRefinancingDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isWorkingWithEzalready = _data["isWorkingWithEzalready"];
      this.workingOfficerName = _data["workingOfficerName"];
      this.objectiveReason = _data["objectiveReason"];
      this.propertyAddress = _data["propertyAddress"];
      this.propertyUnit = _data["propertyUnit"];
      this.propertyCity = _data["propertyCity"];
      this.propertyZip = _data["propertyZip"];
      this.propertyStateId = _data["propertyStateId"];
      this.propertyCountryId = _data["propertyCountryId"];
      this.propertyEstimatedValue = _data["propertyEstimatedValue"];
      this.propertyLoanBalance = _data["propertyLoanBalance"];
      this.propertCashOutAmount = _data["propertCashOutAmount"];
      this.newLoanEstimateAmount = _data["newLoanEstimateAmount"];
      this.creditScore = _data["creditScore"];
      this.typeOfHome = _data["typeOfHome"];
      this.monthlyHoadues = _data["monthlyHoadues"];
      this.yearHomePurchased = _data["yearHomePurchased"];
      this.orignalPurchasedPrice = _data["orignalPurchasedPrice"];
      this.estimatedAnnualTax = _data["estimatedAnnualTax"];
      this.estimatedAnnualHomeInsurance = _data["estimatedAnnualHomeInsurance"];
      this.currentlyUsingHomeAs = _data["currentlyUsingHomeAs"];
      this.isMilitaryMember = _data["isMilitaryMember"];
      this.currentMilitaryStatus = _data["currentMilitaryStatus"];
      this.militaryBranch = _data["militaryBranch"];
      this.isEtsdateinYear = _data["isEtsdateinYear"];
      this.etsdate = _data["etsdate"]
        ? moment(_data["etsdate"].toString())
        : <any>undefined;
      this.isValoanPreviously = _data["isValoanPreviously"];
      this.whoLivingInHome = _data["whoLivingInHome"];
      this.propertyLegalFirstName = _data["propertyLegalFirstName"];
      this.propertyMiddleInitial = _data["propertyMiddleInitial"];
      this.propertyLegalLastName = _data["propertyLegalLastName"];
      this.propertyPhoneNumber = _data["propertyPhoneNumber"];
      this.propertyEmailAddress = _data["propertyEmailAddress"];
      this.propertyPassword = _data["propertyPassword"];
      this.isSomeoneRefer = _data["isSomeoneRefer"];
      this.refferedBy = _data["refferedBy"];
      this.isApplyOwn = _data["isApplyOwn"];
      this.isLegalSpouse = _data["isLegalSpouse"];
      this.maritialStatus = _data["maritialStatus"];
      this.numberOfDependents = _data["numberOfDependents"];
      this.firstDependantAge = _data["firstDependantAge"];
      this.isCurrentlyLivingOnRefinancingProperty =
        _data["isCurrentlyLivingOnRefinancingProperty"];
      this.currentAddress = _data["currentAddress"];
      this.currentUnit = _data["currentUnit"];
      this.currentCity = _data["currentCity"];
      this.currentStateId = _data["currentStateId"];
      this.currentZipCode = _data["currentZipCode"];
      this.currentStartLivingDate = _data["currentStartLivingDate"]
        ? moment(_data["currentStartLivingDate"].toString())
        : <any>undefined;
      this.currentReantingType = _data["currentReantingType"];
      this.estimatedMonthlyExpenses = _data["estimatedMonthlyExpenses"];
      this.personalLegalFirstName = _data["personalLegalFirstName"];
      this.personalMiddleInitial = _data["personalMiddleInitial"];
      this.personalLegalLastName = _data["personalLegalLastName"];
      this.personalPhoneNumber = _data["personalPhoneNumber"];
      this.personalEmailAddress = _data["personalEmailAddress"];
      this.personalPassword = _data["personalPassword"];
      this.isAddressSameAsPrimaryBorrower =
        _data["isAddressSameAsPrimaryBorrower"];
      this.personalAddress = _data["personalAddress"];
      this.personalUnit = _data["personalUnit"];
      this.personalCity = _data["personalCity"];
      this.personalStateId = _data["personalStateId"];
      this.personalZipCode = _data["personalZipCode"];
      this.personalStartLivingDate = _data["personalStartLivingDate"]
        ? moment(_data["personalStartLivingDate"].toString())
        : <any>undefined;
      this.personalReantingType = _data["personalReantingType"];
      this.isEmployementHistory = _data["isEmployementHistory"];
      this.isCoBorrowerHaveShareIncome = _data["isCoBorrowerHaveShareIncome"];
      this.sex = _data["sex"];
      this.ethnicity = _data["ethnicity"];
      this.race = _data["race"];
      this.citizenshipId = _data["citizenshipId"];
      this.isCertify = _data["isCertify"];
      this.isReadEconsent = _data["isReadEconsent"];
      this.isReadThirdPartyConsent = _data["isReadThirdPartyConsent"];
      this.socialSecurityNumber = _data["socialSecurityNumber"];
      this.conformSsn = _data["conformSsn"];
      this.birthDate = _data["birthDate"]
        ? moment(_data["birthDate"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadRefinancingDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadRefinancingDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isWorkingWithEzalready"] = this.isWorkingWithEzalready;
    data["workingOfficerName"] = this.workingOfficerName;
    data["objectiveReason"] = this.objectiveReason;
    data["propertyAddress"] = this.propertyAddress;
    data["propertyUnit"] = this.propertyUnit;
    data["propertyCity"] = this.propertyCity;
    data["propertyZip"] = this.propertyZip;
    data["propertyStateId"] = this.propertyStateId;
    data["propertyCountryId"] = this.propertyCountryId;
    data["propertyEstimatedValue"] = this.propertyEstimatedValue;
    data["propertyLoanBalance"] = this.propertyLoanBalance;
    data["propertCashOutAmount"] = this.propertCashOutAmount;
    data["newLoanEstimateAmount"] = this.newLoanEstimateAmount;
    data["creditScore"] = this.creditScore;
    data["typeOfHome"] = this.typeOfHome;
    data["monthlyHoadues"] = this.monthlyHoadues;
    data["yearHomePurchased"] = this.yearHomePurchased;
    data["orignalPurchasedPrice"] = this.orignalPurchasedPrice;
    data["estimatedAnnualTax"] = this.estimatedAnnualTax;
    data["estimatedAnnualHomeInsurance"] = this.estimatedAnnualHomeInsurance;
    data["currentlyUsingHomeAs"] = this.currentlyUsingHomeAs;
    data["isMilitaryMember"] = this.isMilitaryMember;
    data["currentMilitaryStatus"] = this.currentMilitaryStatus;
    data["militaryBranch"] = this.militaryBranch;
    data["isEtsdateinYear"] = this.isEtsdateinYear;
    data["etsdate"] = this.etsdate
      ? this.etsdate.toISOString()
      : <any>undefined;
    data["isValoanPreviously"] = this.isValoanPreviously;
    data["whoLivingInHome"] = this.whoLivingInHome;
    data["propertyLegalFirstName"] = this.propertyLegalFirstName;
    data["propertyMiddleInitial"] = this.propertyMiddleInitial;
    data["propertyLegalLastName"] = this.propertyLegalLastName;
    data["propertyPhoneNumber"] = this.propertyPhoneNumber;
    data["propertyEmailAddress"] = this.propertyEmailAddress;
    data["propertyPassword"] = this.propertyPassword;
    data["isSomeoneRefer"] = this.isSomeoneRefer;
    data["refferedBy"] = this.refferedBy;
    data["isApplyOwn"] = this.isApplyOwn;
    data["isLegalSpouse"] = this.isLegalSpouse;
    data["maritialStatus"] = this.maritialStatus;
    data["numberOfDependents"] = this.numberOfDependents;
    data["firstDependantAge"] = this.firstDependantAge;
    data[
      "isCurrentlyLivingOnRefinancingProperty"
    ] = this.isCurrentlyLivingOnRefinancingProperty;
    data["currentAddress"] = this.currentAddress;
    data["currentUnit"] = this.currentUnit;
    data["currentCity"] = this.currentCity;
    data["currentStateId"] = this.currentStateId;
    data["currentZipCode"] = this.currentZipCode;
    data["currentStartLivingDate"] = this.currentStartLivingDate
      ? this.currentStartLivingDate.toISOString()
      : <any>undefined;
    data["currentReantingType"] = this.currentReantingType;
    data["estimatedMonthlyExpenses"] = this.estimatedMonthlyExpenses;
    data["personalLegalFirstName"] = this.personalLegalFirstName;
    data["personalMiddleInitial"] = this.personalMiddleInitial;
    data["personalLegalLastName"] = this.personalLegalLastName;
    data["personalPhoneNumber"] = this.personalPhoneNumber;
    data["personalEmailAddress"] = this.personalEmailAddress;
    data["personalPassword"] = this.personalPassword;
    data[
      "isAddressSameAsPrimaryBorrower"
    ] = this.isAddressSameAsPrimaryBorrower;
    data["personalAddress"] = this.personalAddress;
    data["personalUnit"] = this.personalUnit;
    data["personalCity"] = this.personalCity;
    data["personalStateId"] = this.personalStateId;
    data["personalZipCode"] = this.personalZipCode;
    data["personalStartLivingDate"] = this.personalStartLivingDate
      ? this.personalStartLivingDate.toISOString()
      : <any>undefined;
    data["personalReantingType"] = this.personalReantingType;
    data["isEmployementHistory"] = this.isEmployementHistory;
    data["isCoBorrowerHaveShareIncome"] = this.isCoBorrowerHaveShareIncome;
    data["sex"] = this.sex;
    data["ethnicity"] = this.ethnicity;
    data["race"] = this.race;
    data["citizenshipId"] = this.citizenshipId;
    data["isCertify"] = this.isCertify;
    data["isReadEconsent"] = this.isReadEconsent;
    data["isReadThirdPartyConsent"] = this.isReadThirdPartyConsent;
    data["socialSecurityNumber"] = this.socialSecurityNumber;
    data["conformSsn"] = this.conformSsn;
    data["birthDate"] = this.birthDate
      ? this.birthDate.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadRefinancingDetails {
    const json = this.toJSON();
    let result = new UpdateLeadRefinancingDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadRefinancingDetails {
  isWorkingWithEzalready: number | undefined;
  workingOfficerName: string | undefined;
  objectiveReason: string | undefined;
  propertyAddress: string | undefined;
  propertyUnit: string | undefined;
  propertyCity: string | undefined;
  propertyZip: string | undefined;
  propertyStateId: number;
  propertyCountryId: number;
  propertyEstimatedValue: number | undefined;
  propertyLoanBalance: number | undefined;
  propertCashOutAmount: number | undefined;
  newLoanEstimateAmount: number | undefined;
  creditScore: string | undefined;
  typeOfHome: string | undefined;
  monthlyHoadues: number | undefined;
  yearHomePurchased: number | undefined;
  orignalPurchasedPrice: number | undefined;
  estimatedAnnualTax: number | undefined;
  estimatedAnnualHomeInsurance: number | undefined;
  currentlyUsingHomeAs: string | undefined;
  isMilitaryMember: number | undefined;
  currentMilitaryStatus: string | undefined;
  militaryBranch: string | undefined;
  isEtsdateinYear: number | undefined;
  etsdate: moment.Moment | undefined;
  isValoanPreviously: number | undefined;
  whoLivingInHome: string | undefined;
  propertyLegalFirstName: string | undefined;
  propertyMiddleInitial: string | undefined;
  propertyLegalLastName: string | undefined;
  propertyPhoneNumber: string | undefined;
  propertyEmailAddress: string | undefined;
  propertyPassword: string | undefined;
  isSomeoneRefer: number | undefined;
  refferedBy: string | undefined;
  isApplyOwn: number | undefined;
  isLegalSpouse: number | undefined;
  maritialStatus: string | undefined;
  numberOfDependents: number | undefined;
  firstDependantAge: number | undefined;
  isCurrentlyLivingOnRefinancingProperty: number | undefined;
  currentAddress: string | undefined;
  currentUnit: string | undefined;
  currentCity: string | undefined;
  currentStateId: number;
  currentZipCode: string | undefined;
  currentStartLivingDate: moment.Moment | undefined;
  currentReantingType: string | undefined;
  estimatedMonthlyExpenses: number | undefined;
  personalLegalFirstName: string | undefined;
  personalMiddleInitial: string | undefined;
  personalLegalLastName: string | undefined;
  personalPhoneNumber: string | undefined;
  personalEmailAddress: string | undefined;
  personalPassword: string | undefined;
  isAddressSameAsPrimaryBorrower: number | undefined;
  personalAddress: string | undefined;
  personalUnit: string | undefined;
  personalCity: string | undefined;
  personalStateId: number;
  personalZipCode: string | undefined;
  personalStartLivingDate: moment.Moment | undefined;
  personalReantingType: string | undefined;
  isEmployementHistory: number | undefined;
  isCoBorrowerHaveShareIncome: number | undefined;
  sex: string | undefined;
  ethnicity: string | undefined;
  race: string | undefined;
  citizenshipId: number;
  isCertify: number | undefined;
  isReadEconsent: number | undefined;
  isReadThirdPartyConsent: number | undefined;
  socialSecurityNumber: string | undefined;
  conformSsn: string | undefined;
  birthDate: moment.Moment | undefined;
  id: number;
}

export class UpdateLeadRefinancingIncomeDetails
  implements IUpdateLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;
  id: number;

  constructor(data?: IUpdateLeadRefinancingIncomeDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.leadApplicationDetailRefinancingId =
        _data["leadApplicationDetailRefinancingId"];
      this.leadApplicationTypeId = _data["leadApplicationTypeId"];
      this.incomeTypeId = _data["incomeTypeId"];
      this.monthlyAmount = _data["monthlyAmount"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadRefinancingIncomeDetails {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadRefinancingIncomeDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "leadApplicationDetailRefinancingId"
    ] = this.leadApplicationDetailRefinancingId;
    data["leadApplicationTypeId"] = this.leadApplicationTypeId;
    data["incomeTypeId"] = this.incomeTypeId;
    data["monthlyAmount"] = this.monthlyAmount;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadRefinancingIncomeDetails {
    const json = this.toJSON();
    let result = new UpdateLeadRefinancingIncomeDetails();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadRefinancingIncomeDetails {
  leadApplicationDetailRefinancingId: number | undefined;
  leadApplicationTypeId: number | undefined;
  incomeTypeId: number;
  monthlyAmount: number | undefined;
  id: number;
}

export class UpdateLeadTaxTypes implements IUpdateLeadTaxTypes {
  taxesType: string | undefined;
  id: number;

  constructor(data?: IUpdateLeadTaxTypes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.taxesType = _data["taxesType"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLeadTaxTypes {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLeadTaxTypes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["taxesType"] = this.taxesType;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLeadTaxTypes {
    const json = this.toJSON();
    let result = new UpdateLeadTaxTypes();
    result.init(json);
    return result;
  }
}

export interface IUpdateLeadTaxTypes {
  taxesType: string | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationGiftRequest
  implements IUpdateLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationGiftRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanPropertyGiftTypeId4d1 = _data["loanPropertyGiftTypeId4d1"];
      this.deposited4d2 = _data["deposited4d2"];
      this.source4d3 = _data["source4d3"];
      this.value4d4 = _data["value4d4"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanAndPropertyInformationGiftRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationGiftRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanPropertyGiftTypeId4d1"] = this.loanPropertyGiftTypeId4d1;
    data["deposited4d2"] = this.deposited4d2;
    data["source4d3"] = this.source4d3;
    data["value4d4"] = this.value4d4;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationGiftRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationGiftRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationGiftRequest {
  applicationPersonalInformationId: number | undefined;
  loanPropertyGiftTypeId4d1: number | undefined;
  deposited4d2: number | undefined;
  source4d3: string | undefined;
  value4d4: number | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationOtherMortageLoanRequest
  implements IUpdateLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationOtherMortageLoanRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.creditorName4b1 = _data["creditorName4b1"];
      this.lienType4b2 = _data["lienType4b2"];
      this.monthlyPayment4b3 = _data["monthlyPayment4b3"];
      this.loanAmount4b4 = _data["loanAmount4b4"];
      this.creditAmount4b5 = _data["creditAmount4b5"];
      this.id = _data["id"];
    }
  }

  static fromJS(
    data: any
  ): UpdateLoanAndPropertyInformationOtherMortageLoanRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["creditorName4b1"] = this.creditorName4b1;
    data["lienType4b2"] = this.lienType4b2;
    data["monthlyPayment4b3"] = this.monthlyPayment4b3;
    data["loanAmount4b4"] = this.loanAmount4b4;
    data["creditAmount4b5"] = this.creditAmount4b5;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationOtherMortageLoanRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationOtherMortageLoanRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationOtherMortageLoanRequest {
  applicationPersonalInformationId: number | undefined;
  creditorName4b1: string | undefined;
  lienType4b2: string | undefined;
  monthlyPayment4b3: number | undefined;
  loanAmount4b4: number | undefined;
  creditAmount4b5: number | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationRentalIncomeRequest
  implements IUpdateLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationRentalIncomeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.expectedMonthlyIncome4c1 = _data["expectedMonthlyIncome4c1"];
      this.lenderExpectedMonthlyIncome4c2 =
        _data["lenderExpectedMonthlyIncome4c2"];
      this.id = _data["id"];
    }
  }

  static fromJS(
    data: any
  ): UpdateLoanAndPropertyInformationRentalIncomeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationRentalIncomeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["expectedMonthlyIncome4c1"] = this.expectedMonthlyIncome4c1;
    data[
      "lenderExpectedMonthlyIncome4c2"
    ] = this.lenderExpectedMonthlyIncome4c2;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationRentalIncomeRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationRentalIncomeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationRentalIncomeRequest {
  applicationPersonalInformationId: number | undefined;
  expectedMonthlyIncome4c1: number | undefined;
  lenderExpectedMonthlyIncome4c2: number | undefined;
  id: number;
}

export class UpdateLoanAndPropertyInformationRequest
  implements IUpdateLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;
  id: number;

  constructor(data?: IUpdateLoanAndPropertyInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.loanAmount4a1 = _data["loanAmount4a1"];
      this.loanPurpose4a2 = _data["loanPurpose4a2"];
      this.propertyStreet4a31 = _data["propertyStreet4a31"];
      this.propertyUnitNo4a32 = _data["propertyUnitNo4a32"];
      this.propertyZip4a35 = _data["propertyZip4a35"];
      this.countryId4a36 = _data["countryId4a36"];
      this.stateId4a34 = _data["stateId4a34"];
      this.cityId4a33 = _data["cityId4a33"];
      this.propertyNumberUnits4a4 = _data["propertyNumberUnits4a4"];
      this.propertyValue4a5 = _data["propertyValue4a5"];
      this.loanPropertyOccupancyId4a6 = _data["loanPropertyOccupancyId4a6"];
      this.fhaSecondaryResidance4a61 = _data["fhaSecondaryResidance4a61"];
      this.isMixedUseProperty4a7 = _data["isMixedUseProperty4a7"];
      this.isManufacturedHome4a8 = _data["isManufacturedHome4a8"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanAndPropertyInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanAndPropertyInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["loanAmount4a1"] = this.loanAmount4a1;
    data["loanPurpose4a2"] = this.loanPurpose4a2;
    data["propertyStreet4a31"] = this.propertyStreet4a31;
    data["propertyUnitNo4a32"] = this.propertyUnitNo4a32;
    data["propertyZip4a35"] = this.propertyZip4a35;
    data["countryId4a36"] = this.countryId4a36;
    data["stateId4a34"] = this.stateId4a34;
    data["cityId4a33"] = this.cityId4a33;
    data["propertyNumberUnits4a4"] = this.propertyNumberUnits4a4;
    data["propertyValue4a5"] = this.propertyValue4a5;
    data["loanPropertyOccupancyId4a6"] = this.loanPropertyOccupancyId4a6;
    data["fhaSecondaryResidance4a61"] = this.fhaSecondaryResidance4a61;
    data["isMixedUseProperty4a7"] = this.isMixedUseProperty4a7;
    data["isManufacturedHome4a8"] = this.isManufacturedHome4a8;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanAndPropertyInformationRequest {
    const json = this.toJSON();
    let result = new UpdateLoanAndPropertyInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanAndPropertyInformationRequest {
  applicationPersonalInformationId: number | undefined;
  loanAmount4a1: number | undefined;
  loanPurpose4a2: string | undefined;
  propertyStreet4a31: string | undefined;
  propertyUnitNo4a32: string | undefined;
  propertyZip4a35: string | undefined;
  countryId4a36: number;
  stateId4a34: number;
  cityId4a33: number;
  propertyNumberUnits4a4: number | undefined;
  propertyValue4a5: number | undefined;
  loanPropertyOccupancyId4a6: number | undefined;
  fhaSecondaryResidance4a61: number | undefined;
  isMixedUseProperty4a7: number | undefined;
  isManufacturedHome4a8: number | undefined;
  id: number;
}

export class UpdateLoanOriginatorInformationRequest
  implements IUpdateLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;
  id: number;

  constructor(data?: IUpdateLoanOriginatorInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.organizationName91 = _data["organizationName91"];
      this.address92 = _data["address92"];
      this.organizationNmlsrId93 = _data["organizationNmlsrId93"];
      this.organizationStateLicence94 = _data["organizationStateLicence94"];
      this.originatorName95 = _data["originatorName95"];
      this.originatorNmlsrId96 = _data["originatorNmlsrId96"];
      this.originatorStateLicense97 = _data["originatorStateLicense97"];
      this.email98 = _data["email98"];
      this.phone99 = _data["phone99"];
      this.date910 = _data["date910"]
        ? moment(_data["date910"].toString())
        : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanOriginatorInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanOriginatorInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["organizationName91"] = this.organizationName91;
    data["address92"] = this.address92;
    data["organizationNmlsrId93"] = this.organizationNmlsrId93;
    data["organizationStateLicence94"] = this.organizationStateLicence94;
    data["originatorName95"] = this.originatorName95;
    data["originatorNmlsrId96"] = this.originatorNmlsrId96;
    data["originatorStateLicense97"] = this.originatorStateLicense97;
    data["email98"] = this.email98;
    data["phone99"] = this.phone99;
    data["date910"] = this.date910
      ? this.date910.toISOString()
      : <any>undefined;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanOriginatorInformationRequest {
    const json = this.toJSON();
    let result = new UpdateLoanOriginatorInformationRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanOriginatorInformationRequest {
  applicationPersonalInformationId: number | undefined;
  organizationName91: string | undefined;
  address92: string | undefined;
  organizationNmlsrId93: string | undefined;
  organizationStateLicence94: string | undefined;
  originatorName95: string | undefined;
  originatorNmlsrId96: string | undefined;
  originatorStateLicense97: string | undefined;
  email98: string | undefined;
  phone99: string | undefined;
  date910: moment.Moment | undefined;
  id: number;
}

export class UpdateLoanPropertyGiftTypeRequest
  implements IUpdateLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;
  id: number;

  constructor(data?: IUpdateLoanPropertyGiftTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyGiftType1 = _data["loanPropertyGiftType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanPropertyGiftTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanPropertyGiftTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyGiftType1"] = this.loanPropertyGiftType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanPropertyGiftTypeRequest {
    const json = this.toJSON();
    let result = new UpdateLoanPropertyGiftTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanPropertyGiftTypeRequest {
  loanPropertyGiftType1: string | undefined;
  id: number;
}

export class UpdateLoanPropertyOccupancyRequest
  implements IUpdateLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;
  id: number;

  constructor(data?: IUpdateLoanPropertyOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanPropertyOccupancy1 = _data["loanPropertyOccupancy1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateLoanPropertyOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateLoanPropertyOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanPropertyOccupancy1"] = this.loanPropertyOccupancy1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateLoanPropertyOccupancyRequest {
    const json = this.toJSON();
    let result = new UpdateLoanPropertyOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateLoanPropertyOccupancyRequest {
  loanPropertyOccupancy1: string | undefined;
  id: number;
}

export class UpdateMaritalStatusRequest implements IUpdateMaritalStatusRequest {
  maritialStatus1: string | undefined;
  id: number;

  constructor(data?: IUpdateMaritalStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.maritialStatus1 = _data["maritialStatus1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMaritalStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMaritalStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["maritialStatus1"] = this.maritialStatus1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMaritalStatusRequest {
    const json = this.toJSON();
    let result = new UpdateMaritalStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMaritalStatusRequest {
  maritialStatus1: string | undefined;
  id: number;
}

export class UpdateMilitaryServiceRequest
  implements IUpdateMilitaryServiceRequest {
  applicationPersonalInformationId: number | undefined;
  servedInForces7a1: number | undefined;
  currentlyServing7a2: number | undefined;
  dateOfServiceExpiration7a3: moment.Moment | undefined;
  retired7a2: number | undefined;
  nonActivatedMember7a2: number | undefined;
  survivingSpouse7a21: number | undefined;
  id: number;

  constructor(data?: IUpdateMilitaryServiceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationPersonalInformationId =
        _data["applicationPersonalInformationId"];
      this.servedInForces7a1 = _data["servedInForces7a1"];
      this.currentlyServing7a2 = _data["currentlyServing7a2"];
      this.dateOfServiceExpiration7a3 = _data["dateOfServiceExpiration7a3"]
        ? moment(_data["dateOfServiceExpiration7a3"].toString())
        : <any>undefined;
      this.retired7a2 = _data["retired7a2"];
      this.nonActivatedMember7a2 = _data["nonActivatedMember7a2"];
      this.survivingSpouse7a21 = _data["survivingSpouse7a21"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMilitaryServiceRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMilitaryServiceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationPersonalInformationId"
    ] = this.applicationPersonalInformationId;
    data["servedInForces7a1"] = this.servedInForces7a1;
    data["currentlyServing7a2"] = this.currentlyServing7a2;
    data["dateOfServiceExpiration7a3"] = this.dateOfServiceExpiration7a3
      ? this.dateOfServiceExpiration7a3.toISOString()
      : <any>undefined;
    data["retired7a2"] = this.retired7a2;
    data["nonActivatedMember7a2"] = this.nonActivatedMember7a2;
    data["survivingSpouse7a21"] = this.survivingSpouse7a21;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMilitaryServiceRequest {
    const json = this.toJSON();
    let result = new UpdateMilitaryServiceRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMilitaryServiceRequest {
  applicationPersonalInformationId: number | undefined;
  servedInForces7a1: number | undefined;
  currentlyServing7a2: number | undefined;
  dateOfServiceExpiration7a3: moment.Moment | undefined;
  retired7a2: number | undefined;
  nonActivatedMember7a2: number | undefined;
  survivingSpouse7a21: number | undefined;
  id: number;
}

export class UpdateMortageLoanOnPropertyRequest
  implements IUpdateMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;
  id: number;

  constructor(data?: IUpdateMortageLoanOnPropertyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.applicationFinancialRealEstateId =
        _data["applicationFinancialRealEstateId"];
      this.creditorName3a9 = _data["creditorName3a9"];
      this.accountNumber3a10 = _data["accountNumber3a10"];
      this.monthlyMortagePayment3a11 = _data["monthlyMortagePayment3a11"];
      this.unpaidBalance3a12 = _data["unpaidBalance3a12"];
      this.paidOff3a13 = _data["paidOff3a13"];
      this.mortageLoanTypesId3a14 = _data["mortageLoanTypesId3a14"];
      this.creditLimit3a15 = _data["creditLimit3a15"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMortageLoanOnPropertyRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMortageLoanOnPropertyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "applicationFinancialRealEstateId"
    ] = this.applicationFinancialRealEstateId;
    data["creditorName3a9"] = this.creditorName3a9;
    data["accountNumber3a10"] = this.accountNumber3a10;
    data["monthlyMortagePayment3a11"] = this.monthlyMortagePayment3a11;
    data["unpaidBalance3a12"] = this.unpaidBalance3a12;
    data["paidOff3a13"] = this.paidOff3a13;
    data["mortageLoanTypesId3a14"] = this.mortageLoanTypesId3a14;
    data["creditLimit3a15"] = this.creditLimit3a15;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMortageLoanOnPropertyRequest {
    const json = this.toJSON();
    let result = new UpdateMortageLoanOnPropertyRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMortageLoanOnPropertyRequest {
  applicationFinancialRealEstateId: number | undefined;
  creditorName3a9: string | undefined;
  accountNumber3a10: string | undefined;
  monthlyMortagePayment3a11: number | undefined;
  unpaidBalance3a12: number | undefined;
  paidOff3a13: number | undefined;
  mortageLoanTypesId3a14: number;
  creditLimit3a15: number | undefined;
  id: number;
}

export class UpdateMortageLoanTypeRequest
  implements IUpdateMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;
  id: number;

  constructor(data?: IUpdateMortageLoanTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mortageLoanTypesId = _data["mortageLoanTypesId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateMortageLoanTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMortageLoanTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["mortageLoanTypesId"] = this.mortageLoanTypesId;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateMortageLoanTypeRequest {
    const json = this.toJSON();
    let result = new UpdateMortageLoanTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateMortageLoanTypeRequest {
  mortageLoanTypesId: string | undefined;
  id: number;
}

export class UpdateOtherLaibilitiesTypeRequest
  implements IUpdateOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;
  id: number;

  constructor(data?: IUpdateOtherLaibilitiesTypeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialOtherLaibilitiesType1 =
        _data["financialOtherLaibilitiesType1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateOtherLaibilitiesTypeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateOtherLaibilitiesTypeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialOtherLaibilitiesType1"
    ] = this.financialOtherLaibilitiesType1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateOtherLaibilitiesTypeRequest {
    const json = this.toJSON();
    let result = new UpdateOtherLaibilitiesTypeRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateOtherLaibilitiesTypeRequest {
  financialOtherLaibilitiesType1: string | undefined;
  id: number;
}

export class UpdatePropertyIntendedOccupancyRequest
  implements IUpdatePropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;
  id: number;

  constructor(data?: IUpdatePropertyIntendedOccupancyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyIntendedOccupancy1 =
        _data["financialPropertyIntendedOccupancy1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdatePropertyIntendedOccupancyRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePropertyIntendedOccupancyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data[
      "financialPropertyIntendedOccupancy1"
    ] = this.financialPropertyIntendedOccupancy1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdatePropertyIntendedOccupancyRequest {
    const json = this.toJSON();
    let result = new UpdatePropertyIntendedOccupancyRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePropertyIntendedOccupancyRequest {
  financialPropertyIntendedOccupancy1: string | undefined;
  id: number;
}

export class UpdatePropertyStatusRequest
  implements IUpdatePropertyStatusRequest {
  financialPropertyStatus1: string | undefined;
  id: number;

  constructor(data?: IUpdatePropertyStatusRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.financialPropertyStatus1 = _data["financialPropertyStatus1"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdatePropertyStatusRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePropertyStatusRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["financialPropertyStatus1"] = this.financialPropertyStatus1;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdatePropertyStatusRequest {
    const json = this.toJSON();
    let result = new UpdatePropertyStatusRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdatePropertyStatusRequest {
  financialPropertyStatus1: string | undefined;
  id: number;
}

export class UpdateStateRequest implements IUpdateStateRequest {
  countryId: number;
  stateName: string | undefined;
  id: number;

  constructor(data?: IUpdateStateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryId = _data["countryId"];
      this.stateName = _data["stateName"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateStateRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateStateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryId"] = this.countryId;
    data["stateName"] = this.stateName;
    data["id"] = this.id;
    return data;
  }

  clone(): UpdateStateRequest {
    const json = this.toJSON();
    let result = new UpdateStateRequest();
    result.init(json);
    return result;
  }
}

export interface IUpdateStateRequest {
  countryId: number;
  stateName: string | undefined;
  id: number;
}

export class UploadAdminLoanApplicationDocument
  implements IUploadAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number;
  formFile: string | undefined;

  constructor(data?: IUploadAdminLoanApplicationDocument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loanId = _data["loanId"];
      this.disclosureId = _data["disclosureId"];
      this.userId = _data["userId"];
      this.formFile = _data["formFile"];
    }
  }

  static fromJS(data: any): UploadAdminLoanApplicationDocument {
    data = typeof data === "object" ? data : {};
    let result = new UploadAdminLoanApplicationDocument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["loanId"] = this.loanId;
    data["disclosureId"] = this.disclosureId;
    data["userId"] = this.userId;
    data["formFile"] = this.formFile;
    return data;
  }

  clone(): UploadAdminLoanApplicationDocument {
    const json = this.toJSON();
    let result = new UploadAdminLoanApplicationDocument();
    result.init(json);
    return result;
  }
}

export interface IUploadAdminLoanApplicationDocument {
  loanId: number;
  disclosureId: number;
  userId: number;
  formFile: string | undefined;
}

export class UserDto implements IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      this.fullName = _data["fullName"];
      this.lastLoginTime = _data["lastLoginTime"]
        ? moment(_data["lastLoginTime"].toString())
        : <any>undefined;
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    data["fullName"] = this.fullName;
    data["lastLoginTime"] = this.lastLoginTime
      ? this.lastLoginTime.toISOString()
      : <any>undefined;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    return data;
  }

  clone(): UserDto {
    const json = this.toJSON();
    let result = new UserDto();
    result.init(json);
    return result;
  }
}

export interface IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;

  constructor(data?: IUserDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(UserDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): UserDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): UserDtoPagedResultDto {
    const json = this.toJSON();
    let result = new UserDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;

  constructor(data?: IUserLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
    }
  }

  static fromJS(data: any): UserLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new UserLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    return data;
  }

  clone(): UserLoginInfoDto {
    const json = this.toJSON();
    let result = new UserLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
}

export class UserNotification implements IUserNotification {
  id: string;
  tenantId: number | undefined;
  userId: number;
  state: UserNotificationState;
  notification: TenantNotification;

  constructor(data?: IUserNotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenantId = _data["tenantId"];
      this.userId = _data["userId"];
      this.state = _data["state"];
      this.notification = _data["notification"]
        ? TenantNotification.fromJS(_data["notification"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UserNotification {
    data = typeof data === "object" ? data : {};
    let result = new UserNotification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenantId"] = this.tenantId;
    data["userId"] = this.userId;
    data["state"] = this.state;
    data["notification"] = this.notification
      ? this.notification.toJSON()
      : <any>undefined;
    return data;
  }

  clone(): UserNotification {
    const json = this.toJSON();
    let result = new UserNotification();
    result.init(json);
    return result;
  }
}

export interface IUserNotification {
  id: string;
  tenantId: number | undefined;
  userId: number;
  state: UserNotificationState;
  notification: TenantNotification;
}

export enum UserNotificationState {
  _0 = 0,
  _1 = 1,
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
